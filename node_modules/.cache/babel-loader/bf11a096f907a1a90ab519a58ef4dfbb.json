{"ast":null,"code":"/* eslint-disable no-use-before-define */\nconst findSchemaDefinition = require('./find-schema-definition');\n\nconst flattenArray = require('./flatten-array');\n\nconst getName = (parent, prop) => {\n  if (!parent) return prop;\n  if (parent[parent.length - 1] === ' ') return `${parent}${prop}`;\n  return `${parent}.${prop}`;\n};\n\nconst capitalizeFirstLetter = (string = '') => string.charAt(0).toUpperCase() + string.slice(1);\n\nmodule.exports = (schema, oas) => {\n  function flattenObject(obj, parent, level) {\n    return flattenArray(Object.keys(obj.properties).map(prop => {\n      let value = obj.properties[prop];\n      let array = [];\n\n      if (value.$ref) {\n        value = findSchemaDefinition(value.$ref, oas);\n      } // If `value` doesn't have an explicit `type` declaration, but has `properties` present, then\n      // it's an object and should be treated as one.\n\n\n      if (!('type' in value) && value.properties) {\n        value.type = 'object';\n      }\n\n      if (value.type === 'object') {\n        array.push(flattenSchema(value, getName(parent, prop), level + 1));\n      }\n\n      if (value.type === 'array' && value.items) {\n        let {\n          items\n        } = value;\n\n        if (items.$ref) {\n          items = findSchemaDefinition(items.$ref, oas);\n        } // If `value` doesn't have an explicit `type` declaration, but has `properties` present,\n        // then it's an object and should be treated as one.\n\n\n        if (!('type' in items) && items.properties) {\n          items.type = 'object';\n        }\n\n        let newParent = parent ? `${parent}.` : '';\n        newParent = `${newParent}${prop}[]`;\n\n        if (items.type) {\n          array.push({\n            name: getName(parent, prop),\n            type: `[${capitalizeFirstLetter(items.type)}]`,\n            description: value.description\n          });\n\n          if (items.type === 'object') {\n            array.push(flattenSchema(items, newParent, level + 1));\n          }\n        } else if ('allOf' in items || 'oneOf' in items || 'anyOf' in items || '$ref' in items) {\n          array = array.concat(flattenSchema(items, newParent, level));\n        }\n\n        return array;\n      }\n\n      array.unshift({\n        name: getName(parent, prop),\n        type: capitalizeFirstLetter(value.type),\n        description: value.description\n      });\n      return array;\n    }));\n  }\n\n  function flattenSchema(obj, parent = '', level = 0) {\n    if (level > 2) {\n      return [];\n    } // If we don't actually have an object here, don't try to treat it as one.\n    //\n    // This might happen in the event of a $ref being improperly written as the value of a non-$ref object property.\n    // For example: `\"schema\": \"~paths~/pet~post~requestBody~content~application/json~schema\"`.\n\n\n    if (obj === null || typeof obj !== 'object') {\n      return [];\n    }\n\n    if ('allOf' in obj) {\n      let allof = [];\n      obj.allOf.forEach(item => {\n        allof = allof.concat(flattenSchema(item, parent, level));\n      });\n      return allof;\n    } else if ('oneOf' in obj || 'anyOf' in obj) {\n      // Since we can't merge flatten objects in a `oneOf` or `anyOf` representation into a single structure, because\n      // that wouldn't validate against the defined schema, we're instead just pick the first one present and\n      // flattening only that one.\n      //\n      // This work will be somewhat resolved when we start to render response schemas in an improved, non-flattened list\n      // in a future API Explorer redesign, but until then we have no other option other than to have partial\n      // documentation data loss in the frontend.\n      //\n      // See https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/ for full documentation on how\n      // these polymorphism traits work and why we need to have these quirks.\n      if ('oneOf' in obj) {\n        return flattenSchema(obj.oneOf.shift(), parent, level);\n      }\n\n      return flattenSchema(obj.anyOf.shift());\n    } else if ('$ref' in obj) {\n      const value = findSchemaDefinition(obj.$ref, oas);\n      return flattenSchema(value, parent, level);\n    } // top level array\n\n\n    if (obj.type === 'array' && obj.items) {\n      const newParent = parent ? `${parent}.[]` : '';\n\n      if (obj.items.$ref) {\n        const value = findSchemaDefinition(obj.items.$ref, oas);\n        return flattenSchema(value, newParent, level);\n      }\n\n      return flattenSchema(obj.items, `${newParent}`, level + 1);\n    }\n\n    if (obj && !obj.properties) {\n      return [];\n    }\n\n    return flattenObject(obj, parent, level);\n  }\n\n  return flattenSchema(schema);\n};","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@readme/oas-tooling/src/lib/flatten-schema.js"],"names":["findSchemaDefinition","require","flattenArray","getName","parent","prop","length","capitalizeFirstLetter","string","charAt","toUpperCase","slice","module","exports","schema","oas","flattenObject","obj","level","Object","keys","properties","map","value","array","$ref","type","push","flattenSchema","items","newParent","name","description","concat","unshift","allof","allOf","forEach","item","oneOf","shift","anyOf"],"mappings":"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","sourcesContent":["/* eslint-disable no-use-before-define */\nconst findSchemaDefinition = require('./find-schema-definition');\nconst flattenArray = require('./flatten-array');\n\nconst getName = (parent, prop) => {\n  if (!parent) return prop;\n  if (parent[parent.length - 1] === ' ') return `${parent}${prop}`;\n\n  return `${parent}.${prop}`;\n};\n\nconst capitalizeFirstLetter = (string = '') => string.charAt(0).toUpperCase() + string.slice(1);\n\nmodule.exports = (schema, oas) => {\n  function flattenObject(obj, parent, level) {\n    return flattenArray(\n      Object.keys(obj.properties).map(prop => {\n        let value = obj.properties[prop];\n        let array = [];\n        if (value.$ref) {\n          value = findSchemaDefinition(value.$ref, oas);\n        }\n\n        // If `value` doesn't have an explicit `type` declaration, but has `properties` present, then\n        // it's an object and should be treated as one.\n        if (!('type' in value) && value.properties) {\n          value.type = 'object';\n        }\n\n        if (value.type === 'object') {\n          array.push(flattenSchema(value, getName(parent, prop), level + 1));\n        }\n\n        if (value.type === 'array' && value.items) {\n          let { items } = value;\n          if (items.$ref) {\n            items = findSchemaDefinition(items.$ref, oas);\n          }\n\n          // If `value` doesn't have an explicit `type` declaration, but has `properties` present,\n          // then it's an object and should be treated as one.\n          if (!('type' in items) && items.properties) {\n            items.type = 'object';\n          }\n\n          let newParent = parent ? `${parent}.` : '';\n          newParent = `${newParent}${prop}[]`;\n          if (items.type) {\n            array.push({\n              name: getName(parent, prop),\n              type: `[${capitalizeFirstLetter(items.type)}]`,\n              description: value.description,\n            });\n\n            if (items.type === 'object') {\n              array.push(flattenSchema(items, newParent, level + 1));\n            }\n          } else if ('allOf' in items || 'oneOf' in items || 'anyOf' in items || '$ref' in items) {\n            array = array.concat(flattenSchema(items, newParent, level));\n          }\n\n          return array;\n        }\n\n        array.unshift({\n          name: getName(parent, prop),\n          type: capitalizeFirstLetter(value.type),\n          description: value.description,\n        });\n\n        return array;\n      })\n    );\n  }\n\n  function flattenSchema(obj, parent = '', level = 0) {\n    if (level > 2) {\n      return [];\n    }\n\n    // If we don't actually have an object here, don't try to treat it as one.\n    //\n    // This might happen in the event of a $ref being improperly written as the value of a non-$ref object property.\n    // For example: `\"schema\": \"~paths~/pet~post~requestBody~content~application/json~schema\"`.\n    if (obj === null || typeof obj !== 'object') {\n      return [];\n    }\n\n    if ('allOf' in obj) {\n      let allof = [];\n      obj.allOf.forEach(item => {\n        allof = allof.concat(flattenSchema(item, parent, level));\n      });\n\n      return allof;\n    } else if ('oneOf' in obj || 'anyOf' in obj) {\n      // Since we can't merge flatten objects in a `oneOf` or `anyOf` representation into a single structure, because\n      // that wouldn't validate against the defined schema, we're instead just pick the first one present and\n      // flattening only that one.\n      //\n      // This work will be somewhat resolved when we start to render response schemas in an improved, non-flattened list\n      // in a future API Explorer redesign, but until then we have no other option other than to have partial\n      // documentation data loss in the frontend.\n      //\n      // See https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/ for full documentation on how\n      // these polymorphism traits work and why we need to have these quirks.\n      if ('oneOf' in obj) {\n        return flattenSchema(obj.oneOf.shift(), parent, level);\n      }\n\n      return flattenSchema(obj.anyOf.shift());\n    } else if ('$ref' in obj) {\n      const value = findSchemaDefinition(obj.$ref, oas);\n      return flattenSchema(value, parent, level);\n    }\n\n    // top level array\n    if (obj.type === 'array' && obj.items) {\n      const newParent = parent ? `${parent}.[]` : '';\n\n      if (obj.items.$ref) {\n        const value = findSchemaDefinition(obj.items.$ref, oas);\n        return flattenSchema(value, newParent, level);\n      }\n\n      return flattenSchema(obj.items, `${newParent}`, level + 1);\n    }\n\n    if (obj && !obj.properties) {\n      return [];\n    }\n\n    return flattenObject(obj, parent, level);\n  }\n\n  return flattenSchema(schema);\n};\n"]},"metadata":{},"sourceType":"script"}