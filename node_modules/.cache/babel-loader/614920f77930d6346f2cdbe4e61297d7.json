{"ast":null,"code":"const findSchemaDefinition = require('./lib/find-schema-definition');\n\nclass Operation {\n  constructor(oas, path, method, operation) {\n    Object.assign(this, operation);\n    this.oas = oas;\n    this.path = path;\n    this.method = method;\n  }\n\n  getContentType() {\n    const types = this.requestBody && this.requestBody.content && Object.keys(this.requestBody.content) || [];\n    let type = 'application/json';\n\n    if (types && types.length) {\n      type = types[0];\n    } // Favor JSON if it exists\n\n\n    types.forEach(t => {\n      if (t.match(/json/)) {\n        type = t;\n      }\n    });\n    return type;\n  }\n\n  getSecurity() {\n    return this.security || this.oas.security || [];\n  }\n\n  prepareSecurity() {\n    const securityRequirements = this.getSecurity();\n    return securityRequirements.map(requirement => {\n      let keys;\n\n      try {\n        keys = Object.keys(requirement);\n      } catch (e) {\n        return false;\n      }\n\n      return keys.map(key => {\n        let security;\n\n        try {\n          security = this.oas.components.securitySchemes[key];\n        } catch (e) {\n          return false;\n        }\n\n        if (!security) return false;\n        let {\n          type\n        } = security;\n\n        if (security.type === 'http') {\n          if (security.scheme === 'basic') type = 'Basic';\n          if (security.scheme === 'bearer') type = 'Bearer';\n        } else if (security.type === 'oauth2') {\n          type = 'OAuth2';\n        } else if (security.type === 'apiKey') {\n          if (security.in === 'query') type = 'Query';else if (security.in === 'header' || security.in === 'cookie') type = 'Header';\n        } else {\n          return false;\n        } // eslint-disable-next-line no-underscore-dangle\n\n\n        security._key = key;\n        return {\n          type,\n          security\n        };\n      });\n    }).reduce((prev, securities) => {\n      securities.forEach(security => {\n        // Remove non-existent schemes\n        if (!security) return;\n        if (!prev[security.type]) prev[security.type] = [];\n        prev[security.type].push(security.security);\n      });\n      return prev;\n    }, {});\n  }\n\n  getHeaders() {\n    this.headers = {\n      request: [],\n      response: []\n    };\n    const security = this.prepareSecurity();\n\n    if (security.Header) {\n      this.headers.request = security.Header.map(h => {\n        if (h.in === 'cookie') return 'Cookie';\n        return h.name;\n      });\n    }\n\n    if (security.Bearer || security.Basic) {\n      this.headers.request.push('Authorization');\n    }\n\n    if (this.parameters) {\n      this.headers.request = this.headers.request.concat(this.parameters.map(p => {\n        if (p.in && p.in === 'header') return p.name;\n\n        if (p.$ref) {\n          const {\n            name\n          } = findSchemaDefinition(p.$ref, this.oas);\n          return name;\n        }\n\n        return undefined;\n      }).filter(p => p));\n    }\n\n    this.headers.response = Object.keys(this.responses).filter(r => this.responses[r].headers).map(r => Object.keys(this.responses[r].headers)).reduce((a, b) => a.concat(b), []); // If the operation doesn't already specify a 'content-type' request header,\n    // we check if the path operation request body contains content, which implies that\n    // we should also include the 'content-type' header.\n\n    if (!this.headers.request.includes('Content-Type') && this.requestBody) {\n      if (this.requestBody.$ref) {\n        const ref = findSchemaDefinition(this.requestBody.$ref, this.oas);\n        if (ref.content && Object.keys(ref.content)) this.headers.request.push('Content-Type');\n      } else if (this.requestBody.content && Object.keys(this.requestBody.content)) this.headers.request.push('Content-Type');\n    } // This is a similar approach, but in this case if we check the response content\n    // and prioritize the 'accept' request header and 'content-type' request header\n\n\n    if (this.responses) {\n      if (Object.keys(this.responses).some(response => !!this.responses[response].content)) {\n        if (!this.headers.request.includes('Accept')) this.headers.request.push('Accept');\n        if (!this.headers.response.includes('Content-Type')) this.headers.response.push('Content-Type');\n      }\n    }\n\n    return this.headers;\n  }\n\n}\n\nmodule.exports = Operation;","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@readme/oas-tooling/src/operation.js"],"names":["findSchemaDefinition","require","Operation","constructor","oas","path","method","operation","Object","assign","getContentType","types","requestBody","content","keys","type","length","forEach","t","match","getSecurity","security","prepareSecurity","securityRequirements","map","requirement","e","key","components","securitySchemes","scheme","in","_key","reduce","prev","securities","push","getHeaders","headers","request","response","Header","h","name","Bearer","Basic","parameters","concat","p","$ref","undefined","filter","responses","r","a","b","includes","ref","some","module","exports"],"mappings":"AAAA,MAAMA,oBAAoB,GAAGC,OAAO,CAAC,8BAAD,CAApC;;AAEA,MAAMC,SAAN,CAAgB;AACdC,EAAAA,WAAW,CAACC,GAAD,EAAMC,IAAN,EAAYC,MAAZ,EAAoBC,SAApB,EAA+B;AACxCC,IAAAA,MAAM,CAACC,MAAP,CAAc,IAAd,EAAoBF,SAApB;AACA,SAAKH,GAAL,GAAWA,GAAX;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,MAAL,GAAcA,MAAd;AACD;;AAEDI,EAAAA,cAAc,GAAG;AACf,UAAMC,KAAK,GAAI,KAAKC,WAAL,IAAoB,KAAKA,WAAL,CAAiBC,OAArC,IAAgDL,MAAM,CAACM,IAAP,CAAY,KAAKF,WAAL,CAAiBC,OAA7B,CAAjD,IAA2F,EAAzG;AAEA,QAAIE,IAAI,GAAG,kBAAX;;AACA,QAAIJ,KAAK,IAAIA,KAAK,CAACK,MAAnB,EAA2B;AACzBD,MAAAA,IAAI,GAAGJ,KAAK,CAAC,CAAD,CAAZ;AACD,KANc,CAQf;;;AACAA,IAAAA,KAAK,CAACM,OAAN,CAAcC,CAAC,IAAI;AACjB,UAAIA,CAAC,CAACC,KAAF,CAAQ,MAAR,CAAJ,EAAqB;AACnBJ,QAAAA,IAAI,GAAGG,CAAP;AACD;AACF,KAJD;AAMA,WAAOH,IAAP;AACD;;AAEDK,EAAAA,WAAW,GAAG;AACZ,WAAO,KAAKC,QAAL,IAAiB,KAAKjB,GAAL,CAASiB,QAA1B,IAAsC,EAA7C;AACD;;AAEDC,EAAAA,eAAe,GAAG;AAChB,UAAMC,oBAAoB,GAAG,KAAKH,WAAL,EAA7B;AAEA,WAAOG,oBAAoB,CACxBC,GADI,CACAC,WAAW,IAAI;AAClB,UAAIX,IAAJ;;AACA,UAAI;AACFA,QAAAA,IAAI,GAAGN,MAAM,CAACM,IAAP,CAAYW,WAAZ,CAAP;AACD,OAFD,CAEE,OAAOC,CAAP,EAAU;AACV,eAAO,KAAP;AACD;;AAED,aAAOZ,IAAI,CAACU,GAAL,CAASG,GAAG,IAAI;AACrB,YAAIN,QAAJ;;AACA,YAAI;AACFA,UAAAA,QAAQ,GAAG,KAAKjB,GAAL,CAASwB,UAAT,CAAoBC,eAApB,CAAoCF,GAApC,CAAX;AACD,SAFD,CAEE,OAAOD,CAAP,EAAU;AACV,iBAAO,KAAP;AACD;;AAED,YAAI,CAACL,QAAL,EAAe,OAAO,KAAP;AACf,YAAI;AAAEN,UAAAA;AAAF,YAAWM,QAAf;;AACA,YAAIA,QAAQ,CAACN,IAAT,KAAkB,MAAtB,EAA8B;AAC5B,cAAIM,QAAQ,CAACS,MAAT,KAAoB,OAAxB,EAAiCf,IAAI,GAAG,OAAP;AACjC,cAAIM,QAAQ,CAACS,MAAT,KAAoB,QAAxB,EAAkCf,IAAI,GAAG,QAAP;AACnC,SAHD,MAGO,IAAIM,QAAQ,CAACN,IAAT,KAAkB,QAAtB,EAAgC;AACrCA,UAAAA,IAAI,GAAG,QAAP;AACD,SAFM,MAEA,IAAIM,QAAQ,CAACN,IAAT,KAAkB,QAAtB,EAAgC;AACrC,cAAIM,QAAQ,CAACU,EAAT,KAAgB,OAApB,EAA6BhB,IAAI,GAAG,OAAP,CAA7B,KACK,IAAIM,QAAQ,CAACU,EAAT,KAAgB,QAAhB,IAA4BV,QAAQ,CAACU,EAAT,KAAgB,QAAhD,EAA0DhB,IAAI,GAAG,QAAP;AAChE,SAHM,MAGA;AACL,iBAAO,KAAP;AACD,SApBoB,CAsBrB;;;AACAM,QAAAA,QAAQ,CAACW,IAAT,GAAgBL,GAAhB;AAEA,eAAO;AAAEZ,UAAAA,IAAF;AAAQM,UAAAA;AAAR,SAAP;AACD,OA1BM,CAAP;AA2BD,KApCI,EAqCJY,MArCI,CAqCG,CAACC,IAAD,EAAOC,UAAP,KAAsB;AAC5BA,MAAAA,UAAU,CAAClB,OAAX,CAAmBI,QAAQ,IAAI;AAC7B;AACA,YAAI,CAACA,QAAL,EAAe;AACf,YAAI,CAACa,IAAI,CAACb,QAAQ,CAACN,IAAV,CAAT,EAA0BmB,IAAI,CAACb,QAAQ,CAACN,IAAV,CAAJ,GAAsB,EAAtB;AAC1BmB,QAAAA,IAAI,CAACb,QAAQ,CAACN,IAAV,CAAJ,CAAoBqB,IAApB,CAAyBf,QAAQ,CAACA,QAAlC;AACD,OALD;AAMA,aAAOa,IAAP;AACD,KA7CI,EA6CF,EA7CE,CAAP;AA8CD;;AAEDG,EAAAA,UAAU,GAAG;AACX,SAAKC,OAAL,GAAe;AACbC,MAAAA,OAAO,EAAE,EADI;AAEbC,MAAAA,QAAQ,EAAE;AAFG,KAAf;AAKA,UAAMnB,QAAQ,GAAG,KAAKC,eAAL,EAAjB;;AACA,QAAID,QAAQ,CAACoB,MAAb,EAAqB;AACnB,WAAKH,OAAL,CAAaC,OAAb,GAAuBlB,QAAQ,CAACoB,MAAT,CAAgBjB,GAAhB,CAAoBkB,CAAC,IAAI;AAC9C,YAAIA,CAAC,CAACX,EAAF,KAAS,QAAb,EAAuB,OAAO,QAAP;AACvB,eAAOW,CAAC,CAACC,IAAT;AACD,OAHsB,CAAvB;AAID;;AAED,QAAItB,QAAQ,CAACuB,MAAT,IAAmBvB,QAAQ,CAACwB,KAAhC,EAAuC;AACrC,WAAKP,OAAL,CAAaC,OAAb,CAAqBH,IAArB,CAA0B,eAA1B;AACD;;AAED,QAAI,KAAKU,UAAT,EAAqB;AACnB,WAAKR,OAAL,CAAaC,OAAb,GAAuB,KAAKD,OAAL,CAAaC,OAAb,CAAqBQ,MAArB,CACrB,KAAKD,UAAL,CACGtB,GADH,CACOwB,CAAC,IAAI;AACR,YAAIA,CAAC,CAACjB,EAAF,IAAQiB,CAAC,CAACjB,EAAF,KAAS,QAArB,EAA+B,OAAOiB,CAAC,CAACL,IAAT;;AAC/B,YAAIK,CAAC,CAACC,IAAN,EAAY;AACV,gBAAM;AAAEN,YAAAA;AAAF,cAAW3C,oBAAoB,CAACgD,CAAC,CAACC,IAAH,EAAS,KAAK7C,GAAd,CAArC;AACA,iBAAOuC,IAAP;AACD;;AACD,eAAOO,SAAP;AACD,OARH,EASGC,MATH,CASUH,CAAC,IAAIA,CATf,CADqB,CAAvB;AAYD;;AAED,SAAKV,OAAL,CAAaE,QAAb,GAAwBhC,MAAM,CAACM,IAAP,CAAY,KAAKsC,SAAjB,EACrBD,MADqB,CACdE,CAAC,IAAI,KAAKD,SAAL,CAAeC,CAAf,EAAkBf,OADT,EAErBd,GAFqB,CAEjB6B,CAAC,IAAI7C,MAAM,CAACM,IAAP,CAAY,KAAKsC,SAAL,CAAeC,CAAf,EAAkBf,OAA9B,CAFY,EAGrBL,MAHqB,CAGd,CAACqB,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACP,MAAF,CAASQ,CAAT,CAHI,EAGS,EAHT,CAAxB,CAjCW,CAsCX;AACA;AACA;;AACA,QAAI,CAAC,KAAKjB,OAAL,CAAaC,OAAb,CAAqBiB,QAArB,CAA8B,cAA9B,CAAD,IAAkD,KAAK5C,WAA3D,EAAwE;AACtE,UAAI,KAAKA,WAAL,CAAiBqC,IAArB,EAA2B;AACzB,cAAMQ,GAAG,GAAGzD,oBAAoB,CAAC,KAAKY,WAAL,CAAiBqC,IAAlB,EAAwB,KAAK7C,GAA7B,CAAhC;AACA,YAAIqD,GAAG,CAAC5C,OAAJ,IAAeL,MAAM,CAACM,IAAP,CAAY2C,GAAG,CAAC5C,OAAhB,CAAnB,EAA6C,KAAKyB,OAAL,CAAaC,OAAb,CAAqBH,IAArB,CAA0B,cAA1B;AAC9C,OAHD,MAGO,IAAI,KAAKxB,WAAL,CAAiBC,OAAjB,IAA4BL,MAAM,CAACM,IAAP,CAAY,KAAKF,WAAL,CAAiBC,OAA7B,CAAhC,EACL,KAAKyB,OAAL,CAAaC,OAAb,CAAqBH,IAArB,CAA0B,cAA1B;AACH,KA/CU,CAiDX;AACA;;;AACA,QAAI,KAAKgB,SAAT,EAAoB;AAClB,UAAI5C,MAAM,CAACM,IAAP,CAAY,KAAKsC,SAAjB,EAA4BM,IAA5B,CAAiClB,QAAQ,IAAI,CAAC,CAAC,KAAKY,SAAL,CAAeZ,QAAf,EAAyB3B,OAAxE,CAAJ,EAAsF;AACpF,YAAI,CAAC,KAAKyB,OAAL,CAAaC,OAAb,CAAqBiB,QAArB,CAA8B,QAA9B,CAAL,EAA8C,KAAKlB,OAAL,CAAaC,OAAb,CAAqBH,IAArB,CAA0B,QAA1B;AAC9C,YAAI,CAAC,KAAKE,OAAL,CAAaE,QAAb,CAAsBgB,QAAtB,CAA+B,cAA/B,CAAL,EAAqD,KAAKlB,OAAL,CAAaE,QAAb,CAAsBJ,IAAtB,CAA2B,cAA3B;AACtD;AACF;;AAED,WAAO,KAAKE,OAAZ;AACD;;AA5Ia;;AA+IhBqB,MAAM,CAACC,OAAP,GAAiB1D,SAAjB","sourcesContent":["const findSchemaDefinition = require('./lib/find-schema-definition');\n\nclass Operation {\n  constructor(oas, path, method, operation) {\n    Object.assign(this, operation);\n    this.oas = oas;\n    this.path = path;\n    this.method = method;\n  }\n\n  getContentType() {\n    const types = (this.requestBody && this.requestBody.content && Object.keys(this.requestBody.content)) || [];\n\n    let type = 'application/json';\n    if (types && types.length) {\n      type = types[0];\n    }\n\n    // Favor JSON if it exists\n    types.forEach(t => {\n      if (t.match(/json/)) {\n        type = t;\n      }\n    });\n\n    return type;\n  }\n\n  getSecurity() {\n    return this.security || this.oas.security || [];\n  }\n\n  prepareSecurity() {\n    const securityRequirements = this.getSecurity();\n\n    return securityRequirements\n      .map(requirement => {\n        let keys;\n        try {\n          keys = Object.keys(requirement);\n        } catch (e) {\n          return false;\n        }\n\n        return keys.map(key => {\n          let security;\n          try {\n            security = this.oas.components.securitySchemes[key];\n          } catch (e) {\n            return false;\n          }\n\n          if (!security) return false;\n          let { type } = security;\n          if (security.type === 'http') {\n            if (security.scheme === 'basic') type = 'Basic';\n            if (security.scheme === 'bearer') type = 'Bearer';\n          } else if (security.type === 'oauth2') {\n            type = 'OAuth2';\n          } else if (security.type === 'apiKey') {\n            if (security.in === 'query') type = 'Query';\n            else if (security.in === 'header' || security.in === 'cookie') type = 'Header';\n          } else {\n            return false;\n          }\n\n          // eslint-disable-next-line no-underscore-dangle\n          security._key = key;\n\n          return { type, security };\n        });\n      })\n      .reduce((prev, securities) => {\n        securities.forEach(security => {\n          // Remove non-existent schemes\n          if (!security) return;\n          if (!prev[security.type]) prev[security.type] = [];\n          prev[security.type].push(security.security);\n        });\n        return prev;\n      }, {});\n  }\n\n  getHeaders() {\n    this.headers = {\n      request: [],\n      response: [],\n    };\n\n    const security = this.prepareSecurity();\n    if (security.Header) {\n      this.headers.request = security.Header.map(h => {\n        if (h.in === 'cookie') return 'Cookie';\n        return h.name;\n      });\n    }\n\n    if (security.Bearer || security.Basic) {\n      this.headers.request.push('Authorization');\n    }\n\n    if (this.parameters) {\n      this.headers.request = this.headers.request.concat(\n        this.parameters\n          .map(p => {\n            if (p.in && p.in === 'header') return p.name;\n            if (p.$ref) {\n              const { name } = findSchemaDefinition(p.$ref, this.oas);\n              return name;\n            }\n            return undefined;\n          })\n          .filter(p => p)\n      );\n    }\n\n    this.headers.response = Object.keys(this.responses)\n      .filter(r => this.responses[r].headers)\n      .map(r => Object.keys(this.responses[r].headers))\n      .reduce((a, b) => a.concat(b), []);\n\n    // If the operation doesn't already specify a 'content-type' request header,\n    // we check if the path operation request body contains content, which implies that\n    // we should also include the 'content-type' header.\n    if (!this.headers.request.includes('Content-Type') && this.requestBody) {\n      if (this.requestBody.$ref) {\n        const ref = findSchemaDefinition(this.requestBody.$ref, this.oas);\n        if (ref.content && Object.keys(ref.content)) this.headers.request.push('Content-Type');\n      } else if (this.requestBody.content && Object.keys(this.requestBody.content))\n        this.headers.request.push('Content-Type');\n    }\n\n    // This is a similar approach, but in this case if we check the response content\n    // and prioritize the 'accept' request header and 'content-type' request header\n    if (this.responses) {\n      if (Object.keys(this.responses).some(response => !!this.responses[response].content)) {\n        if (!this.headers.request.includes('Accept')) this.headers.request.push('Accept');\n        if (!this.headers.response.includes('Content-Type')) this.headers.response.push('Content-Type');\n      }\n    }\n\n    return this.headers;\n  }\n}\n\nmodule.exports = Operation;\n"]},"metadata":{},"sourceType":"script"}