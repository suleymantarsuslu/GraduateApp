{"ast":null,"code":"\"use strict\";\n\nconst Options = require(\"./options\");\n\nconst $Refs = require(\"./refs\");\n\nconst parse = require(\"./parse\");\n\nconst normalizeArgs = require(\"./normalize-args\");\n\nconst resolveExternal = require(\"./resolve-external\");\n\nconst bundle = require(\"./bundle\");\n\nconst dereference = require(\"./dereference\");\n\nconst url = require(\"./util/url\");\n\nconst maybe = require(\"call-me-maybe\");\n\nconst {\n  ono\n} = require(\"@jsdevtools/ono\");\n\nmodule.exports = $RefParser;\nmodule.exports.YAML = require(\"./util/yaml\");\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @constructor\n */\n\nfunction $RefParser() {\n  /**\n   * The parsed (and possibly dereferenced) JSON schema object\n   *\n   * @type {object}\n   * @readonly\n   */\n  this.schema = null;\n  /**\n   * The resolved JSON references\n   *\n   * @type {$Refs}\n   * @readonly\n   */\n\n  this.$refs = new $Refs();\n}\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n\n\n$RefParser.parse = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n\n  let instance = new Class();\n  return instance.parse.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n\n\n$RefParser.prototype.parse = async function (path, schema, options, callback) {\n  let args = normalizeArgs(arguments);\n  let promise;\n\n  if (!args.path && !args.schema) {\n    let err = ono(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);\n    return maybe(args.callback, Promise.reject(err));\n  } // Reset everything\n\n\n  this.schema = null;\n  this.$refs = new $Refs(); // If the path is a filesystem path, then convert it to a URL.\n  // NOTE: According to the JSON Reference spec, these should already be URLs,\n  // but, in practice, many people use local filesystem paths instead.\n  // So we're being generous here and doing the conversion automatically.\n  // This is not intended to be a 100% bulletproof solution.\n  // If it doesn't work for your use-case, then use a URL instead.\n\n  let pathType = \"http\";\n\n  if (url.isFileSystemPath(args.path)) {\n    args.path = url.fromFileSystemPath(args.path);\n    pathType = \"file\";\n  } // Resolve the absolute path of the schema\n\n\n  args.path = url.resolve(url.cwd(), args.path);\n\n  if (args.schema && typeof args.schema === \"object\") {\n    // A schema object was passed-in.\n    // So immediately add a new $Ref with the schema object as its value\n    let $ref = this.$refs._add(args.path);\n\n    $ref.value = args.schema;\n    $ref.pathType = pathType;\n    promise = Promise.resolve(args.schema);\n  } else {\n    // Parse the schema file/url\n    promise = parse(args.path, this.$refs, args.options);\n  }\n\n  let me = this;\n\n  try {\n    let result = await promise;\n\n    if (!result || typeof result !== \"object\" || Buffer.isBuffer(result)) {\n      throw ono.syntax(`\"${me.$refs._root$Ref.path || result}\" is not a valid JSON Schema`);\n    } else {\n      me.schema = result;\n      return maybe(args.callback, Promise.resolve(me.schema));\n    }\n  } catch (e) {\n    return maybe(args.callback, Promise.reject(e));\n  }\n};\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n\n\n$RefParser.resolve = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n\n  let instance = new Class();\n  return instance.resolve.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n\n\n$RefParser.prototype.resolve = async function (path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.parse(args.path, args.schema, args.options);\n    await resolveExternal(me, args.options);\n    return maybe(args.callback, Promise.resolve(me.$refs));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n\n\n$RefParser.bundle = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n\n  let instance = new Class();\n  return instance.bundle.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n\n\n$RefParser.prototype.bundle = async function (path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n    bundle(me, args.options);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n\n\n$RefParser.dereference = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n\n  let instance = new Class();\n  return instance.dereference.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n\n\n$RefParser.prototype.dereference = async function (path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n    dereference(me, args.options);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@apidevtools/swagger-parser/node_modules/@apidevtools/json-schema-ref-parser/lib/index.js"],"names":["Options","require","$Refs","parse","normalizeArgs","resolveExternal","bundle","dereference","url","maybe","ono","module","exports","$RefParser","YAML","schema","$refs","path","options","callback","Class","instance","apply","arguments","prototype","args","promise","err","Promise","reject","pathType","isFileSystemPath","fromFileSystemPath","resolve","cwd","$ref","_add","value","me","result","Buffer","isBuffer","syntax","_root$Ref","e"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst Options = require(\"./options\");\nconst $Refs = require(\"./refs\");\nconst parse = require(\"./parse\");\nconst normalizeArgs = require(\"./normalize-args\");\nconst resolveExternal = require(\"./resolve-external\");\nconst bundle = require(\"./bundle\");\nconst dereference = require(\"./dereference\");\nconst url = require(\"./util/url\");\nconst maybe = require(\"call-me-maybe\");\nconst { ono } = require(\"@jsdevtools/ono\");\n\nmodule.exports = $RefParser;\nmodule.exports.YAML = require(\"./util/yaml\");\n\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @constructor\n */\nfunction $RefParser () {\n  /**\n   * The parsed (and possibly dereferenced) JSON schema object\n   *\n   * @type {object}\n   * @readonly\n   */\n  this.schema = null;\n\n  /**\n   * The resolved JSON references\n   *\n   * @type {$Refs}\n   * @readonly\n   */\n  this.$refs = new $Refs();\n}\n\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n$RefParser.parse = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.parse.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n$RefParser.prototype.parse = async function (path, schema, options, callback) {\n  let args = normalizeArgs(arguments);\n  let promise;\n\n  if (!args.path && !args.schema) {\n    let err = ono(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);\n    return maybe(args.callback, Promise.reject(err));\n  }\n\n  // Reset everything\n  this.schema = null;\n  this.$refs = new $Refs();\n\n  // If the path is a filesystem path, then convert it to a URL.\n  // NOTE: According to the JSON Reference spec, these should already be URLs,\n  // but, in practice, many people use local filesystem paths instead.\n  // So we're being generous here and doing the conversion automatically.\n  // This is not intended to be a 100% bulletproof solution.\n  // If it doesn't work for your use-case, then use a URL instead.\n  let pathType = \"http\";\n  if (url.isFileSystemPath(args.path)) {\n    args.path = url.fromFileSystemPath(args.path);\n    pathType = \"file\";\n  }\n\n  // Resolve the absolute path of the schema\n  args.path = url.resolve(url.cwd(), args.path);\n\n  if (args.schema && typeof args.schema === \"object\") {\n    // A schema object was passed-in.\n    // So immediately add a new $Ref with the schema object as its value\n    let $ref = this.$refs._add(args.path);\n    $ref.value = args.schema;\n    $ref.pathType = pathType;\n    promise = Promise.resolve(args.schema);\n  }\n  else {\n    // Parse the schema file/url\n    promise = parse(args.path, this.$refs, args.options);\n  }\n\n  let me = this;\n  try {\n    let result = await promise;\n\n    if (!result || typeof result !== \"object\" || Buffer.isBuffer(result)) {\n      throw ono.syntax(`\"${me.$refs._root$Ref.path || result}\" is not a valid JSON Schema`);\n    }\n    else {\n      me.schema = result;\n      return maybe(args.callback, Promise.resolve(me.schema));\n    }\n  }\n  catch (e) {\n    return maybe(args.callback, Promise.reject(e));\n  }\n};\n\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n$RefParser.resolve = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.resolve.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n$RefParser.prototype.resolve = async function (path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.parse(args.path, args.schema, args.options);\n    await resolveExternal(me, args.options);\n    return maybe(args.callback, Promise.resolve(me.$refs));\n  }\n  catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n$RefParser.bundle = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.bundle.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n$RefParser.prototype.bundle = async function (path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n    bundle(me, args.options);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  }\n  catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n$RefParser.dereference = function (path, schema, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.dereference.apply(instance, arguments);\n};\n\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n$RefParser.prototype.dereference = async function (path, schema, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n\n  try {\n    await this.resolve(args.path, args.schema, args.options);\n    dereference(me, args.options);\n    return maybe(args.callback, Promise.resolve(me.schema));\n  }\n  catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n"]},"metadata":{},"sourceType":"script"}