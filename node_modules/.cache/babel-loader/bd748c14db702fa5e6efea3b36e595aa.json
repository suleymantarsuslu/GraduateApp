{"ast":null,"code":"\"use strict\";\n\nconst YAML = require(\"../util/yaml\");\n\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 200,\n\n  /**\n   * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that match will be tried, in order, until one successfully parses the file.\n   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n   * every parser will be tried.\n   *\n   * @type {RegExp|string[]|function}\n   */\n  canParse: [\".yaml\", \".yml\", \".json\"],\n\n  // JSON is valid YAML\n\n  /**\n   * Parses the given file as YAML\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {Promise}\n   */\n  parse(file) {\n    return new Promise((resolve, reject) => {\n      let data = file.data;\n\n      if (Buffer.isBuffer(data)) {\n        data = data.toString();\n      }\n\n      if (typeof data === \"string\") {\n        resolve(YAML.parse(data));\n      } else {\n        // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n        resolve(data);\n      }\n    });\n  }\n\n};","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@apidevtools/swagger-parser/node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/yaml.js"],"names":["YAML","require","module","exports","order","allowEmpty","canParse","parse","file","Promise","resolve","reject","data","Buffer","isBuffer","toString"],"mappings":"AAAA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,cAAD,CAApB;;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACf;;;;;AAKAC,EAAAA,KAAK,EAAE,GANQ;;AAQf;;;;;AAKAC,EAAAA,UAAU,EAAE,IAbG;;AAef;;;;;;;;AAQAC,EAAAA,QAAQ,EAAE,CAAC,OAAD,EAAU,MAAV,EAAkB,OAAlB,CAvBK;;AAuBwB;;AAEvC;;;;;;;;;AASAC,EAAAA,KAAK,CAAEC,IAAF,EAAQ;AACX,WAAO,IAAIC,OAAJ,CAAa,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACvC,UAAIC,IAAI,GAAGJ,IAAI,CAACI,IAAhB;;AACA,UAAIC,MAAM,CAACC,QAAP,CAAgBF,IAAhB,CAAJ,EAA2B;AACzBA,QAAAA,IAAI,GAAGA,IAAI,CAACG,QAAL,EAAP;AACD;;AAED,UAAI,OAAOH,IAAP,KAAgB,QAApB,EAA8B;AAC5BF,QAAAA,OAAO,CAACV,IAAI,CAACO,KAAL,CAAWK,IAAX,CAAD,CAAP;AACD,OAFD,MAGK;AACH;AACAF,QAAAA,OAAO,CAACE,IAAD,CAAP;AACD;AACF,KAbM,CAAP;AAcD;;AAjDc,CAAjB","sourcesContent":["\"use strict\";\n\nconst YAML = require(\"../util/yaml\");\n\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 200,\n\n  /**\n   * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that match will be tried, in order, until one successfully parses the file.\n   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n   * every parser will be tried.\n   *\n   * @type {RegExp|string[]|function}\n   */\n  canParse: [\".yaml\", \".yml\", \".json\"],  // JSON is valid YAML\n\n  /**\n   * Parses the given file as YAML\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {Promise}\n   */\n  parse (file) {\n    return new Promise(((resolve, reject) => {\n      let data = file.data;\n      if (Buffer.isBuffer(data)) {\n        data = data.toString();\n      }\n\n      if (typeof data === \"string\") {\n        resolve(YAML.parse(data));\n      }\n      else {\n        // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n        resolve(data);\n      }\n    }));\n  }\n};\n"]},"metadata":{},"sourceType":"script"}