{"ast":null,"code":"\"use strict\";\n\nlet TEXT_REGEXP = /\\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 300,\n\n  /**\n   * Whether to allow \"empty\" files (zero bytes).\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n\n  /**\n   * The encoding that the text is expected to be in.\n   *\n   * @type {string}\n   */\n  encoding: \"utf8\",\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that return true will be tried, in order, until one successfully parses the file.\n   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n   * every parser will be tried.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {boolean}\n   */\n  canParse(file) {\n    // Use this parser if the file is a string or Buffer, and has a known text-based extension\n    return (typeof file.data === \"string\" || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);\n  },\n\n  /**\n   * Parses the given file as text\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {Promise<string>}\n   */\n  parse(file) {\n    if (typeof file.data === \"string\") {\n      return file.data;\n    } else if (Buffer.isBuffer(file.data)) {\n      return file.data.toString(this.encoding);\n    } else {\n      throw new Error(\"data is not text\");\n    }\n  }\n\n};","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@apidevtools/swagger-parser/node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/text.js"],"names":["TEXT_REGEXP","module","exports","order","allowEmpty","encoding","canParse","file","data","Buffer","isBuffer","test","url","parse","toString","Error"],"mappings":"AAAA;;AAEA,IAAIA,WAAW,GAAG,wDAAlB;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACf;;;;;AAKAC,EAAAA,KAAK,EAAE,GANQ;;AAQf;;;;;AAKAC,EAAAA,UAAU,EAAE,IAbG;;AAef;;;;;AAKAC,EAAAA,QAAQ,EAAE,MApBK;;AAsBf;;;;;;;;;;;;AAYAC,EAAAA,QAAQ,CAAEC,IAAF,EAAQ;AACd;AACA,WAAO,CAAC,OAAOA,IAAI,CAACC,IAAZ,KAAqB,QAArB,IAAiCC,MAAM,CAACC,QAAP,CAAgBH,IAAI,CAACC,IAArB,CAAlC,KAAiER,WAAW,CAACW,IAAZ,CAAiBJ,IAAI,CAACK,GAAtB,CAAxE;AACD,GArCc;;AAuCf;;;;;;;;;AASAC,EAAAA,KAAK,CAAEN,IAAF,EAAQ;AACX,QAAI,OAAOA,IAAI,CAACC,IAAZ,KAAqB,QAAzB,EAAmC;AACjC,aAAOD,IAAI,CAACC,IAAZ;AACD,KAFD,MAGK,IAAIC,MAAM,CAACC,QAAP,CAAgBH,IAAI,CAACC,IAArB,CAAJ,EAAgC;AACnC,aAAOD,IAAI,CAACC,IAAL,CAAUM,QAAV,CAAmB,KAAKT,QAAxB,CAAP;AACD,KAFI,MAGA;AACH,YAAM,IAAIU,KAAJ,CAAU,kBAAV,CAAN;AACD;AACF;;AA1Dc,CAAjB","sourcesContent":["\"use strict\";\n\nlet TEXT_REGEXP = /\\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;\n\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 300,\n\n  /**\n   * Whether to allow \"empty\" files (zero bytes).\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n\n  /**\n   * The encoding that the text is expected to be in.\n   *\n   * @type {string}\n   */\n  encoding: \"utf8\",\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that return true will be tried, in order, until one successfully parses the file.\n   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n   * every parser will be tried.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {boolean}\n   */\n  canParse (file) {\n    // Use this parser if the file is a string or Buffer, and has a known text-based extension\n    return (typeof file.data === \"string\" || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);\n  },\n\n  /**\n   * Parses the given file as text\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {Promise<string>}\n   */\n  parse (file) {\n    if (typeof file.data === \"string\") {\n      return file.data;\n    }\n    else if (Buffer.isBuffer(file.data)) {\n      return file.data.toString(this.encoding);\n    }\n    else {\n      throw new Error(\"data is not text\");\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}