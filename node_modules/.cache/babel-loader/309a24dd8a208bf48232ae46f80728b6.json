{"ast":null,"code":"\"use strict\";\n\nvar method = require(\"method\");\n\nvar isReduced = require(\"./is-reduced\");\n\nvar isError = require(\"./is-error\");\n\nvar end = require(\"./end\");\n\nvar reduce = method(\"reduce@reducible\"); // Implementation of `reduce` for the empty collections, that immediately\n// signals reducer that it's ended.\n\nreduce.empty = function reduceEmpty(empty, next, initial) {\n  next(end, initial);\n}; // Implementation of `reduce` for the singular values which are treated\n// as collections with a single element. Yields a value and signals the end.\n\n\nreduce.singular = function reduceSingular(value, next, initial) {\n  next(end, next(value, initial));\n}; // Implementation of `reduce` for the array (and alike) values, such that it\n// will call accumulator function `next` each time with next item and\n// accumulated state until it's exhausted or `next` returns marked value\n// indicating that it's reduced. Either way signals `end` to an accumulator.\n\n\nreduce.indexed = function reduceIndexed(indexed, next, initial) {\n  var state = initial;\n  var index = 0;\n  var count = indexed.length;\n\n  while (index < count) {\n    var value = indexed[index];\n    state = next(value, state);\n    index = index + 1;\n    if (value === end) return end;\n    if (isError(value)) return state;\n    if (isReduced(state)) return state.value;\n  }\n\n  next(end, state);\n}; // Both `undefined` and `null` implement accumulate for empty sequences.\n\n\nreduce.define(void 0, reduce.empty);\nreduce.define(null, reduce.empty); // Array and arguments implement accumulate for indexed sequences.\n\nreduce.define(Array, reduce.indexed);\n\nfunction Arguments() {\n  return arguments;\n}\n\nArguments.prototype = Arguments();\nreduce.define(Arguments, reduce.indexed); // All other built-in data types are treated as single value collections\n// by default. Of course individual types may choose to override that.\n\nreduce.define(reduce.singular); // Errors just yield that error.\n\nreduce.define(Error, function (error, next) {\n  next(error);\n});\nmodule.exports = reduce;","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/reducible/reduce.js"],"names":["method","require","isReduced","isError","end","reduce","empty","reduceEmpty","next","initial","singular","reduceSingular","value","indexed","reduceIndexed","state","index","count","length","define","Array","Arguments","arguments","prototype","Error","error","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AAEA,IAAIC,SAAS,GAAGD,OAAO,CAAC,cAAD,CAAvB;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,YAAD,CAArB;;AACA,IAAIG,GAAG,GAAGH,OAAO,CAAC,OAAD,CAAjB;;AAEA,IAAII,MAAM,GAAGL,MAAM,CAAC,kBAAD,CAAnB,C,CAEA;AACA;;AACAK,MAAM,CAACC,KAAP,GAAe,SAASC,WAAT,CAAqBD,KAArB,EAA4BE,IAA5B,EAAkCC,OAAlC,EAA2C;AACxDD,EAAAA,IAAI,CAACJ,GAAD,EAAMK,OAAN,CAAJ;AACD,CAFD,C,CAIA;AACA;;;AACAJ,MAAM,CAACK,QAAP,GAAkB,SAASC,cAAT,CAAwBC,KAAxB,EAA+BJ,IAA/B,EAAqCC,OAArC,EAA8C;AAC9DD,EAAAA,IAAI,CAACJ,GAAD,EAAMI,IAAI,CAACI,KAAD,EAAQH,OAAR,CAAV,CAAJ;AACD,CAFD,C,CAIA;AACA;AACA;AACA;;;AACAJ,MAAM,CAACQ,OAAP,GAAiB,SAASC,aAAT,CAAuBD,OAAvB,EAAgCL,IAAhC,EAAsCC,OAAtC,EAA+C;AAC9D,MAAIM,KAAK,GAAGN,OAAZ;AACA,MAAIO,KAAK,GAAG,CAAZ;AACA,MAAIC,KAAK,GAAGJ,OAAO,CAACK,MAApB;;AACA,SAAOF,KAAK,GAAGC,KAAf,EAAsB;AACpB,QAAIL,KAAK,GAAGC,OAAO,CAACG,KAAD,CAAnB;AACAD,IAAAA,KAAK,GAAGP,IAAI,CAACI,KAAD,EAAQG,KAAR,CAAZ;AACAC,IAAAA,KAAK,GAAGA,KAAK,GAAG,CAAhB;AACA,QAAIJ,KAAK,KAAKR,GAAd,EAAmB,OAAOA,GAAP;AACnB,QAAID,OAAO,CAACS,KAAD,CAAX,EAAoB,OAAOG,KAAP;AACpB,QAAIb,SAAS,CAACa,KAAD,CAAb,EAAsB,OAAOA,KAAK,CAACH,KAAb;AACvB;;AACDJ,EAAAA,IAAI,CAACJ,GAAD,EAAMW,KAAN,CAAJ;AACD,CAbD,C,CAeA;;;AACAV,MAAM,CAACc,MAAP,CAAc,KAAK,CAAnB,EAAuBd,MAAM,CAACC,KAA9B;AACAD,MAAM,CAACc,MAAP,CAAc,IAAd,EAAoBd,MAAM,CAACC,KAA3B,E,CAEA;;AACAD,MAAM,CAACc,MAAP,CAAcC,KAAd,EAAqBf,MAAM,CAACQ,OAA5B;;AAEA,SAASQ,SAAT,GAAqB;AAAE,SAAOC,SAAP;AAAkB;;AACzCD,SAAS,CAACE,SAAV,GAAsBF,SAAS,EAA/B;AACAhB,MAAM,CAACc,MAAP,CAAcE,SAAd,EAAyBhB,MAAM,CAACQ,OAAhC,E,CAEA;AACA;;AACAR,MAAM,CAACc,MAAP,CAAcd,MAAM,CAACK,QAArB,E,CAEA;;AACAL,MAAM,CAACc,MAAP,CAAcK,KAAd,EAAqB,UAASC,KAAT,EAAgBjB,IAAhB,EAAsB;AAAEA,EAAAA,IAAI,CAACiB,KAAD,CAAJ;AAAa,CAA1D;AACAC,MAAM,CAACC,OAAP,GAAiBtB,MAAjB","sourcesContent":["\"use strict\";\n\nvar method = require(\"method\")\n\nvar isReduced = require(\"./is-reduced\")\nvar isError = require(\"./is-error\")\nvar end = require(\"./end\")\n\nvar reduce = method(\"reduce@reducible\")\n\n// Implementation of `reduce` for the empty collections, that immediately\n// signals reducer that it's ended.\nreduce.empty = function reduceEmpty(empty, next, initial) {\n  next(end, initial)\n}\n\n// Implementation of `reduce` for the singular values which are treated\n// as collections with a single element. Yields a value and signals the end.\nreduce.singular = function reduceSingular(value, next, initial) {\n  next(end, next(value, initial))\n}\n\n// Implementation of `reduce` for the array (and alike) values, such that it\n// will call accumulator function `next` each time with next item and\n// accumulated state until it's exhausted or `next` returns marked value\n// indicating that it's reduced. Either way signals `end` to an accumulator.\nreduce.indexed = function reduceIndexed(indexed, next, initial) {\n  var state = initial\n  var index = 0\n  var count = indexed.length\n  while (index < count) {\n    var value = indexed[index]\n    state = next(value, state)\n    index = index + 1\n    if (value === end) return end\n    if (isError(value)) return state\n    if (isReduced(state)) return state.value\n  }\n  next(end, state)\n}\n\n// Both `undefined` and `null` implement accumulate for empty sequences.\nreduce.define(void(0), reduce.empty)\nreduce.define(null, reduce.empty)\n\n// Array and arguments implement accumulate for indexed sequences.\nreduce.define(Array, reduce.indexed)\n\nfunction Arguments() { return arguments }\nArguments.prototype = Arguments()\nreduce.define(Arguments, reduce.indexed)\n\n// All other built-in data types are treated as single value collections\n// by default. Of course individual types may choose to override that.\nreduce.define(reduce.singular)\n\n// Errors just yield that error.\nreduce.define(Error, function(error, next) { next(error) })\nmodule.exports = reduce\n"]},"metadata":{},"sourceType":"script"}