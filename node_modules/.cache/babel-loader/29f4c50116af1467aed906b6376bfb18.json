{"ast":null,"code":"\"use strict\";\n\nvar isequal = require(\"lodash.isequal\");\n\nvar Report = require(\"./Report\");\n\nvar SchemaCompilation = require(\"./SchemaCompilation\");\n\nvar SchemaValidation = require(\"./SchemaValidation\");\n\nvar Utils = require(\"./Utils\");\n\nfunction decodeJSONPointer(str) {\n  // http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-07#section-3\n  return decodeURIComponent(str).replace(/~[0-1]/g, function (x) {\n    return x === \"~1\" ? \"/\" : \"~\";\n  });\n}\n\nfunction getRemotePath(uri) {\n  var io = uri.indexOf(\"#\");\n  return io === -1 ? uri : uri.slice(0, io);\n}\n\nfunction getQueryPath(uri) {\n  var io = uri.indexOf(\"#\");\n  var res = io === -1 ? undefined : uri.slice(io + 1); // WARN: do not slice slash, #/ means take root and go down from it\n  // if (res && res[0] === \"/\") { res = res.slice(1); }\n\n  return res;\n}\n\nfunction findId(schema, id) {\n  // process only arrays and objects\n  if (typeof schema !== \"object\" || schema === null) {\n    return;\n  } // no id means root so return itself\n\n\n  if (!id) {\n    return schema;\n  }\n\n  if (schema.id) {\n    if (schema.id === id || schema.id[0] === \"#\" && schema.id.substring(1) === id) {\n      return schema;\n    }\n  }\n\n  var idx, result;\n\n  if (Array.isArray(schema)) {\n    idx = schema.length;\n\n    while (idx--) {\n      result = findId(schema[idx], id);\n\n      if (result) {\n        return result;\n      }\n    }\n  } else {\n    var keys = Object.keys(schema);\n    idx = keys.length;\n\n    while (idx--) {\n      var k = keys[idx];\n\n      if (k.indexOf(\"__$\") === 0) {\n        continue;\n      }\n\n      result = findId(schema[k], id);\n\n      if (result) {\n        return result;\n      }\n    }\n  }\n}\n/**\n *\n * @param {*} uri\n * @param {*} schema\n *\n * @returns {void}\n */\n\n\nexports.cacheSchemaByUri = function (uri, schema) {\n  var remotePath = getRemotePath(uri);\n\n  if (remotePath) {\n    this.cache[remotePath] = schema;\n  }\n};\n/**\n *\n * @param {*} uri\n *\n * @returns {void}\n */\n\n\nexports.removeFromCacheByUri = function (uri) {\n  var remotePath = getRemotePath(uri);\n\n  if (remotePath) {\n    delete this.cache[remotePath];\n  }\n};\n/**\n *\n * @param {*} uri\n *\n * @returns {boolean}\n */\n\n\nexports.checkCacheForUri = function (uri) {\n  var remotePath = getRemotePath(uri);\n  return remotePath ? this.cache[remotePath] != null : false;\n};\n\nexports.getSchema = function (report, schema) {\n  if (typeof schema === \"object\") {\n    schema = exports.getSchemaByReference.call(this, report, schema);\n  }\n\n  if (typeof schema === \"string\") {\n    schema = exports.getSchemaByUri.call(this, report, schema);\n  }\n\n  return schema;\n};\n\nexports.getSchemaByReference = function (report, key) {\n  var i = this.referenceCache.length;\n\n  while (i--) {\n    if (isequal(this.referenceCache[i][0], key)) {\n      return this.referenceCache[i][1];\n    }\n  } // not found\n\n\n  var schema = Utils.cloneDeep(key);\n  this.referenceCache.push([key, schema]);\n  return schema;\n};\n\nexports.getSchemaByUri = function (report, uri, root) {\n  var remotePath = getRemotePath(uri),\n      queryPath = getQueryPath(uri),\n      result = remotePath ? this.cache[remotePath] : root;\n\n  if (result && remotePath) {\n    // we need to avoid compiling schemas in a recursive loop\n    var compileRemote = result !== root; // now we need to compile and validate resolved schema (in case it's not already)\n\n    if (compileRemote) {\n      report.path.push(remotePath);\n      var remoteReport;\n      var anscestorReport = report.getAncestor(result.id);\n\n      if (anscestorReport) {\n        remoteReport = anscestorReport;\n      } else {\n        remoteReport = new Report(report);\n\n        if (SchemaCompilation.compileSchema.call(this, remoteReport, result)) {\n          var savedOptions = this.options;\n\n          try {\n            // If custom validationOptions were provided to setRemoteReference(),\n            // use them instead of the default options\n            this.options = result.__$validationOptions || this.options;\n            SchemaValidation.validateSchema.call(this, remoteReport, result);\n          } finally {\n            this.options = savedOptions;\n          }\n        }\n      }\n\n      var remoteReportIsValid = remoteReport.isValid();\n\n      if (!remoteReportIsValid) {\n        report.addError(\"REMOTE_NOT_VALID\", [uri], remoteReport);\n      }\n\n      report.path.pop();\n\n      if (!remoteReportIsValid) {\n        return undefined;\n      }\n    }\n  }\n\n  if (result && queryPath) {\n    var parts = queryPath.split(\"/\");\n\n    for (var idx = 0, lim = parts.length; result && idx < lim; idx++) {\n      var key = decodeJSONPointer(parts[idx]);\n\n      if (idx === 0) {\n        // it's an id\n        result = findId(result, key);\n      } else {\n        // it's a path behind id\n        result = result[key];\n      }\n    }\n  }\n\n  return result;\n};\n\nexports.getRemotePath = getRemotePath;","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/z-schema/src/SchemaCache.js"],"names":["isequal","require","Report","SchemaCompilation","SchemaValidation","Utils","decodeJSONPointer","str","decodeURIComponent","replace","x","getRemotePath","uri","io","indexOf","slice","getQueryPath","res","undefined","findId","schema","id","substring","idx","result","Array","isArray","length","keys","Object","k","exports","cacheSchemaByUri","remotePath","cache","removeFromCacheByUri","checkCacheForUri","getSchema","report","getSchemaByReference","call","getSchemaByUri","key","i","referenceCache","cloneDeep","push","root","queryPath","compileRemote","path","remoteReport","anscestorReport","getAncestor","compileSchema","savedOptions","options","__$validationOptions","validateSchema","remoteReportIsValid","isValid","addError","pop","parts","split","lim"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar isequal             = require(\"lodash.isequal\");\nvar Report              = require(\"./Report\");\nvar SchemaCompilation   = require(\"./SchemaCompilation\");\nvar SchemaValidation    = require(\"./SchemaValidation\");\nvar Utils               = require(\"./Utils\");\n\nfunction decodeJSONPointer(str) {\n    // http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-07#section-3\n    return decodeURIComponent(str).replace(/~[0-1]/g, function (x) {\n        return x === \"~1\" ? \"/\" : \"~\";\n    });\n}\n\nfunction getRemotePath(uri) {\n    var io = uri.indexOf(\"#\");\n    return io === -1 ? uri : uri.slice(0, io);\n}\n\nfunction getQueryPath(uri) {\n    var io = uri.indexOf(\"#\");\n    var res = io === -1 ? undefined : uri.slice(io + 1);\n    // WARN: do not slice slash, #/ means take root and go down from it\n    // if (res && res[0] === \"/\") { res = res.slice(1); }\n    return res;\n}\n\nfunction findId(schema, id) {\n    // process only arrays and objects\n    if (typeof schema !== \"object\" || schema === null) {\n        return;\n    }\n\n    // no id means root so return itself\n    if (!id) {\n        return schema;\n    }\n\n    if (schema.id) {\n        if (schema.id === id || schema.id[0] === \"#\" && schema.id.substring(1) === id) {\n            return schema;\n        }\n    }\n\n    var idx, result;\n    if (Array.isArray(schema)) {\n        idx = schema.length;\n        while (idx--) {\n            result = findId(schema[idx], id);\n            if (result) { return result; }\n        }\n    } else {\n        var keys = Object.keys(schema);\n        idx = keys.length;\n        while (idx--) {\n            var k = keys[idx];\n            if (k.indexOf(\"__$\") === 0) {\n                continue;\n            }\n            result = findId(schema[k], id);\n            if (result) { return result; }\n        }\n    }\n}\n\n/**\n *\n * @param {*} uri\n * @param {*} schema\n *\n * @returns {void}\n */\nexports.cacheSchemaByUri = function (uri, schema) {\n    var remotePath = getRemotePath(uri);\n    if (remotePath) {\n        this.cache[remotePath] = schema;\n    }\n};\n\n/**\n *\n * @param {*} uri\n *\n * @returns {void}\n */\nexports.removeFromCacheByUri = function (uri) {\n    var remotePath = getRemotePath(uri);\n    if (remotePath) {\n        delete this.cache[remotePath];\n    }\n};\n\n/**\n *\n * @param {*} uri\n *\n * @returns {boolean}\n */\nexports.checkCacheForUri = function (uri) {\n    var remotePath = getRemotePath(uri);\n    return remotePath ? this.cache[remotePath] != null : false;\n};\n\nexports.getSchema = function (report, schema) {\n    if (typeof schema === \"object\") {\n        schema = exports.getSchemaByReference.call(this, report, schema);\n    }\n    if (typeof schema === \"string\") {\n        schema = exports.getSchemaByUri.call(this, report, schema);\n    }\n    return schema;\n};\n\nexports.getSchemaByReference = function (report, key) {\n    var i = this.referenceCache.length;\n    while (i--) {\n        if (isequal(this.referenceCache[i][0], key)) {\n            return this.referenceCache[i][1];\n        }\n    }\n    // not found\n    var schema = Utils.cloneDeep(key);\n    this.referenceCache.push([key, schema]);\n    return schema;\n};\n\nexports.getSchemaByUri = function (report, uri, root) {\n    var remotePath = getRemotePath(uri),\n        queryPath = getQueryPath(uri),\n        result = remotePath ? this.cache[remotePath] : root;\n\n    if (result && remotePath) {\n        // we need to avoid compiling schemas in a recursive loop\n        var compileRemote = result !== root;\n        // now we need to compile and validate resolved schema (in case it's not already)\n        if (compileRemote) {\n\n            report.path.push(remotePath);\n\n            var remoteReport;\n\n            var anscestorReport = report.getAncestor(result.id);\n            if (anscestorReport) {\n                remoteReport = anscestorReport;\n            } else {\n                remoteReport = new Report(report);\n                if (SchemaCompilation.compileSchema.call(this, remoteReport, result)) {\n                    var savedOptions = this.options;\n                    try {\n                        // If custom validationOptions were provided to setRemoteReference(),\n                        // use them instead of the default options\n                        this.options = result.__$validationOptions || this.options;\n                        SchemaValidation.validateSchema.call(this, remoteReport, result);\n                    } finally {\n                        this.options = savedOptions;\n                    }\n                }\n            }\n            var remoteReportIsValid = remoteReport.isValid();\n            if (!remoteReportIsValid) {\n                report.addError(\"REMOTE_NOT_VALID\", [uri], remoteReport);\n            }\n\n            report.path.pop();\n\n            if (!remoteReportIsValid) {\n                return undefined;\n            }\n        }\n    }\n\n    if (result && queryPath) {\n        var parts = queryPath.split(\"/\");\n        for (var idx = 0, lim = parts.length; result && idx < lim; idx++) {\n            var key = decodeJSONPointer(parts[idx]);\n            if (idx === 0) { // it's an id\n                result = findId(result, key);\n            } else { // it's a path behind id\n                result = result[key];\n            }\n        }\n    }\n\n    return result;\n};\n\nexports.getRemotePath = getRemotePath;\n"]},"metadata":{},"sourceType":"script"}