{"ast":null,"code":"const {\n  pathToRegexp,\n  match\n} = require('path-to-regexp');\n\nconst getPathOperation = require('./lib/get-path-operation');\n\nconst getUserVariable = require('./lib/get-user-variable');\n\nconst Operation = require('./operation');\n\nfunction ensureProtocol(url) {\n  // Add protocol to urls starting with // e.g. //example.com\n  // This is because httpsnippet throws a HARError when it doesnt have a protocol\n  if (url.match(/^\\/\\//)) {\n    return `https:${url}`;\n  } // Add protocol to urls with no // within them\n  // This is because httpsnippet throws a HARError when it doesnt have a protocol\n\n\n  if (!url.match(/\\/\\//)) {\n    return `https://${url}`;\n  }\n\n  return url;\n}\n\nfunction normalizedUrl(oas) {\n  let url;\n\n  try {\n    url = oas.servers[0].url; // This is to catch the case where servers = [{}]\n\n    if (!url) throw new Error('no url'); // Stripping the '/' off the end\n\n    if (url[url.length - 1] === '/') {\n      url = url.slice(0, -1);\n    }\n  } catch (e) {\n    url = 'https://example.com';\n  }\n\n  return ensureProtocol(url);\n}\n\nfunction normalizePath(path) {\n  return path.replace(/{(.*?)}/g, ':$1');\n}\n\nfunction generatePathMatches(paths, pathName, origin) {\n  const prunedPathName = pathName.split('?')[0];\n  return Object.keys(paths).map(path => {\n    const cleanedPath = normalizePath(path);\n    const matchStatement = match(cleanedPath, {\n      decode: decodeURIComponent\n    });\n    const matchResult = matchStatement(prunedPathName);\n    const slugs = {};\n\n    if (matchResult && Object.keys(matchResult.params).length) {\n      Object.keys(matchResult.params).forEach(param => {\n        slugs[`:${param}`] = matchResult.params[param];\n      });\n    }\n\n    return {\n      url: {\n        origin,\n        path: cleanedPath,\n        nonNormalizedPath: path,\n        slugs\n      },\n      operation: paths[path],\n      match: matchResult\n    };\n  }).filter(p => p.match);\n}\n\nfunction filterPathMethods(pathMatches, targetMethod) {\n  const regExp = pathToRegexp(targetMethod);\n  return pathMatches.map(p => {\n    const captures = Object.keys(p.operation).filter(r => regExp.exec(r));\n\n    if (captures.length) {\n      const method = captures[0];\n      p.url.method = method.toUpperCase();\n      return {\n        url: p.url,\n        operation: p.operation[method]\n      };\n    }\n\n    return undefined;\n  }).filter(p => p);\n}\n\nfunction findTargetPath(pathMatches) {\n  let minCount = Object.keys(pathMatches[0].url.slugs).length;\n  let operation;\n\n  for (let m = 0; m < pathMatches.length; m += 1) {\n    const selection = pathMatches[m];\n    const paramCount = Object.keys(selection.url.slugs).length;\n\n    if (paramCount <= minCount) {\n      minCount = paramCount;\n      operation = selection;\n    }\n  }\n\n  return operation;\n}\n\nclass Oas {\n  constructor(oas, user) {\n    Object.assign(this, oas);\n    this.user = user || {};\n  }\n\n  url() {\n    const url = normalizedUrl(this);\n    let variables;\n\n    try {\n      variables = this.servers[0].variables;\n      if (!variables) throw new Error('no variables');\n    } catch (e) {\n      variables = {};\n    }\n\n    return this.replaceUrl(url, variables).trim();\n  }\n\n  replaceUrl(url, variables) {\n    return url.replace(/{([-_a-zA-Z0-9[\\]]+)}/g, (original, key) => {\n      if (getUserVariable(this.user, key)) return getUserVariable(this.user, key);\n      return variables[key] ? variables[key].default : original;\n    });\n  }\n\n  operation(path, method) {\n    const operation = getPathOperation(this, {\n      swagger: {\n        path\n      },\n      api: {\n        method\n      }\n    });\n    return new Operation(this, path, method, operation);\n  }\n  /**\n   * Discover an operation in an OAS from a fully-formed URL and HTTP method. Will return an object containing a `url`\n   * object and another one for `operation`. This differs from `getOperation()` in that it does not return an instance\n   * of the `Operation` class.\n   *\n   * @param {String} url\n   * @param {String} method\n   * @return {(Object|undefined)}\n   */\n\n\n  findOperation(url, method) {\n    const {\n      origin\n    } = new URL(url);\n    const originRegExp = new RegExp(origin);\n    const {\n      servers,\n      paths\n    } = this;\n    if (!servers || !servers.length) return undefined;\n    const targetServer = servers.find(s => originRegExp.exec(this.replaceUrl(s.url, s.variables || {})));\n    if (!targetServer) return undefined;\n    targetServer.url = this.replaceUrl(targetServer.url, targetServer.variables || {});\n    const [, pathName] = url.split(targetServer.url);\n    if (pathName === undefined) return undefined;\n    const annotatedPaths = generatePathMatches(paths, pathName, targetServer.url);\n    if (!annotatedPaths.length) return undefined;\n    const includesMethod = filterPathMethods(annotatedPaths, method);\n    if (!includesMethod.length) return undefined;\n    return findTargetPath(includesMethod);\n  }\n  /**\n   * Retrieve an operation in an OAS from a fully-formed URL and HTTP method. Differs from `findOperation` in that while\n   * this method will return an `Operation` instance, `findOperation()` does not.\n   *\n   * @param {String} url\n   * @param {String} method\n   * @return {(Operation|undefined)}\n   */\n\n\n  getOperation(url, method) {\n    const op = this.findOperation(url, method);\n\n    if (op === undefined) {\n      return undefined;\n    }\n\n    return this.operation(op.url.path, method);\n  }\n\n}\n\nmodule.exports = Oas;\nmodule.exports.Operation = Operation;","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@readme/oas-tooling/src/oas.js"],"names":["pathToRegexp","match","require","getPathOperation","getUserVariable","Operation","ensureProtocol","url","normalizedUrl","oas","servers","Error","length","slice","e","normalizePath","path","replace","generatePathMatches","paths","pathName","origin","prunedPathName","split","Object","keys","map","cleanedPath","matchStatement","decode","decodeURIComponent","matchResult","slugs","params","forEach","param","nonNormalizedPath","operation","filter","p","filterPathMethods","pathMatches","targetMethod","regExp","captures","r","exec","method","toUpperCase","undefined","findTargetPath","minCount","m","selection","paramCount","Oas","constructor","user","assign","variables","replaceUrl","trim","original","key","default","swagger","api","findOperation","URL","originRegExp","RegExp","targetServer","find","s","annotatedPaths","includesMethod","getOperation","op","module","exports"],"mappings":"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","sourcesContent":["const { pathToRegexp, match } = require('path-to-regexp');\nconst getPathOperation = require('./lib/get-path-operation');\nconst getUserVariable = require('./lib/get-user-variable');\nconst Operation = require('./operation');\n\nfunction ensureProtocol(url) {\n  // Add protocol to urls starting with // e.g. //example.com\n  // This is because httpsnippet throws a HARError when it doesnt have a protocol\n  if (url.match(/^\\/\\//)) {\n    return `https:${url}`;\n  }\n\n  // Add protocol to urls with no // within them\n  // This is because httpsnippet throws a HARError when it doesnt have a protocol\n  if (!url.match(/\\/\\//)) {\n    return `https://${url}`;\n  }\n\n  return url;\n}\n\nfunction normalizedUrl(oas) {\n  let url;\n  try {\n    url = oas.servers[0].url;\n    // This is to catch the case where servers = [{}]\n    if (!url) throw new Error('no url');\n\n    // Stripping the '/' off the end\n    if (url[url.length - 1] === '/') {\n      url = url.slice(0, -1);\n    }\n  } catch (e) {\n    url = 'https://example.com';\n  }\n\n  return ensureProtocol(url);\n}\n\nfunction normalizePath(path) {\n  return path.replace(/{(.*?)}/g, ':$1');\n}\n\nfunction generatePathMatches(paths, pathName, origin) {\n  const prunedPathName = pathName.split('?')[0];\n  return Object.keys(paths)\n    .map(path => {\n      const cleanedPath = normalizePath(path);\n      const matchStatement = match(cleanedPath, { decode: decodeURIComponent });\n      const matchResult = matchStatement(prunedPathName);\n      const slugs = {};\n\n      if (matchResult && Object.keys(matchResult.params).length) {\n        Object.keys(matchResult.params).forEach(param => {\n          slugs[`:${param}`] = matchResult.params[param];\n        });\n      }\n\n      return {\n        url: {\n          origin,\n          path: cleanedPath,\n          nonNormalizedPath: path,\n          slugs,\n        },\n        operation: paths[path],\n        match: matchResult,\n      };\n    })\n    .filter(p => p.match);\n}\n\nfunction filterPathMethods(pathMatches, targetMethod) {\n  const regExp = pathToRegexp(targetMethod);\n  return pathMatches\n    .map(p => {\n      const captures = Object.keys(p.operation).filter(r => regExp.exec(r));\n\n      if (captures.length) {\n        const method = captures[0];\n        p.url.method = method.toUpperCase();\n\n        return {\n          url: p.url,\n          operation: p.operation[method],\n        };\n      }\n      return undefined;\n    })\n    .filter(p => p);\n}\n\nfunction findTargetPath(pathMatches) {\n  let minCount = Object.keys(pathMatches[0].url.slugs).length;\n  let operation;\n\n  for (let m = 0; m < pathMatches.length; m += 1) {\n    const selection = pathMatches[m];\n    const paramCount = Object.keys(selection.url.slugs).length;\n    if (paramCount <= minCount) {\n      minCount = paramCount;\n      operation = selection;\n    }\n  }\n\n  return operation;\n}\n\nclass Oas {\n  constructor(oas, user) {\n    Object.assign(this, oas);\n    this.user = user || {};\n  }\n\n  url() {\n    const url = normalizedUrl(this);\n\n    let variables;\n    try {\n      variables = this.servers[0].variables;\n      if (!variables) throw new Error('no variables');\n    } catch (e) {\n      variables = {};\n    }\n\n    return this.replaceUrl(url, variables).trim();\n  }\n\n  replaceUrl(url, variables) {\n    return url.replace(/{([-_a-zA-Z0-9[\\]]+)}/g, (original, key) => {\n      if (getUserVariable(this.user, key)) return getUserVariable(this.user, key);\n      return variables[key] ? variables[key].default : original;\n    });\n  }\n\n  operation(path, method) {\n    const operation = getPathOperation(this, { swagger: { path }, api: { method } });\n    return new Operation(this, path, method, operation);\n  }\n\n  /**\n   * Discover an operation in an OAS from a fully-formed URL and HTTP method. Will return an object containing a `url`\n   * object and another one for `operation`. This differs from `getOperation()` in that it does not return an instance\n   * of the `Operation` class.\n   *\n   * @param {String} url\n   * @param {String} method\n   * @return {(Object|undefined)}\n   */\n  findOperation(url, method) {\n    const { origin } = new URL(url);\n    const originRegExp = new RegExp(origin);\n    const { servers, paths } = this;\n\n    if (!servers || !servers.length) return undefined;\n    const targetServer = servers.find(s => originRegExp.exec(this.replaceUrl(s.url, s.variables || {})));\n    if (!targetServer) return undefined;\n    targetServer.url = this.replaceUrl(targetServer.url, targetServer.variables || {});\n\n    const [, pathName] = url.split(targetServer.url);\n    if (pathName === undefined) return undefined;\n    const annotatedPaths = generatePathMatches(paths, pathName, targetServer.url);\n    if (!annotatedPaths.length) return undefined;\n\n    const includesMethod = filterPathMethods(annotatedPaths, method);\n    if (!includesMethod.length) return undefined;\n\n    return findTargetPath(includesMethod);\n  }\n\n  /**\n   * Retrieve an operation in an OAS from a fully-formed URL and HTTP method. Differs from `findOperation` in that while\n   * this method will return an `Operation` instance, `findOperation()` does not.\n   *\n   * @param {String} url\n   * @param {String} method\n   * @return {(Operation|undefined)}\n   */\n  getOperation(url, method) {\n    const op = this.findOperation(url, method);\n    if (op === undefined) {\n      return undefined;\n    }\n\n    return this.operation(op.url.path, method);\n  }\n}\n\nmodule.exports = Oas;\nmodule.exports.Operation = Operation;\n"]},"metadata":{},"sourceType":"script"}