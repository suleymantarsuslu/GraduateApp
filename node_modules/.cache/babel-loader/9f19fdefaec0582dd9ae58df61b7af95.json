{"ast":null,"code":"function digestParameters(parameters) {\n  return parameters.reduce((prev, param) => {\n    if ('$ref' in param || 'allOf' in param || 'anyOf' in param || 'oneOf' in param) {\n      throw new Error(`The OpenAPI document for this operation wasn't dereferenced before processing.`);\n    } else if (param.name in prev) {\n      throw new Error(`The operation you are using has the same parameter, ${param.name}, spread across multiple entry points. We unfortunately can't handle this right now.`);\n    }\n\n    return Object.assign(prev, {\n      [param.name]: param\n    });\n  }, {});\n} // https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_isempty\n\n\nfunction isEmpty(obj) {\n  return [Object, Array].includes((obj || {}).constructor) && !Object.entries(obj || {}).length;\n}\n\nmodule.exports = function (operation, body, metadata) {\n  // If no data was supplied, just return immediately.\n  if (isEmpty(body) && isEmpty(metadata)) {\n    return {};\n  }\n\n  const params = {};\n  let shouldDigestParams = false;\n  const contentType = operation.getContentType();\n\n  if (Array.isArray(body)) {\n    // If the body param is an array, then it's absolutely a body and not something we need to do analysis against.\n    params.body = body;\n\n    if (typeof metadata !== 'undefined') {\n      shouldDigestParams = true;\n    }\n  } else if (typeof metadata === 'undefined') {\n    // No metadata was explicitly defined so we need to analyze the body to determine if it should actually be treated\n    // as metadata.\n    shouldDigestParams = true;\n  } else {\n    // Body and metadata were both supplied.\n    params.body = body;\n    shouldDigestParams = true;\n  }\n\n  let digested = {};\n  let hasDigestedParams = false;\n\n  if (shouldDigestParams) {\n    // @todo `operation.parameters` should also pull in common params (this does not happen automatically when dereffing!)\n    if ('parameters' in operation) {\n      digested = digestParameters(operation.parameters);\n      hasDigestedParams = Object.keys(digested).length;\n    }\n  } // No metadata was explicitly defined so we need to analyze the supplied, and we haven't already set a body then we\n  // need to analyze the supplied body to see if it should actually be metadata. If not, then we can just treat it as a\n  // body and pass it along.\n\n\n  if (!('body' in params) && typeof metadata === 'undefined') {\n    if (!hasDigestedParams) {\n      // No parameters were able to be digested, so we just have to assume that what the user supplied was for a body.\n      // This might lead to unwanted false positives if an OAS isn't accurate, but short of throwing an error there\n      // isn't anything we can really do about it.\n      params.body = body;\n    } else {\n      const intersection = Object.keys(body).filter(value => Object.keys(digested).includes(value)).length;\n\n      if (intersection && intersection / Object.keys(body).length > 0.25) {\n        // If more than 25% of the body intersects with the parameters that we've got on hand, then we should treat it\n        // as a metadata object and organize into parameters.\n        // eslint-disable-next-line no-param-reassign\n        metadata = body;\n      } else {\n        // For all other cases, we should just treat the supplied body as a body.\n        params.body = body;\n      }\n    }\n  } // @todo add in a debug mode that would run jsonschema validation against request bodies and parameters and throw back errors if what's supplied isn't up to spec.\n  // Only spend time trying to organize metadata into parameters if we were able to digest parameters out of the\n  // operation schema. If we couldn't digest anything, but metadata was supplied then we wouldn't know where to place\n  // the metadata!\n\n\n  if (hasDigestedParams) {\n    params.header = {};\n    params.path = {};\n    params.query = {};\n\n    if (typeof metadata === 'object' && !isEmpty(metadata)) {\n      const metadataKeys = Object.keys(metadata);\n\n      if (metadataKeys.length) {\n        metadataKeys.forEach(param => {\n          if (!(param in digested)) {\n            // This param isn't documented in the OAS, so we can't know where to put it!\n            return;\n          }\n\n          if (digested[param].in === 'path') {\n            params.path[param] = metadata[param];\n          } else if (digested[param].in === 'query') {\n            params.query[param] = metadata[param];\n          } else if (digested[param].in === 'header') {\n            params.header[param] = metadata[param];\n          } else if (digested[param].in === 'cookie') {// @todo add support cookie params here and also in @readme/oas-to-har\n          }\n        });\n      }\n    }\n  } // Form data should be placed inside `formData` instead of `body` for it to properly get picked up.\n\n\n  if (contentType === 'application/x-www-form-urlencoded') {\n    params.formData = body;\n    delete params.body;\n  } // @todo add required params with defaults if they aren't supplied\n  // @todo in debug mode, if a path param is missing (and required -- they always are), and no defaults are present, we should throw an error\n  // Clean up any empty items.\n\n\n  ['body', 'formData', 'header', 'path', 'query'].forEach(type => {\n    if (type in params && Object.keys(params[type]).length === 0) {\n      delete params[type];\n    }\n  });\n  return params;\n};","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/api/src/lib/prepareParams.js"],"names":["digestParameters","parameters","reduce","prev","param","Error","name","Object","assign","isEmpty","obj","Array","includes","constructor","entries","length","module","exports","operation","body","metadata","params","shouldDigestParams","contentType","getContentType","isArray","digested","hasDigestedParams","keys","intersection","filter","value","header","path","query","metadataKeys","forEach","in","formData","type"],"mappings":"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","sourcesContent":["function digestParameters(parameters) {\n  return parameters.reduce((prev, param) => {\n    if ('$ref' in param || 'allOf' in param || 'anyOf' in param || 'oneOf' in param) {\n      throw new Error(`The OpenAPI document for this operation wasn't dereferenced before processing.`);\n    } else if (param.name in prev) {\n      throw new Error(\n        `The operation you are using has the same parameter, ${param.name}, spread across multiple entry points. We unfortunately can't handle this right now.`\n      );\n    }\n\n    return Object.assign(prev, { [param.name]: param });\n  }, {});\n}\n\n// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_isempty\nfunction isEmpty(obj) {\n  return [Object, Array].includes((obj || {}).constructor) && !Object.entries(obj || {}).length;\n}\n\nmodule.exports = function (operation, body, metadata) {\n  // If no data was supplied, just return immediately.\n  if (isEmpty(body) && isEmpty(metadata)) {\n    return {};\n  }\n\n  const params = {};\n  let shouldDigestParams = false;\n  const contentType = operation.getContentType();\n\n  if (Array.isArray(body)) {\n    // If the body param is an array, then it's absolutely a body and not something we need to do analysis against.\n    params.body = body;\n\n    if (typeof metadata !== 'undefined') {\n      shouldDigestParams = true;\n    }\n  } else if (typeof metadata === 'undefined') {\n    // No metadata was explicitly defined so we need to analyze the body to determine if it should actually be treated\n    // as metadata.\n    shouldDigestParams = true;\n  } else {\n    // Body and metadata were both supplied.\n    params.body = body;\n    shouldDigestParams = true;\n  }\n\n  let digested = {};\n  let hasDigestedParams = false;\n  if (shouldDigestParams) {\n    // @todo `operation.parameters` should also pull in common params (this does not happen automatically when dereffing!)\n    if ('parameters' in operation) {\n      digested = digestParameters(operation.parameters);\n      hasDigestedParams = Object.keys(digested).length;\n    }\n  }\n\n  // No metadata was explicitly defined so we need to analyze the supplied, and we haven't already set a body then we\n  // need to analyze the supplied body to see if it should actually be metadata. If not, then we can just treat it as a\n  // body and pass it along.\n  if (!('body' in params) && typeof metadata === 'undefined') {\n    if (!hasDigestedParams) {\n      // No parameters were able to be digested, so we just have to assume that what the user supplied was for a body.\n      // This might lead to unwanted false positives if an OAS isn't accurate, but short of throwing an error there\n      // isn't anything we can really do about it.\n      params.body = body;\n    } else {\n      const intersection = Object.keys(body).filter(value => Object.keys(digested).includes(value)).length;\n      if (intersection && intersection / Object.keys(body).length > 0.25) {\n        // If more than 25% of the body intersects with the parameters that we've got on hand, then we should treat it\n        // as a metadata object and organize into parameters.\n        // eslint-disable-next-line no-param-reassign\n        metadata = body;\n      } else {\n        // For all other cases, we should just treat the supplied body as a body.\n        params.body = body;\n      }\n    }\n  }\n\n  // @todo add in a debug mode that would run jsonschema validation against request bodies and parameters and throw back errors if what's supplied isn't up to spec.\n\n  // Only spend time trying to organize metadata into parameters if we were able to digest parameters out of the\n  // operation schema. If we couldn't digest anything, but metadata was supplied then we wouldn't know where to place\n  // the metadata!\n  if (hasDigestedParams) {\n    params.header = {};\n    params.path = {};\n    params.query = {};\n\n    if (typeof metadata === 'object' && !isEmpty(metadata)) {\n      const metadataKeys = Object.keys(metadata);\n      if (metadataKeys.length) {\n        metadataKeys.forEach(param => {\n          if (!(param in digested)) {\n            // This param isn't documented in the OAS, so we can't know where to put it!\n            return;\n          }\n\n          if (digested[param].in === 'path') {\n            params.path[param] = metadata[param];\n          } else if (digested[param].in === 'query') {\n            params.query[param] = metadata[param];\n          } else if (digested[param].in === 'header') {\n            params.header[param] = metadata[param];\n          } else if (digested[param].in === 'cookie') {\n            // @todo add support cookie params here and also in @readme/oas-to-har\n          }\n        });\n      }\n    }\n  }\n\n  // Form data should be placed inside `formData` instead of `body` for it to properly get picked up.\n  if (contentType === 'application/x-www-form-urlencoded') {\n    params.formData = body;\n    delete params.body;\n  }\n\n  // @todo add required params with defaults if they aren't supplied\n  // @todo in debug mode, if a path param is missing (and required -- they always are), and no defaults are present, we should throw an error\n\n  // Clean up any empty items.\n  ['body', 'formData', 'header', 'path', 'query'].forEach(type => {\n    if (type in params && Object.keys(params[type]).length === 0) {\n      delete params[type];\n    }\n  });\n\n  return params;\n};\n"]},"metadata":{},"sourceType":"script"}