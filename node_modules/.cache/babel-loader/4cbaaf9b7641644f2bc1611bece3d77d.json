{"ast":null,"code":"// This library is built to translate OpenAPI schemas into schemas compatible with react-jsonschema-form, and should\n// not at this time be used for general purpose consumption.\nconst getSchema = require('./get-schema');\n\nconst findSchemaDefinition = require('./find-schema-definition'); // The order of this object determines how they will be sorted in the compiled JSON Schema\n// representation.\n// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#parameterObject\n\n\nconst types = {\n  path: 'Path Params',\n  query: 'Query Params',\n  body: 'Body Params',\n  cookie: 'Cookie Params',\n  formData: 'Form Data',\n  header: 'Headers'\n};\n\nfunction getBodyParam(pathOperation, oas) {\n  const schema = getSchema(pathOperation, oas);\n  if (!schema) return null;\n\n  const cleanupSchemaDefaults = (obj, prevProp = false, prevProps = []) => {\n    Object.keys(obj).forEach(prop => {\n      // Since this method is recursive, let's reset our states when we're first processing a new property tree.\n      if (!prevProp) {\n        prevProps = [];\n      }\n\n      if (obj[prop] === null) {// If the item is null, just carry on. Why do this in addition to `typeof obj[prop] == object`? Because\n        // `typeof null` equates to `object` for \"legacy reasons\" apparently.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null\n      } else if (typeof obj[prop] === 'object' && !Array.isArray(obj[prop])) {\n        // If we have a `properties` object, but no adjacent `type`, we know it's an object so just cast it as one.\n        if (prop === 'properties' && !('type' in obj)) {\n          if (prevProp && prevProp === 'properties') {// Only add a type if the previous prop isn't also named `properties`!\n          } else {\n            obj.type = 'object';\n          }\n        }\n\n        prevProps.push(prop);\n        cleanupSchemaDefaults(obj[prop], prop, prevProps);\n      } else {\n        if (prevProps.includes('properties') && !('type' in obj) && !('$ref' in obj) && !('allOf' in obj) && !('oneOf' in obj) && !('anyOf' in obj) && prevProp !== 'additionalProperties') {\n          // If we're processing a schema that has no types, no refs, and is just a lone schema, we should treat it at\n          // the bare minimum as a simple string so we make an attempt to generate valid JSON Schema.\n          obj.type = 'string';\n        }\n\n        switch (prop) {\n          case 'additionalProperties':\n            // If it's set to `false`, don't bother adding it.\n            if (obj[prop] === false) {\n              delete obj[prop];\n            }\n\n            break;\n\n          case 'default':\n            if ('allowEmptyValue' in obj && obj.allowEmptyValue && obj[prop] === '') {// If we have `allowEmptyValue` present, and the default is actually an empty string, let it through as\n              // it's allowed.\n            } else if (obj[prop] === '') {\n              delete obj[prop];\n            }\n\n            break;\n          // If we have a description or title on a component or request body schema, get rid of it because our\n          // @readme/react-jsonschema-form package will end up interpreting it as a lone `DescriptionField` element and\n          // we don't want that to appear in the frontend.\n\n          case 'description':\n          case 'title':\n            if (!prevProp) {\n              // If we have no previous prop, then we're processing a top-level title and description on a requestBody.\n              delete obj[prop];\n            } else if (prevProp !== false && prevProps.length === 1) {\n              // If we have a previous prop, but we're parsing the immediate schemas tree (we know this if prevProps\n              // only has a single entry as that entry will be the name of the schema!) in the components object, then\n              // we're processing a title and description on a component schema.\n              delete obj[prop];\n            }\n\n            break;\n\n          case 'maxLength':\n            obj.maximum = obj[prop];\n            delete obj[prop];\n            break;\n\n          case 'minLength':\n            obj.minimum = obj[prop];\n            delete obj[prop];\n            break;\n\n          case 'type':\n            if (obj.type === 'array') {\n              if (!('items' in obj)) {\n                if ('properties' in obj) {\n                  // This is a fix to handle cases where someone may have typod `items` as `properties` on an array.\n                  // Since throwing a complete failure isn't ideal, we can see that they meant for the type to be\n                  // `object`, so we  can do our best to shape the data into what they were intendint it to be.\n                  // README-6R\n                  obj.type = 'object';\n                } else {\n                  // This is a fix to handle cases where we have a malformed array with no `items` property present.\n                  // README-8E\n                  obj.items = {};\n                }\n              }\n            }\n\n            break;\n          // Do nothing\n\n          default:\n        }\n      }\n    });\n    return obj;\n  };\n\n  const type = schema.type === 'application/x-www-form-urlencoded' ? 'formData' : 'body';\n  let cleanedSchema;\n\n  if (oas.components) {\n    cleanedSchema = {\n      components: {},\n      ...cleanupSchemaDefaults(schema.schema)\n    }; // Since cleanupSchemaDefaults is a recursive method, it's best if we start it at the `components.schemas` level\n    // so we have immediate knowledge of when we're first processing a component schema, and can reset our internal\n    // prop states that keep track of how we should treat certain prop edge cases.\n\n    Object.keys(oas.components).forEach(componentType => {\n      cleanedSchema.components[componentType] = cleanupSchemaDefaults(oas.components[componentType]);\n    });\n  } else {\n    cleanedSchema = cleanupSchemaDefaults(schema.schema);\n  } // If there's not actually any data within this schema, don't bother returning it.\n\n\n  if (Object.keys(cleanedSchema).length === 0) {\n    return null;\n  }\n\n  return {\n    type,\n    label: types[type],\n    schema: cleanedSchema\n  };\n}\n\nfunction getCommonParams(pathOperation) {\n  const {\n    path\n  } = pathOperation || {};\n\n  if (pathOperation && 'oas' in pathOperation && 'paths' in pathOperation.oas && path in pathOperation.oas.paths) {\n    if ('parameters' in pathOperation.oas.paths[path]) {\n      return pathOperation.oas.paths[path].parameters;\n    }\n  }\n\n  return [];\n}\n\nfunction getOtherParams(pathOperation, oas) {\n  let operationParams = pathOperation.parameters || [];\n  const commonParams = getCommonParams(pathOperation);\n\n  if (commonParams.length !== 0) {\n    const commonParamsNotInParams = commonParams.filter(param => {\n      return !operationParams.find(param2 => {\n        if (param.name && param2.name) {\n          return param.name === param2.name && param.in === param2.in;\n        } else if (param.$ref && param2.$ref) {\n          return param.$ref === param2.$ref;\n        }\n\n        return false;\n      });\n    });\n    operationParams = operationParams.concat(commonParamsNotInParams || []);\n  }\n\n  const resolvedParameters = operationParams.map(param => {\n    if (param.$ref) return findSchemaDefinition(param.$ref, oas);\n    return param;\n  });\n\n  const constructSchema = (data, prevProp = false) => {\n    const schema = {};\n\n    if (data.$ref) {\n      data = findSchemaDefinition(data.$ref, oas);\n    }\n\n    if (!('type' in data) && !('$ref' in data) && !('allOf' in data) && !('anyOf' in data) && !('oneOf' in data) && (!prevProp || prevProp && prevProp !== 'additionalProperties')) {\n      // If we're processing a schema that has no types, no refs, and is just a lone schema, we should treat it at the\n      // bare minimum as a simple string so we make an attempt to generate valid JSON Schema.\n      schema.type = 'string';\n    } else if (data.type === 'array') {\n      schema.type = 'array';\n\n      if ('items' in data) {\n        if (Object.keys(data.items).length === 1 && typeof data.items.$ref !== 'undefined') {\n          schema.items = findSchemaDefinition(data.items.$ref, oas);\n        } else {\n          schema.items = data.items;\n        } // Run through the arrays contents and clean them up.\n\n\n        schema.items = constructSchema(schema.items);\n      } else if ('properties' in data || 'additionalProperties' in data) {\n        // This is a fix to handle cases where someone may have typod `items` as `properties` on an array. Since\n        // throwing a complete failure isn't ideal, we can see that they meant for the type to be `object`, so we can do\n        // our best to shape the data into what they were intending it to be.\n        // README-6R\n        schema.type = 'object';\n      } else {\n        // This is a fix to handle cases where we have a malformed array with no `items` property present.\n        // README-8E\n        schema.items = {};\n      }\n    } else if (data.type === 'object') {\n      schema.type = 'object';\n\n      if ('properties' in data) {\n        schema.properties = {};\n        Object.keys(data.properties).map(prop => {\n          schema.properties[prop] = constructSchema(data.properties[prop], prop);\n          return true;\n        });\n      }\n\n      if ('additionalProperties' in data) {\n        if (typeof data.additionalProperties === 'object' && data.additionalProperties !== null) {\n          schema.additionalProperties = constructSchema(data.additionalProperties, 'additionalProperties');\n        } else if (data.additionalProperties !== false) {\n          // If it's set to `false`, don't bother adding it.\n          schema.additionalProperties = data.additionalProperties;\n        }\n      }\n    } else if ('type' in data) {\n      schema.type = data.type;\n    } else {\n      // If we don't have a set type, but are dealing with an anyOf, oneOf, or allOf representation let's run through\n      // them and make sure they're good.\n      // eslint-disable-next-line no-lonely-if\n      if ('allOf' in data && Array.isArray(data.allOf)) {\n        schema.allOf = data.allOf;\n        schema.allOf.forEach((item, idx) => {\n          schema.allOf[idx] = constructSchema(item);\n        });\n      } else if ('anyOf' in data && Array.isArray(data.anyOf)) {\n        schema.anyOf = data.anyOf;\n        schema.anyOf.forEach((item, idx) => {\n          schema.anyOf[idx] = constructSchema(item);\n        });\n      } else if ('oneOf' in data && Array.isArray(data.oneOf)) {\n        schema.oneOf = data.oneOf;\n        schema.oneOf.forEach((item, idx) => {\n          schema.oneOf[idx] = constructSchema(item);\n        });\n      }\n    }\n\n    if ('allowEmptyValue' in data) {\n      schema.allowEmptyValue = data.allowEmptyValue;\n    } // Only add a default value if we actually have one.\n\n\n    if (typeof data.default !== 'undefined') {\n      if ('allowEmptyValue' in schema && schema.allowEmptyValue && data.default === '') {\n        // If we have `allowEmptyValue` present, and the default is actually an empty string, let it through as it's\n        // allowed.\n        schema.default = data.default;\n      } else if (data.default !== '') {\n        schema.default = data.default;\n      }\n    }\n\n    if ('description' in data) schema.description = data.description;\n    if ('enum' in data) schema.enum = data.enum;\n    if ('format' in data) schema.format = data.format;\n    if ('maxLength' in data) schema.maximum = data.maxLength;\n    if ('minLength' in data) schema.minimum = data.minLength;\n    return schema;\n  };\n\n  return Object.keys(types).map(type => {\n    const required = [];\n    const parameters = resolvedParameters.filter(param => param.in === type);\n\n    if (parameters.length === 0) {\n      return null;\n    }\n\n    const properties = parameters.reduce((prev, current) => {\n      const schema = { ...(current.schema ? constructSchema(current.schema) : {})\n      }; // If we still don't have a `type` at the highest level of this schema, and it's not a polymorphism/inheritance\n      // model, add a `string` type so the schema will be valid.\n\n      if (!('type' in schema) && !('allOf' in schema) && !('anyOf' in schema) && !('oneOf' in schema)) {\n        schema.type = 'string';\n      }\n\n      if (current.description) {\n        schema.description = current.description;\n      }\n\n      prev[current.name] = schema;\n\n      if (current.required) {\n        required.push(current.name);\n      }\n\n      return prev;\n    }, {});\n    return {\n      type,\n      label: types[type],\n      schema: {\n        type: 'object',\n        properties,\n        required\n      }\n    };\n  });\n}\n\nmodule.exports = (pathOperation, oas) => {\n  const hasRequestBody = !!pathOperation.requestBody;\n  const hasParameters = !!(pathOperation.parameters && pathOperation.parameters.length !== 0);\n  if (!hasParameters && !hasRequestBody && getCommonParams(pathOperation).length === 0) return null;\n  const typeKeys = Object.keys(types);\n  return [getBodyParam(pathOperation, oas)].concat(...getOtherParams(pathOperation, oas)).filter(Boolean).sort((a, b) => {\n    return typeKeys.indexOf(a.type) - typeKeys.indexOf(b.type);\n  });\n}; // Exported for use in oas-to-har for default values object\n\n\nmodule.exports.types = types;","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@readme/oas-tooling/src/lib/parameters-to-json-schema.js"],"names":["getSchema","require","findSchemaDefinition","types","path","query","body","cookie","formData","header","getBodyParam","pathOperation","oas","schema","cleanupSchemaDefaults","obj","prevProp","prevProps","Object","keys","forEach","prop","Array","isArray","type","push","includes","allowEmptyValue","length","maximum","minimum","items","cleanedSchema","components","componentType","label","getCommonParams","paths","parameters","getOtherParams","operationParams","commonParams","commonParamsNotInParams","filter","param","find","param2","name","in","$ref","concat","resolvedParameters","map","constructSchema","data","properties","additionalProperties","allOf","item","idx","anyOf","oneOf","default","description","enum","format","maxLength","minLength","required","reduce","prev","current","module","exports","hasRequestBody","requestBody","hasParameters","typeKeys","Boolean","sort","a","b","indexOf"],"mappings":"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","sourcesContent":["// This library is built to translate OpenAPI schemas into schemas compatible with react-jsonschema-form, and should\n// not at this time be used for general purpose consumption.\nconst getSchema = require('./get-schema');\nconst findSchemaDefinition = require('./find-schema-definition');\n\n// The order of this object determines how they will be sorted in the compiled JSON Schema\n// representation.\n// https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#parameterObject\nconst types = {\n  path: 'Path Params',\n  query: 'Query Params',\n  body: 'Body Params',\n  cookie: 'Cookie Params',\n  formData: 'Form Data',\n  header: 'Headers',\n};\n\nfunction getBodyParam(pathOperation, oas) {\n  const schema = getSchema(pathOperation, oas);\n  if (!schema) return null;\n\n  const cleanupSchemaDefaults = (obj, prevProp = false, prevProps = []) => {\n    Object.keys(obj).forEach(prop => {\n      // Since this method is recursive, let's reset our states when we're first processing a new property tree.\n      if (!prevProp) {\n        prevProps = [];\n      }\n\n      if (obj[prop] === null) {\n        // If the item is null, just carry on. Why do this in addition to `typeof obj[prop] == object`? Because\n        // `typeof null` equates to `object` for \"legacy reasons\" apparently.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null\n      } else if (typeof obj[prop] === 'object' && !Array.isArray(obj[prop])) {\n        // If we have a `properties` object, but no adjacent `type`, we know it's an object so just cast it as one.\n        if (prop === 'properties' && !('type' in obj)) {\n          if (prevProp && prevProp === 'properties') {\n            // Only add a type if the previous prop isn't also named `properties`!\n          } else {\n            obj.type = 'object';\n          }\n        }\n\n        prevProps.push(prop);\n        cleanupSchemaDefaults(obj[prop], prop, prevProps);\n      } else {\n        if (\n          prevProps.includes('properties') &&\n          !('type' in obj) &&\n          !('$ref' in obj) &&\n          !('allOf' in obj) &&\n          !('oneOf' in obj) &&\n          !('anyOf' in obj) &&\n          prevProp !== 'additionalProperties'\n        ) {\n          // If we're processing a schema that has no types, no refs, and is just a lone schema, we should treat it at\n          // the bare minimum as a simple string so we make an attempt to generate valid JSON Schema.\n          obj.type = 'string';\n        }\n\n        switch (prop) {\n          case 'additionalProperties':\n            // If it's set to `false`, don't bother adding it.\n            if (obj[prop] === false) {\n              delete obj[prop];\n            }\n            break;\n\n          case 'default':\n            if ('allowEmptyValue' in obj && obj.allowEmptyValue && obj[prop] === '') {\n              // If we have `allowEmptyValue` present, and the default is actually an empty string, let it through as\n              // it's allowed.\n            } else if (obj[prop] === '') {\n              delete obj[prop];\n            }\n            break;\n\n          // If we have a description or title on a component or request body schema, get rid of it because our\n          // @readme/react-jsonschema-form package will end up interpreting it as a lone `DescriptionField` element and\n          // we don't want that to appear in the frontend.\n          case 'description':\n          case 'title':\n            if (!prevProp) {\n              // If we have no previous prop, then we're processing a top-level title and description on a requestBody.\n              delete obj[prop];\n            } else if (prevProp !== false && prevProps.length === 1) {\n              // If we have a previous prop, but we're parsing the immediate schemas tree (we know this if prevProps\n              // only has a single entry as that entry will be the name of the schema!) in the components object, then\n              // we're processing a title and description on a component schema.\n              delete obj[prop];\n            }\n            break;\n\n          case 'maxLength':\n            obj.maximum = obj[prop];\n            delete obj[prop];\n            break;\n\n          case 'minLength':\n            obj.minimum = obj[prop];\n            delete obj[prop];\n            break;\n\n          case 'type':\n            if (obj.type === 'array') {\n              if (!('items' in obj)) {\n                if ('properties' in obj) {\n                  // This is a fix to handle cases where someone may have typod `items` as `properties` on an array.\n                  // Since throwing a complete failure isn't ideal, we can see that they meant for the type to be\n                  // `object`, so we  can do our best to shape the data into what they were intendint it to be.\n                  // README-6R\n                  obj.type = 'object';\n                } else {\n                  // This is a fix to handle cases where we have a malformed array with no `items` property present.\n                  // README-8E\n                  obj.items = {};\n                }\n              }\n            }\n            break;\n\n          // Do nothing\n          default:\n        }\n      }\n    });\n\n    return obj;\n  };\n\n  const type = schema.type === 'application/x-www-form-urlencoded' ? 'formData' : 'body';\n  let cleanedSchema;\n\n  if (oas.components) {\n    cleanedSchema = {\n      components: {},\n      ...cleanupSchemaDefaults(schema.schema),\n    };\n\n    // Since cleanupSchemaDefaults is a recursive method, it's best if we start it at the `components.schemas` level\n    // so we have immediate knowledge of when we're first processing a component schema, and can reset our internal\n    // prop states that keep track of how we should treat certain prop edge cases.\n    Object.keys(oas.components).forEach(componentType => {\n      cleanedSchema.components[componentType] = cleanupSchemaDefaults(oas.components[componentType]);\n    });\n  } else {\n    cleanedSchema = cleanupSchemaDefaults(schema.schema);\n  }\n\n  // If there's not actually any data within this schema, don't bother returning it.\n  if (Object.keys(cleanedSchema).length === 0) {\n    return null;\n  }\n\n  return {\n    type,\n    label: types[type],\n    schema: cleanedSchema,\n  };\n}\n\nfunction getCommonParams(pathOperation) {\n  const { path } = pathOperation || {};\n  if (pathOperation && 'oas' in pathOperation && 'paths' in pathOperation.oas && path in pathOperation.oas.paths) {\n    if ('parameters' in pathOperation.oas.paths[path]) {\n      return pathOperation.oas.paths[path].parameters;\n    }\n  }\n\n  return [];\n}\n\nfunction getOtherParams(pathOperation, oas) {\n  let operationParams = pathOperation.parameters || [];\n  const commonParams = getCommonParams(pathOperation);\n\n  if (commonParams.length !== 0) {\n    const commonParamsNotInParams = commonParams.filter(param => {\n      return !operationParams.find(param2 => {\n        if (param.name && param2.name) {\n          return param.name === param2.name && param.in === param2.in;\n        } else if (param.$ref && param2.$ref) {\n          return param.$ref === param2.$ref;\n        }\n\n        return false;\n      });\n    });\n\n    operationParams = operationParams.concat(commonParamsNotInParams || []);\n  }\n\n  const resolvedParameters = operationParams.map(param => {\n    if (param.$ref) return findSchemaDefinition(param.$ref, oas);\n    return param;\n  });\n\n  const constructSchema = (data, prevProp = false) => {\n    const schema = {};\n\n    if (data.$ref) {\n      data = findSchemaDefinition(data.$ref, oas);\n    }\n\n    if (\n      !('type' in data) &&\n      !('$ref' in data) &&\n      !('allOf' in data) &&\n      !('anyOf' in data) &&\n      !('oneOf' in data) &&\n      (!prevProp || (prevProp && prevProp !== 'additionalProperties'))\n    ) {\n      // If we're processing a schema that has no types, no refs, and is just a lone schema, we should treat it at the\n      // bare minimum as a simple string so we make an attempt to generate valid JSON Schema.\n      schema.type = 'string';\n    } else if (data.type === 'array') {\n      schema.type = 'array';\n\n      if ('items' in data) {\n        if (Object.keys(data.items).length === 1 && typeof data.items.$ref !== 'undefined') {\n          schema.items = findSchemaDefinition(data.items.$ref, oas);\n        } else {\n          schema.items = data.items;\n        }\n\n        // Run through the arrays contents and clean them up.\n        schema.items = constructSchema(schema.items);\n      } else if ('properties' in data || 'additionalProperties' in data) {\n        // This is a fix to handle cases where someone may have typod `items` as `properties` on an array. Since\n        // throwing a complete failure isn't ideal, we can see that they meant for the type to be `object`, so we can do\n        // our best to shape the data into what they were intending it to be.\n        // README-6R\n        schema.type = 'object';\n      } else {\n        // This is a fix to handle cases where we have a malformed array with no `items` property present.\n        // README-8E\n        schema.items = {};\n      }\n    } else if (data.type === 'object') {\n      schema.type = 'object';\n\n      if ('properties' in data) {\n        schema.properties = {};\n\n        Object.keys(data.properties).map(prop => {\n          schema.properties[prop] = constructSchema(data.properties[prop], prop);\n          return true;\n        });\n      }\n\n      if ('additionalProperties' in data) {\n        if (typeof data.additionalProperties === 'object' && data.additionalProperties !== null) {\n          schema.additionalProperties = constructSchema(data.additionalProperties, 'additionalProperties');\n        } else if (data.additionalProperties !== false) {\n          // If it's set to `false`, don't bother adding it.\n          schema.additionalProperties = data.additionalProperties;\n        }\n      }\n    } else if ('type' in data) {\n      schema.type = data.type;\n    } else {\n      // If we don't have a set type, but are dealing with an anyOf, oneOf, or allOf representation let's run through\n      // them and make sure they're good.\n      // eslint-disable-next-line no-lonely-if\n      if ('allOf' in data && Array.isArray(data.allOf)) {\n        schema.allOf = data.allOf;\n        schema.allOf.forEach((item, idx) => {\n          schema.allOf[idx] = constructSchema(item);\n        });\n      } else if ('anyOf' in data && Array.isArray(data.anyOf)) {\n        schema.anyOf = data.anyOf;\n        schema.anyOf.forEach((item, idx) => {\n          schema.anyOf[idx] = constructSchema(item);\n        });\n      } else if ('oneOf' in data && Array.isArray(data.oneOf)) {\n        schema.oneOf = data.oneOf;\n        schema.oneOf.forEach((item, idx) => {\n          schema.oneOf[idx] = constructSchema(item);\n        });\n      }\n    }\n\n    if ('allowEmptyValue' in data) {\n      schema.allowEmptyValue = data.allowEmptyValue;\n    }\n\n    // Only add a default value if we actually have one.\n    if (typeof data.default !== 'undefined') {\n      if ('allowEmptyValue' in schema && schema.allowEmptyValue && data.default === '') {\n        // If we have `allowEmptyValue` present, and the default is actually an empty string, let it through as it's\n        // allowed.\n        schema.default = data.default;\n      } else if (data.default !== '') {\n        schema.default = data.default;\n      }\n    }\n\n    if ('description' in data) schema.description = data.description;\n    if ('enum' in data) schema.enum = data.enum;\n    if ('format' in data) schema.format = data.format;\n    if ('maxLength' in data) schema.maximum = data.maxLength;\n    if ('minLength' in data) schema.minimum = data.minLength;\n\n    return schema;\n  };\n\n  return Object.keys(types).map(type => {\n    const required = [];\n\n    const parameters = resolvedParameters.filter(param => param.in === type);\n    if (parameters.length === 0) {\n      return null;\n    }\n\n    const properties = parameters.reduce((prev, current) => {\n      const schema = {\n        ...(current.schema ? constructSchema(current.schema) : {}),\n      };\n\n      // If we still don't have a `type` at the highest level of this schema, and it's not a polymorphism/inheritance\n      // model, add a `string` type so the schema will be valid.\n      if (!('type' in schema) && !('allOf' in schema) && !('anyOf' in schema) && !('oneOf' in schema)) {\n        schema.type = 'string';\n      }\n\n      if (current.description) {\n        schema.description = current.description;\n      }\n\n      prev[current.name] = schema;\n\n      if (current.required) {\n        required.push(current.name);\n      }\n\n      return prev;\n    }, {});\n\n    return {\n      type,\n      label: types[type],\n      schema: {\n        type: 'object',\n        properties,\n        required,\n      },\n    };\n  });\n}\n\nmodule.exports = (pathOperation, oas) => {\n  const hasRequestBody = !!pathOperation.requestBody;\n  const hasParameters = !!(pathOperation.parameters && pathOperation.parameters.length !== 0);\n  if (!hasParameters && !hasRequestBody && getCommonParams(pathOperation).length === 0) return null;\n\n  const typeKeys = Object.keys(types);\n  return [getBodyParam(pathOperation, oas)]\n    .concat(...getOtherParams(pathOperation, oas))\n    .filter(Boolean)\n    .sort((a, b) => {\n      return typeKeys.indexOf(a.type) - typeKeys.indexOf(b.type);\n    });\n};\n\n// Exported for use in oas-to-har for default values object\nmodule.exports.types = types;\n"]},"metadata":{},"sourceType":"script"}