{"ast":null,"code":"\"use strict\";\n\nvar Report = require(\"./Report\");\n\nvar SchemaCache = require(\"./SchemaCache\");\n\nvar Utils = require(\"./Utils\");\n\nfunction mergeReference(scope, ref) {\n  if (Utils.isAbsoluteUri(ref)) {\n    return ref;\n  }\n\n  var joinedScope = scope.join(\"\"),\n      isScopeAbsolute = Utils.isAbsoluteUri(joinedScope),\n      isScopeRelative = Utils.isRelativeUri(joinedScope),\n      isRefRelative = Utils.isRelativeUri(ref),\n      toRemove;\n\n  if (isScopeAbsolute && isRefRelative) {\n    toRemove = joinedScope.match(/\\/[^\\/]*$/);\n\n    if (toRemove) {\n      joinedScope = joinedScope.slice(0, toRemove.index + 1);\n    }\n  } else if (isScopeRelative && isRefRelative) {\n    joinedScope = \"\";\n  } else {\n    toRemove = joinedScope.match(/[^#/]+$/);\n\n    if (toRemove) {\n      joinedScope = joinedScope.slice(0, toRemove.index);\n    }\n  }\n\n  var res = joinedScope + ref;\n  res = res.replace(/##/, \"#\");\n  return res;\n}\n\nfunction collectReferences(obj, results, scope, path) {\n  results = results || [];\n  scope = scope || [];\n  path = path || [];\n\n  if (typeof obj !== \"object\" || obj === null) {\n    return results;\n  }\n\n  if (typeof obj.id === \"string\") {\n    scope.push(obj.id);\n  }\n\n  if (typeof obj.$ref === \"string\" && typeof obj.__$refResolved === \"undefined\") {\n    results.push({\n      ref: mergeReference(scope, obj.$ref),\n      key: \"$ref\",\n      obj: obj,\n      path: path.slice(0)\n    });\n  }\n\n  if (typeof obj.$schema === \"string\" && typeof obj.__$schemaResolved === \"undefined\") {\n    results.push({\n      ref: mergeReference(scope, obj.$schema),\n      key: \"$schema\",\n      obj: obj,\n      path: path.slice(0)\n    });\n  }\n\n  var idx;\n\n  if (Array.isArray(obj)) {\n    idx = obj.length;\n\n    while (idx--) {\n      path.push(idx.toString());\n      collectReferences(obj[idx], results, scope, path);\n      path.pop();\n    }\n  } else {\n    var keys = Object.keys(obj);\n    idx = keys.length;\n\n    while (idx--) {\n      // do not recurse through resolved references and other z-schema props\n      if (keys[idx].indexOf(\"__$\") === 0) {\n        continue;\n      }\n\n      path.push(keys[idx]);\n      collectReferences(obj[keys[idx]], results, scope, path);\n      path.pop();\n    }\n  }\n\n  if (typeof obj.id === \"string\") {\n    scope.pop();\n  }\n\n  return results;\n}\n\nvar compileArrayOfSchemasLoop = function (mainReport, arr) {\n  var idx = arr.length,\n      compiledCount = 0;\n\n  while (idx--) {\n    // try to compile each schema separately\n    var report = new Report(mainReport);\n    var isValid = exports.compileSchema.call(this, report, arr[idx]);\n\n    if (isValid) {\n      compiledCount++;\n    } // copy errors to report\n\n\n    mainReport.errors = mainReport.errors.concat(report.errors);\n  }\n\n  return compiledCount;\n};\n\nfunction findId(arr, id) {\n  var idx = arr.length;\n\n  while (idx--) {\n    if (arr[idx].id === id) {\n      return arr[idx];\n    }\n  }\n\n  return null;\n}\n\nvar compileArrayOfSchemas = function (report, arr) {\n  var compiled = 0,\n      lastLoopCompiled;\n\n  do {\n    // remove all UNRESOLVABLE_REFERENCE errors before compiling array again\n    var idx = report.errors.length;\n\n    while (idx--) {\n      if (report.errors[idx].code === \"UNRESOLVABLE_REFERENCE\") {\n        report.errors.splice(idx, 1);\n      }\n    } // remember how many were compiled in the last loop\n\n\n    lastLoopCompiled = compiled; // count how many are compiled now\n\n    compiled = compileArrayOfSchemasLoop.call(this, report, arr); // fix __$missingReferences if possible\n\n    idx = arr.length;\n\n    while (idx--) {\n      var sch = arr[idx];\n\n      if (sch.__$missingReferences) {\n        var idx2 = sch.__$missingReferences.length;\n\n        while (idx2--) {\n          var refObj = sch.__$missingReferences[idx2];\n          var response = findId(arr, refObj.ref);\n\n          if (response) {\n            // this might create circular references\n            refObj.obj[\"__\" + refObj.key + \"Resolved\"] = response; // it's resolved now so delete it\n\n            sch.__$missingReferences.splice(idx2, 1);\n          }\n        }\n\n        if (sch.__$missingReferences.length === 0) {\n          delete sch.__$missingReferences;\n        }\n      }\n    } // keep repeating if not all compiled and at least one more was compiled in the last loop\n\n  } while (compiled !== arr.length && compiled !== lastLoopCompiled);\n\n  return report.isValid();\n};\n\nexports.compileSchema = function (report, schema) {\n  report.commonErrorMessage = \"SCHEMA_COMPILATION_FAILED\"; // if schema is a string, assume it's a uri\n\n  if (typeof schema === \"string\") {\n    var loadedSchema = SchemaCache.getSchemaByUri.call(this, report, schema);\n\n    if (!loadedSchema) {\n      report.addError(\"SCHEMA_NOT_REACHABLE\", [schema]);\n      return false;\n    }\n\n    schema = loadedSchema;\n  } // if schema is an array, assume it's an array of schemas\n\n\n  if (Array.isArray(schema)) {\n    return compileArrayOfSchemas.call(this, report, schema);\n  } // if we have an id than it should be cached already (if this instance has compiled it)\n\n\n  if (schema.__$compiled && schema.id && SchemaCache.checkCacheForUri.call(this, schema.id) === false) {\n    schema.__$compiled = undefined;\n  } // do not re-compile schemas\n\n\n  if (schema.__$compiled) {\n    return true;\n  }\n\n  if (schema.id && typeof schema.id === \"string\") {\n    // add this to our schemaCache (before compilation in case we have references including id)\n    SchemaCache.cacheSchemaByUri.call(this, schema.id, schema);\n  } // this method can be called recursively, so we need to remember our root\n\n\n  var isRoot = false;\n\n  if (!report.rootSchema) {\n    report.rootSchema = schema;\n    isRoot = true;\n  } // delete all __$missingReferences from previous compilation attempts\n\n\n  var isValidExceptReferences = report.isValid();\n  delete schema.__$missingReferences; // collect all references that need to be resolved - $ref and $schema\n\n  var refs = collectReferences.call(this, schema),\n      idx = refs.length;\n\n  while (idx--) {\n    // resolve all the collected references into __xxxResolved pointer\n    var refObj = refs[idx];\n    var response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema); // we can try to use custom schemaReader if available\n\n    if (!response) {\n      var schemaReader = this.getSchemaReader();\n\n      if (schemaReader) {\n        // it's supposed to return a valid schema\n        var s = schemaReader(refObj.ref);\n\n        if (s) {\n          // it needs to have the id\n          s.id = refObj.ref; // try to compile the schema\n\n          var subreport = new Report(report);\n\n          if (!exports.compileSchema.call(this, subreport, s)) {\n            // copy errors to report\n            report.errors = report.errors.concat(subreport.errors);\n          } else {\n            response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);\n          }\n        }\n      }\n    }\n\n    if (!response) {\n      var hasNotValid = report.hasError(\"REMOTE_NOT_VALID\", [refObj.ref]);\n      var isAbsolute = Utils.isAbsoluteUri(refObj.ref);\n      var isDownloaded = false;\n      var ignoreUnresolvableRemotes = this.options.ignoreUnresolvableReferences === true;\n\n      if (isAbsolute) {\n        // we shouldn't add UNRESOLVABLE_REFERENCE for schemas we already have downloaded\n        // and set through setRemoteReference method\n        isDownloaded = SchemaCache.checkCacheForUri.call(this, refObj.ref);\n      }\n\n      if (hasNotValid) {// already has REMOTE_NOT_VALID error for this one\n      } else if (ignoreUnresolvableRemotes && isAbsolute) {// ignoreUnresolvableRemotes is on and remote isAbsolute\n      } else if (isDownloaded) {// remote is downloaded, so no UNRESOLVABLE_REFERENCE\n      } else {\n        Array.prototype.push.apply(report.path, refObj.path);\n        report.addError(\"UNRESOLVABLE_REFERENCE\", [refObj.ref]);\n        report.path = report.path.slice(0, -refObj.path.length); // pusblish unresolved references out\n\n        if (isValidExceptReferences) {\n          schema.__$missingReferences = schema.__$missingReferences || [];\n\n          schema.__$missingReferences.push(refObj);\n        }\n      }\n    } // this might create circular references\n\n\n    refObj.obj[\"__\" + refObj.key + \"Resolved\"] = response;\n  }\n\n  var isValid = report.isValid();\n\n  if (isValid) {\n    schema.__$compiled = true;\n  } else {\n    if (schema.id && typeof schema.id === \"string\") {\n      // remove this schema from schemaCache because it failed to compile\n      SchemaCache.removeFromCacheByUri.call(this, schema.id);\n    }\n  } // we don't need the root pointer anymore\n\n\n  if (isRoot) {\n    report.rootSchema = undefined;\n  }\n\n  return isValid;\n};","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/z-schema/src/SchemaCompilation.js"],"names":["Report","require","SchemaCache","Utils","mergeReference","scope","ref","isAbsoluteUri","joinedScope","join","isScopeAbsolute","isScopeRelative","isRelativeUri","isRefRelative","toRemove","match","slice","index","res","replace","collectReferences","obj","results","path","id","push","$ref","__$refResolved","key","$schema","__$schemaResolved","idx","Array","isArray","length","toString","pop","keys","Object","indexOf","compileArrayOfSchemasLoop","mainReport","arr","compiledCount","report","isValid","exports","compileSchema","call","errors","concat","findId","compileArrayOfSchemas","compiled","lastLoopCompiled","code","splice","sch","__$missingReferences","idx2","refObj","response","schema","commonErrorMessage","loadedSchema","getSchemaByUri","addError","__$compiled","checkCacheForUri","undefined","cacheSchemaByUri","isRoot","rootSchema","isValidExceptReferences","refs","schemaReader","getSchemaReader","s","subreport","hasNotValid","hasError","isAbsolute","isDownloaded","ignoreUnresolvableRemotes","options","ignoreUnresolvableReferences","prototype","apply","removeFromCacheByUri"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar Report      = require(\"./Report\");\nvar SchemaCache = require(\"./SchemaCache\");\nvar Utils       = require(\"./Utils\");\n\nfunction mergeReference(scope, ref) {\n    if (Utils.isAbsoluteUri(ref)) {\n        return ref;\n    }\n\n    var joinedScope = scope.join(\"\"),\n        isScopeAbsolute = Utils.isAbsoluteUri(joinedScope),\n        isScopeRelative = Utils.isRelativeUri(joinedScope),\n        isRefRelative = Utils.isRelativeUri(ref),\n        toRemove;\n\n    if (isScopeAbsolute && isRefRelative) {\n        toRemove = joinedScope.match(/\\/[^\\/]*$/);\n        if (toRemove) {\n            joinedScope = joinedScope.slice(0, toRemove.index + 1);\n        }\n    } else if (isScopeRelative && isRefRelative) {\n        joinedScope = \"\";\n    } else {\n        toRemove = joinedScope.match(/[^#/]+$/);\n        if (toRemove) {\n            joinedScope = joinedScope.slice(0, toRemove.index);\n        }\n    }\n\n    var res = joinedScope + ref;\n    res = res.replace(/##/, \"#\");\n    return res;\n}\n\nfunction collectReferences(obj, results, scope, path) {\n    results = results || [];\n    scope = scope || [];\n    path = path || [];\n\n    if (typeof obj !== \"object\" || obj === null) {\n        return results;\n    }\n\n    if (typeof obj.id === \"string\") {\n        scope.push(obj.id);\n    }\n\n    if (typeof obj.$ref === \"string\" && typeof obj.__$refResolved === \"undefined\") {\n        results.push({\n            ref: mergeReference(scope, obj.$ref),\n            key: \"$ref\",\n            obj: obj,\n            path: path.slice(0)\n        });\n    }\n    if (typeof obj.$schema === \"string\" && typeof obj.__$schemaResolved === \"undefined\") {\n        results.push({\n            ref: mergeReference(scope, obj.$schema),\n            key: \"$schema\",\n            obj: obj,\n            path: path.slice(0)\n        });\n    }\n\n    var idx;\n    if (Array.isArray(obj)) {\n        idx = obj.length;\n        while (idx--) {\n            path.push(idx.toString());\n            collectReferences(obj[idx], results, scope, path);\n            path.pop();\n        }\n    } else {\n        var keys = Object.keys(obj);\n        idx = keys.length;\n        while (idx--) {\n            // do not recurse through resolved references and other z-schema props\n            if (keys[idx].indexOf(\"__$\") === 0) { continue; }\n            path.push(keys[idx]);\n            collectReferences(obj[keys[idx]], results, scope, path);\n            path.pop();\n        }\n    }\n\n    if (typeof obj.id === \"string\") {\n        scope.pop();\n    }\n\n    return results;\n}\n\nvar compileArrayOfSchemasLoop = function (mainReport, arr) {\n    var idx = arr.length,\n        compiledCount = 0;\n\n    while (idx--) {\n\n        // try to compile each schema separately\n        var report = new Report(mainReport);\n        var isValid = exports.compileSchema.call(this, report, arr[idx]);\n        if (isValid) { compiledCount++; }\n\n        // copy errors to report\n        mainReport.errors = mainReport.errors.concat(report.errors);\n\n    }\n\n    return compiledCount;\n};\n\nfunction findId(arr, id) {\n    var idx = arr.length;\n    while (idx--) {\n        if (arr[idx].id === id) {\n            return arr[idx];\n        }\n    }\n    return null;\n}\n\nvar compileArrayOfSchemas = function (report, arr) {\n\n    var compiled = 0,\n        lastLoopCompiled;\n\n    do {\n\n        // remove all UNRESOLVABLE_REFERENCE errors before compiling array again\n        var idx = report.errors.length;\n        while (idx--) {\n            if (report.errors[idx].code === \"UNRESOLVABLE_REFERENCE\") {\n                report.errors.splice(idx, 1);\n            }\n        }\n\n        // remember how many were compiled in the last loop\n        lastLoopCompiled = compiled;\n\n        // count how many are compiled now\n        compiled = compileArrayOfSchemasLoop.call(this, report, arr);\n\n        // fix __$missingReferences if possible\n        idx = arr.length;\n        while (idx--) {\n            var sch = arr[idx];\n            if (sch.__$missingReferences) {\n                var idx2 = sch.__$missingReferences.length;\n                while (idx2--) {\n                    var refObj = sch.__$missingReferences[idx2];\n                    var response = findId(arr, refObj.ref);\n                    if (response) {\n                        // this might create circular references\n                        refObj.obj[\"__\" + refObj.key + \"Resolved\"] = response;\n                        // it's resolved now so delete it\n                        sch.__$missingReferences.splice(idx2, 1);\n                    }\n                }\n                if (sch.__$missingReferences.length === 0) {\n                    delete sch.__$missingReferences;\n                }\n            }\n        }\n\n        // keep repeating if not all compiled and at least one more was compiled in the last loop\n    } while (compiled !== arr.length && compiled !== lastLoopCompiled);\n\n    return report.isValid();\n\n};\n\nexports.compileSchema = function (report, schema) {\n\n    report.commonErrorMessage = \"SCHEMA_COMPILATION_FAILED\";\n\n    // if schema is a string, assume it's a uri\n    if (typeof schema === \"string\") {\n        var loadedSchema = SchemaCache.getSchemaByUri.call(this, report, schema);\n        if (!loadedSchema) {\n            report.addError(\"SCHEMA_NOT_REACHABLE\", [schema]);\n            return false;\n        }\n        schema = loadedSchema;\n    }\n\n    // if schema is an array, assume it's an array of schemas\n    if (Array.isArray(schema)) {\n        return compileArrayOfSchemas.call(this, report, schema);\n    }\n\n    // if we have an id than it should be cached already (if this instance has compiled it)\n    if (schema.__$compiled && schema.id && SchemaCache.checkCacheForUri.call(this, schema.id) === false) {\n        schema.__$compiled = undefined;\n    }\n\n    // do not re-compile schemas\n    if (schema.__$compiled) {\n        return true;\n    }\n\n    if (schema.id && typeof schema.id === \"string\") {\n        // add this to our schemaCache (before compilation in case we have references including id)\n        SchemaCache.cacheSchemaByUri.call(this, schema.id, schema);\n    }\n\n    // this method can be called recursively, so we need to remember our root\n    var isRoot = false;\n    if (!report.rootSchema) {\n        report.rootSchema = schema;\n        isRoot = true;\n    }\n\n    // delete all __$missingReferences from previous compilation attempts\n    var isValidExceptReferences = report.isValid();\n    delete schema.__$missingReferences;\n\n    // collect all references that need to be resolved - $ref and $schema\n    var refs = collectReferences.call(this, schema),\n        idx = refs.length;\n    while (idx--) {\n        // resolve all the collected references into __xxxResolved pointer\n        var refObj = refs[idx];\n        var response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);\n\n        // we can try to use custom schemaReader if available\n        if (!response) {\n            var schemaReader = this.getSchemaReader();\n            if (schemaReader) {\n                // it's supposed to return a valid schema\n                var s = schemaReader(refObj.ref);\n                if (s) {\n                    // it needs to have the id\n                    s.id = refObj.ref;\n                    // try to compile the schema\n                    var subreport = new Report(report);\n                    if (!exports.compileSchema.call(this, subreport, s)) {\n                        // copy errors to report\n                        report.errors = report.errors.concat(subreport.errors);\n                    } else {\n                        response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);\n                    }\n                }\n            }\n        }\n\n        if (!response) {\n\n            var hasNotValid = report.hasError(\"REMOTE_NOT_VALID\", [refObj.ref]);\n            var isAbsolute = Utils.isAbsoluteUri(refObj.ref);\n            var isDownloaded = false;\n            var ignoreUnresolvableRemotes = this.options.ignoreUnresolvableReferences === true;\n\n            if (isAbsolute) {\n                // we shouldn't add UNRESOLVABLE_REFERENCE for schemas we already have downloaded\n                // and set through setRemoteReference method\n                isDownloaded = SchemaCache.checkCacheForUri.call(this, refObj.ref);\n            }\n\n            if (hasNotValid) {\n                // already has REMOTE_NOT_VALID error for this one\n            } else if (ignoreUnresolvableRemotes && isAbsolute) {\n                // ignoreUnresolvableRemotes is on and remote isAbsolute\n            } else if (isDownloaded) {\n                // remote is downloaded, so no UNRESOLVABLE_REFERENCE\n            } else {\n                Array.prototype.push.apply(report.path, refObj.path);\n                report.addError(\"UNRESOLVABLE_REFERENCE\", [refObj.ref]);\n                report.path = report.path.slice(0, -refObj.path.length);\n\n                // pusblish unresolved references out\n                if (isValidExceptReferences) {\n                    schema.__$missingReferences = schema.__$missingReferences || [];\n                    schema.__$missingReferences.push(refObj);\n                }\n            }\n        }\n        // this might create circular references\n        refObj.obj[\"__\" + refObj.key + \"Resolved\"] = response;\n    }\n\n    var isValid = report.isValid();\n    if (isValid) {\n        schema.__$compiled = true;\n    } else {\n        if (schema.id && typeof schema.id === \"string\") {\n            // remove this schema from schemaCache because it failed to compile\n            SchemaCache.removeFromCacheByUri.call(this, schema.id);\n        }\n    }\n\n    // we don't need the root pointer anymore\n    if (isRoot) {\n        report.rootSchema = undefined;\n    }\n\n    return isValid;\n\n};\n"]},"metadata":{},"sourceType":"script"}