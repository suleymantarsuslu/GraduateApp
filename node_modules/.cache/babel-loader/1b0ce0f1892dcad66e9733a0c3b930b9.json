{"ast":null,"code":"\"use strict\";\n\nvar reduce = require(\"reducible/reduce\");\n\nvar reducible = require(\"reducible/reducible\");\n\nvar isError = require(\"reducible/is-error\");\n\nvar end = require(\"reducible/end\");\n\nfunction reducer(process) {\n  /**\n  Convenience function to simplify definitions of transformation function, to\n  avoid manual definition of `reducible` results and currying transformation\n  function. It creates typical transformation function with a following\n  signature:\n       transform(source, options)\n   From a pure data `process` function that is called on each value for a\n  collection with following arguments:\n     1. `options` - Options passed to the resulting transformation function\n       most commonly that's a function like in `map(source, f)`.\n    2. `next` - Function which needs to be invoked with transformed value,\n       or simply not called to skip the value.\n    3. `value` - Last value emitted by a collection being reduced.\n    4. `result` - Accumulate value.\n   Function is supposed to return new, accumulated `result`. It may either\n  pass mapped transformed `value` and `result` to the `next` continuation\n  or skip it.\n   For example see `map` and `filter` functions.\n  **/\n  return function reducer(source, options) {\n    // When return transformation function is called with a source and\n    // `options`\n    return reducible(function reduceReducer(next, initial) {\n      // When actual result is \n      reduce(source, function reduceReducerSource(value, result) {\n        // If value is `end` of source or an error just propagate through,\n        // otherwise call `process` with all the curried `options` and `next`\n        // continuation function.\n        return value === end ? next(value, result) : isError(value) ? next(value, result) : process(options, next, value, result);\n      });\n    });\n  };\n}\n\nmodule.exports = reducer;","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/reducers/reducer.js"],"names":["reduce","require","reducible","isError","end","reducer","process","source","options","reduceReducer","next","initial","reduceReducerSource","value","result","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,kBAAD,CAApB;;AACA,IAAIC,SAAS,GAAGD,OAAO,CAAC,qBAAD,CAAvB;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,oBAAD,CAArB;;AACA,IAAIG,GAAG,GAAGH,OAAO,CAAC,eAAD,CAAjB;;AAGA,SAASI,OAAT,CAAiBC,OAAjB,EAA0B;AACxB;;;;;;;;;;;;;;;;;;;AAwBA,SAAO,SAASD,OAAT,CAAiBE,MAAjB,EAAyBC,OAAzB,EAAkC;AACvC;AACA;AACA,WAAON,SAAS,CAAC,SAASO,aAAT,CAAuBC,IAAvB,EAA6BC,OAA7B,EAAsC;AACrD;AACAX,MAAAA,MAAM,CAACO,MAAD,EAAS,SAASK,mBAAT,CAA6BC,KAA7B,EAAoCC,MAApC,EAA4C;AACzD;AACA;AACA;AACA,eAAOD,KAAK,KAAKT,GAAV,GAAgBM,IAAI,CAACG,KAAD,EAAQC,MAAR,CAApB,GACAX,OAAO,CAACU,KAAD,CAAP,GAAiBH,IAAI,CAACG,KAAD,EAAQC,MAAR,CAArB,GACAR,OAAO,CAACE,OAAD,EAAUE,IAAV,EAAgBG,KAAhB,EAAuBC,MAAvB,CAFd;AAGD,OAPK,CAAN;AAQD,KAVe,CAAhB;AAWD,GAdD;AAeD;;AAEDC,MAAM,CAACC,OAAP,GAAiBX,OAAjB","sourcesContent":["\"use strict\";\n\nvar reduce = require(\"reducible/reduce\")\nvar reducible = require(\"reducible/reducible\")\nvar isError = require(\"reducible/is-error\")\nvar end = require(\"reducible/end\")\n\n\nfunction reducer(process) {\n  /**\n  Convenience function to simplify definitions of transformation function, to\n  avoid manual definition of `reducible` results and currying transformation\n  function. It creates typical transformation function with a following\n  signature:\n\n      transform(source, options)\n\n  From a pure data `process` function that is called on each value for a\n  collection with following arguments:\n\n    1. `options` - Options passed to the resulting transformation function\n       most commonly that's a function like in `map(source, f)`.\n    2. `next` - Function which needs to be invoked with transformed value,\n       or simply not called to skip the value.\n    3. `value` - Last value emitted by a collection being reduced.\n    4. `result` - Accumulate value.\n\n  Function is supposed to return new, accumulated `result`. It may either\n  pass mapped transformed `value` and `result` to the `next` continuation\n  or skip it.\n\n  For example see `map` and `filter` functions.\n  **/\n  return function reducer(source, options) {\n    // When return transformation function is called with a source and\n    // `options`\n    return reducible(function reduceReducer(next, initial) {\n      // When actual result is \n      reduce(source, function reduceReducerSource(value, result) {\n        // If value is `end` of source or an error just propagate through,\n        // otherwise call `process` with all the curried `options` and `next`\n        // continuation function.\n        return value === end ? next(value, result) :\n               isError(value) ? next(value, result) :\n               process(options, next, value, result)\n      })\n    })\n  }\n}\n\nmodule.exports = reducer\n"]},"metadata":{},"sourceType":"script"}