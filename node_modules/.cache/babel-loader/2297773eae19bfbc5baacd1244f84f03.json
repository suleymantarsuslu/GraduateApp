{"ast":null,"code":"\"use strict\";\n\nconst {\n  ono\n} = require(\"@jsdevtools/ono\");\n\nconst url = require(\"./util/url\");\n\nconst plugins = require(\"./util/plugins\");\n\nmodule.exports = parse;\n/**\n * Reads and parses the specified file path or URL.\n *\n * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.\n */\n\nasync function parse(path, $refs, options) {\n  try {\n    // Remove the URL fragment, if any\n    path = url.stripHash(path); // Add a new $Ref for this file, even though we don't have the value yet.\n    // This ensures that we don't simultaneously read & parse the same file multiple times\n\n    let $ref = $refs._add(path); // This \"file object\" will be passed to all resolvers and parsers.\n\n\n    let file = {\n      url: path,\n      extension: url.getExtension(path)\n    }; // Read the file and then parse the data\n\n    const resolver = await readFile(file, options, $refs);\n    $ref.pathType = resolver.plugin.name;\n    file.data = resolver.result;\n    const parser = await parseFile(file, options, $refs);\n    $ref.value = parser.result;\n    return parser.result;\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the raw file contents and the resolver that was used.\n */\n\n\nfunction readFile(file, options, $refs) {\n  return new Promise((resolve, reject) => {\n    // console.log('Reading %s', file.url);\n    // Find the resolvers that can read this file\n    let resolvers = plugins.all(options.resolve);\n    resolvers = plugins.filter(resolvers, \"canRead\", file); // Run the resolvers, in order, until one of them succeeds\n\n    plugins.sort(resolvers);\n    plugins.run(resolvers, \"read\", file, $refs).then(resolve, onError);\n\n    function onError(err) {\n      // Throw the original error, if it's one of our own (user-friendly) errors.\n      // Otherwise, throw a generic, friendly error.\n      if (err && !(err instanceof SyntaxError)) {\n        reject(err);\n      } else {\n        reject(ono.syntax(`Unable to resolve $ref pointer \"${file.url}\"`));\n      }\n    }\n  });\n}\n/**\n * Parses the given file's contents, using the configured parser plugins.\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents and the parser that was used.\n */\n\n\nfunction parseFile(file, options, $refs) {\n  return new Promise((resolve, reject) => {\n    // console.log('Parsing %s', file.url);\n    // Find the parsers that can read this file type.\n    // If none of the parsers are an exact match for this file, then we'll try ALL of them.\n    // This handles situations where the file IS a supported type, just with an unknown extension.\n    let allParsers = plugins.all(options.parse);\n    let filteredParsers = plugins.filter(allParsers, \"canParse\", file);\n    let parsers = filteredParsers.length > 0 ? filteredParsers : allParsers; // Run the parsers, in order, until one of them succeeds\n\n    plugins.sort(parsers);\n    plugins.run(parsers, \"parse\", file, $refs).then(onParsed, onError);\n\n    function onParsed(parser) {\n      if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {\n        reject(ono.syntax(`Error parsing \"${file.url}\" as ${parser.plugin.name}. \\nParsed value is empty`));\n      } else {\n        resolve(parser);\n      }\n    }\n\n    function onError(err) {\n      if (err) {\n        err = err instanceof Error ? err : new Error(err);\n        reject(ono.syntax(err, `Error parsing ${file.url}`));\n      } else {\n        reject(ono.syntax(`Unable to parse ${file.url}`));\n      }\n    }\n  });\n}\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param {*} value\n * @returns {boolean}\n */\n\n\nfunction isEmpty(value) {\n  return value === undefined || typeof value === \"object\" && Object.keys(value).length === 0 || typeof value === \"string\" && value.trim().length === 0 || Buffer.isBuffer(value) && value.length === 0;\n}","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@apidevtools/swagger-parser/node_modules/@apidevtools/json-schema-ref-parser/lib/parse.js"],"names":["ono","require","url","plugins","module","exports","parse","path","$refs","options","stripHash","$ref","_add","file","extension","getExtension","resolver","readFile","pathType","plugin","name","data","result","parser","parseFile","value","e","Promise","reject","resolve","resolvers","all","filter","sort","run","then","onError","err","SyntaxError","syntax","allParsers","filteredParsers","parsers","length","onParsed","allowEmpty","isEmpty","Error","undefined","Object","keys","trim","Buffer","isBuffer"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst { ono } = require(\"@jsdevtools/ono\");\nconst url = require(\"./util/url\");\nconst plugins = require(\"./util/plugins\");\n\nmodule.exports = parse;\n\n/**\n * Reads and parses the specified file path or URL.\n *\n * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.\n */\nasync function parse (path, $refs, options) {\n  try {\n    // Remove the URL fragment, if any\n    path = url.stripHash(path);\n\n    // Add a new $Ref for this file, even though we don't have the value yet.\n    // This ensures that we don't simultaneously read & parse the same file multiple times\n    let $ref = $refs._add(path);\n\n    // This \"file object\" will be passed to all resolvers and parsers.\n    let file = {\n      url: path,\n      extension: url.getExtension(path),\n    };\n\n    // Read the file and then parse the data\n    const resolver = await readFile(file, options, $refs);\n    $ref.pathType = resolver.plugin.name;\n    file.data = resolver.result;\n\n    const parser = await parseFile(file, options, $refs);\n    $ref.value = parser.result;\n\n    return parser.result;\n  }\n  catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the raw file contents and the resolver that was used.\n */\nfunction readFile (file, options, $refs) {\n  return new Promise(((resolve, reject) => {\n    // console.log('Reading %s', file.url);\n\n    // Find the resolvers that can read this file\n    let resolvers = plugins.all(options.resolve);\n    resolvers = plugins.filter(resolvers, \"canRead\", file);\n\n    // Run the resolvers, in order, until one of them succeeds\n    plugins.sort(resolvers);\n    plugins.run(resolvers, \"read\", file, $refs)\n      .then(resolve, onError);\n\n    function onError (err) {\n      // Throw the original error, if it's one of our own (user-friendly) errors.\n      // Otherwise, throw a generic, friendly error.\n      if (err && !(err instanceof SyntaxError)) {\n        reject(err);\n      }\n      else {\n        reject(ono.syntax(`Unable to resolve $ref pointer \"${file.url}\"`));\n      }\n    }\n  }));\n}\n\n/**\n * Parses the given file's contents, using the configured parser plugins.\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents and the parser that was used.\n */\nfunction parseFile (file, options, $refs) {\n  return new Promise(((resolve, reject) => {\n    // console.log('Parsing %s', file.url);\n\n    // Find the parsers that can read this file type.\n    // If none of the parsers are an exact match for this file, then we'll try ALL of them.\n    // This handles situations where the file IS a supported type, just with an unknown extension.\n    let allParsers = plugins.all(options.parse);\n    let filteredParsers = plugins.filter(allParsers, \"canParse\", file);\n    let parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;\n\n    // Run the parsers, in order, until one of them succeeds\n    plugins.sort(parsers);\n    plugins.run(parsers, \"parse\", file, $refs)\n      .then(onParsed, onError);\n\n    function onParsed (parser) {\n      if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {\n        reject(ono.syntax(`Error parsing \"${file.url}\" as ${parser.plugin.name}. \\nParsed value is empty`));\n      }\n      else {\n        resolve(parser);\n      }\n    }\n\n    function onError (err) {\n      if (err) {\n        err = err instanceof Error ? err : new Error(err);\n        reject(ono.syntax(err, `Error parsing ${file.url}`));\n      }\n      else {\n        reject(ono.syntax(`Unable to parse ${file.url}`));\n      }\n    }\n  }));\n}\n\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param {*} value\n * @returns {boolean}\n */\nfunction isEmpty (value) {\n  return value === undefined ||\n    (typeof value === \"object\" && Object.keys(value).length === 0) ||\n    (typeof value === \"string\" && value.trim().length === 0) ||\n    (Buffer.isBuffer(value) && value.length === 0);\n}\n"]},"metadata":{},"sourceType":"script"}