{"ast":null,"code":"\"use strict\";\n\nmodule.exports = $Ref;\n\nconst Pointer = require(\"./pointer\");\n\nconst {\n  JSONParserError,\n  JSONParserErrorGroup,\n  ParserError,\n  MissingPointerError,\n  ResolverError,\n  isHandledError\n} = require(\"./util/errors\");\n\nconst {\n  safePointerToPath\n} = require(\"./util/url\");\n/**\n * This class represents a single JSON reference and its resolved value.\n *\n * @constructor\n */\n\n\nfunction $Ref() {\n  /**\n   * The file path or URL of the referenced file.\n   * This path is relative to the path of the main JSON schema file.\n   *\n   * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.\n   * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get\n   * specific JSON pointers within the file.\n   *\n   * @type {string}\n   */\n  this.path = undefined;\n  /**\n   * The resolved value of the JSON reference.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   * @type {?*}\n   */\n\n  this.value = undefined;\n  /**\n   * The {@link $Refs} object that contains this {@link $Ref} object.\n   * @type {$Refs}\n   */\n\n  this.$refs = undefined;\n  /**\n   * Indicates the type of {@link $Ref#path} (e.g. \"file\", \"http\", etc.)\n   * @type {?string}\n   */\n\n  this.pathType = undefined;\n  /**\n   * List of all errors. Undefined if no errors.\n   * @type {Array<JSONParserError | ResolverError | ParserError | MissingPointerError>}\n   */\n\n  this.errors = undefined;\n}\n/**\n * Pushes an error to errors array.\n *\n * @param {Array<JSONParserError | JSONParserErrorGroup>} error - The error to be pushed\n * @returns {void}\n */\n\n\n$Ref.prototype.addError = function (err) {\n  if (this.errors === undefined) {\n    this.errors = [];\n  }\n\n  if (Array.isArray(err.errors)) {\n    this.errors.push(...err.errors);\n  } else {\n    this.errors.push(err);\n  }\n};\n/**\n * Determines whether the given JSON reference exists within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n\n\n$Ref.prototype.exists = function (path, options) {\n  try {\n    this.resolve(path, options);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n/**\n * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {*} - Returns the resolved value\n */\n\n\n$Ref.prototype.get = function (path, options) {\n  return this.resolve(path, options).value;\n};\n/**\n * Resolves the given JSON reference within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @param {string} friendlyPath - The original user-specified path (used for error messages)\n*  @param {string} pathFromRoot - The path of `obj` from the schema root\n * @returns {Pointer}\n */\n\n\n$Ref.prototype.resolve = function (path, options, friendlyPath, pathFromRoot) {\n  let pointer = new Pointer(this, path, friendlyPath);\n\n  try {\n    return pointer.resolve(this.value, options);\n  } catch (err) {\n    if (!options || !options.continueOnError || !isHandledError(err)) {\n      throw err;\n    }\n\n    err.path = safePointerToPath(pathFromRoot);\n    this.addError(err);\n    return null;\n  }\n};\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The full path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */\n\n\n$Ref.prototype.set = function (path, value) {\n  let pointer = new Pointer(this, path);\n  this.value = pointer.set(this.value, value);\n};\n/**\n * Determines whether the given value is a JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n\n\n$Ref.is$Ref = function (value) {\n  return value && typeof value === \"object\" && typeof value.$ref === \"string\" && value.$ref.length > 0;\n};\n/**\n * Determines whether the given value is an external JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n\n\n$Ref.isExternal$Ref = function (value) {\n  return $Ref.is$Ref(value) && value.$ref[0] !== \"#\";\n};\n/**\n * Determines whether the given value is a JSON reference, and whether it is allowed by the options.\n * For example, if it references an external file, then options.resolve.external must be true.\n *\n * @param {*} value - The value to inspect\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n\n\n$Ref.isAllowed$Ref = function (value, options) {\n  if ($Ref.is$Ref(value)) {\n    if (value.$ref.substr(0, 2) === \"#/\" || value.$ref === \"#\") {\n      // It's a JSON Pointer reference, which is always allowed\n      return true;\n    } else if (value.$ref[0] !== \"#\" && (!options || options.resolve.external)) {\n      // It's an external reference, which is allowed by the options\n      return true;\n    }\n  }\n};\n/**\n * Determines whether the given value is a JSON reference that \"extends\" its resolved value.\n * That is, it has extra properties (in addition to \"$ref\"), so rather than simply pointing to\n * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved\n * value, plus the extra properties.\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  In this example, \"employee\" is an extended $ref, since it extends \"person\" with an additional\n *  property (salary).  The result is a NEW value that looks like this:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n\n\n$Ref.isExtended$Ref = function (value) {\n  return $Ref.is$Ref(value) && Object.keys(value).length > 1;\n};\n/**\n * Returns the resolved value of a JSON Reference.\n * If necessary, the resolved value is merged with the JSON Reference to create a new object\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  When \"person\" and \"employee\" are merged, you end up with the following object:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {object} $ref - The JSON reference object (the one with the \"$ref\" property)\n * @param {*} resolvedValue - The resolved value, which can be any type\n * @returns {*} - Returns the dereferenced value\n */\n\n\n$Ref.dereference = function ($ref, resolvedValue) {\n  if (resolvedValue && typeof resolvedValue === \"object\" && $Ref.isExtended$Ref($ref)) {\n    let merged = {};\n\n    for (let key of Object.keys($ref)) {\n      if (key !== \"$ref\") {\n        merged[key] = $ref[key];\n      }\n    }\n\n    for (let key of Object.keys(resolvedValue)) {\n      if (!(key in merged)) {\n        merged[key] = resolvedValue[key];\n      }\n    }\n\n    return merged;\n  } else {\n    // Completely replace the original reference with the resolved value\n    return resolvedValue;\n  }\n};","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@apidevtools/json-schema-ref-parser/lib/ref.js"],"names":["module","exports","$Ref","Pointer","require","JSONParserError","JSONParserErrorGroup","ParserError","MissingPointerError","ResolverError","isHandledError","safePointerToPath","path","undefined","value","$refs","pathType","errors","prototype","addError","err","Array","isArray","push","exists","options","resolve","e","get","friendlyPath","pathFromRoot","pointer","continueOnError","set","is$Ref","$ref","length","isExternal$Ref","isAllowed$Ref","substr","external","isExtended$Ref","Object","keys","dereference","resolvedValue","merged","key"],"mappings":"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","sourcesContent":["\"use strict\";\n\nmodule.exports = $Ref;\n\nconst Pointer = require(\"./pointer\");\nconst { JSONParserError, JSONParserErrorGroup, ParserError, MissingPointerError, ResolverError, isHandledError } = require(\"./util/errors\");\nconst { safePointerToPath } = require(\"./util/url\");\n\n/**\n * This class represents a single JSON reference and its resolved value.\n *\n * @constructor\n */\nfunction $Ref () {\n  /**\n   * The file path or URL of the referenced file.\n   * This path is relative to the path of the main JSON schema file.\n   *\n   * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.\n   * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get\n   * specific JSON pointers within the file.\n   *\n   * @type {string}\n   */\n  this.path = undefined;\n\n  /**\n   * The resolved value of the JSON reference.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   * @type {?*}\n   */\n  this.value = undefined;\n\n  /**\n   * The {@link $Refs} object that contains this {@link $Ref} object.\n   * @type {$Refs}\n   */\n  this.$refs = undefined;\n\n  /**\n   * Indicates the type of {@link $Ref#path} (e.g. \"file\", \"http\", etc.)\n   * @type {?string}\n   */\n  this.pathType = undefined;\n\n  /**\n   * List of all errors. Undefined if no errors.\n   * @type {Array<JSONParserError | ResolverError | ParserError | MissingPointerError>}\n   */\n  this.errors = undefined;\n}\n\n/**\n * Pushes an error to errors array.\n *\n * @param {Array<JSONParserError | JSONParserErrorGroup>} error - The error to be pushed\n * @returns {void}\n */\n$Ref.prototype.addError = function (err) {\n  if (this.errors === undefined) {\n    this.errors = [];\n  }\n\n  if (Array.isArray(err.errors)) {\n    this.errors.push(...err.errors);\n  }\n  else {\n    this.errors.push(err);\n  }\n};\n\n\n/**\n * Determines whether the given JSON reference exists within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n$Ref.prototype.exists = function (path, options) {\n  try {\n    this.resolve(path, options);\n    return true;\n  }\n  catch (e) {\n    return false;\n  }\n};\n\n/**\n * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {*} - Returns the resolved value\n */\n$Ref.prototype.get = function (path, options) {\n  return this.resolve(path, options).value;\n};\n\n/**\n * Resolves the given JSON reference within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @param {string} friendlyPath - The original user-specified path (used for error messages)\n*  @param {string} pathFromRoot - The path of `obj` from the schema root\n * @returns {Pointer}\n */\n$Ref.prototype.resolve = function (path, options, friendlyPath, pathFromRoot) {\n  let pointer = new Pointer(this, path, friendlyPath);\n  try {\n    return pointer.resolve(this.value, options);\n  }\n  catch (err) {\n    if (!options || !options.continueOnError || !isHandledError(err)) {\n      throw err;\n    }\n\n    err.path = safePointerToPath(pathFromRoot);\n    this.addError(err);\n    return null;\n  }\n};\n\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The full path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */\n$Ref.prototype.set = function (path, value) {\n  let pointer = new Pointer(this, path);\n  this.value = pointer.set(this.value, value);\n};\n\n/**\n * Determines whether the given value is a JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.is$Ref = function (value) {\n  return value && typeof value === \"object\" && typeof value.$ref === \"string\" && value.$ref.length > 0;\n};\n\n/**\n * Determines whether the given value is an external JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.isExternal$Ref = function (value) {\n  return $Ref.is$Ref(value) && value.$ref[0] !== \"#\";\n};\n\n/**\n * Determines whether the given value is a JSON reference, and whether it is allowed by the options.\n * For example, if it references an external file, then options.resolve.external must be true.\n *\n * @param {*} value - The value to inspect\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n$Ref.isAllowed$Ref = function (value, options) {\n  if ($Ref.is$Ref(value)) {\n    if (value.$ref.substr(0, 2) === \"#/\" || value.$ref === \"#\") {\n      // It's a JSON Pointer reference, which is always allowed\n      return true;\n    }\n    else if (value.$ref[0] !== \"#\" && (!options || options.resolve.external)) {\n      // It's an external reference, which is allowed by the options\n      return true;\n    }\n  }\n};\n\n/**\n * Determines whether the given value is a JSON reference that \"extends\" its resolved value.\n * That is, it has extra properties (in addition to \"$ref\"), so rather than simply pointing to\n * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved\n * value, plus the extra properties.\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  In this example, \"employee\" is an extended $ref, since it extends \"person\" with an additional\n *  property (salary).  The result is a NEW value that looks like this:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.isExtended$Ref = function (value) {\n  return $Ref.is$Ref(value) && Object.keys(value).length > 1;\n};\n\n/**\n * Returns the resolved value of a JSON Reference.\n * If necessary, the resolved value is merged with the JSON Reference to create a new object\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  When \"person\" and \"employee\" are merged, you end up with the following object:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {object} $ref - The JSON reference object (the one with the \"$ref\" property)\n * @param {*} resolvedValue - The resolved value, which can be any type\n * @returns {*} - Returns the dereferenced value\n */\n$Ref.dereference = function ($ref, resolvedValue) {\n  if (resolvedValue && typeof resolvedValue === \"object\" && $Ref.isExtended$Ref($ref)) {\n    let merged = {};\n    for (let key of Object.keys($ref)) {\n      if (key !== \"$ref\") {\n        merged[key] = $ref[key];\n      }\n    }\n\n    for (let key of Object.keys(resolvedValue)) {\n      if (!(key in merged)) {\n        merged[key] = resolvedValue[key];\n      }\n    }\n\n    return merged;\n  }\n  else {\n    // Completely replace the original reference with the resolved value\n    return resolvedValue;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}