{"ast":null,"code":"const fetch = require('node-fetch');\n\nconst SwaggerParser = require('@apidevtools/swagger-parser');\n\nconst $RefParser = require('@apidevtools/json-schema-ref-parser');\n\nconst yaml = require('js-yaml');\n\nconst crypto = require('crypto');\n\nconst findCacheDir = require('find-cache-dir');\n\nconst pkg = require('../package.json');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst cacheDir = findCacheDir({\n  name: pkg.name,\n  thunk: true\n});\n\nclass SdkCache {\n  constructor(uri) {\n    this.uri = uri;\n    this.uriHash = SdkCache.getCacheHash(this.uri);\n    this.dir = cacheDir();\n    this.cacheStore = cacheDir('cache.json');\n    this.specsCache = cacheDir('specs'); // This should default to false so we have awareness if we've looked at the cache yet.\n\n    this.cached = false;\n  }\n\n  static getCacheHash(file) {\n    let data = file;\n\n    if (typeof file === 'object') {\n      // Under certain unit testing circumstances, we might be supplying the class with a raw JSON object so we'll need\n      // to convert it to a string in order to hand it off to the crypto module.\n      data = JSON.stringify(file);\n    }\n\n    return crypto.createHash('md5').update(data).digest('hex');\n  }\n\n  isCached() {\n    const cache = this.getCache();\n    return cache && this.uriHash in cache;\n  }\n\n  getCache() {\n    if (typeof this.cached === 'object') {\n      return this.cached;\n    }\n\n    this.cached = {};\n\n    if (fs.existsSync(this.cacheStore)) {\n      this.cached = JSON.parse(fs.readFileSync(this.cacheStore, 'utf8'));\n    }\n\n    return this.cached;\n  }\n\n  get() {\n    // If the class was supplied a raw object, just go ahead and bypass the caching system and return that.\n    if (typeof this.uri === 'object') {\n      return this.uri;\n    }\n\n    if (!this.isCached()) {\n      throw new Error(`${this.uri} has not been cached yet and must do so before being retrieved.`);\n    }\n\n    const cache = this.getCache();\n    return JSON.parse(fs.readFileSync(cache[this.uriHash].path, 'utf8'));\n  }\n\n  async load() {\n    // If the class was supplied a raw object, just go ahead and bypass the caching system and return that.\n    if (typeof this.uri === 'object') {\n      return this.uri;\n    }\n\n    try {\n      const url = new URL(this.uri);\n      this.uri = url.href;\n      return this.saveUrl();\n    } catch (err) {\n      // Support relative paths by resolving them against the cwd.\n      this.uri = path.resolve(process.cwd(), this.uri);\n\n      if (!fs.existsSync(this.uri)) {\n        throw new Error(`Sorry, we were unable to load that OpenAPI definition. Please either supply a URL or a path on your filesystem.`);\n      }\n\n      return this.saveFile();\n    }\n  }\n\n  save(json) {\n    const self = this;\n\n    if (json.swagger) {\n      throw new Error('Sorry, this module only supports OpenAPI definitions.');\n    }\n\n    return new Promise(resolve => {\n      return resolve(json);\n    }).then(res => {\n      return SwaggerParser.validate(res).catch(err => {\n        if (/is not a valid openapi api definition/i.test(err.message)) {\n          throw new Error(\"Sorry, that doesn't look like a valid OpenAPI definition.\");\n        }\n\n        throw err;\n      });\n    }).then(res => {\n      return $RefParser.dereference(res);\n    }).then(async spec => {\n      if (!fs.existsSync(self.dir)) {\n        fs.mkdirSync(self.dir, {\n          recursive: true\n        });\n      }\n\n      if (!fs.existsSync(self.specsCache)) {\n        fs.mkdirSync(self.specsCache, {\n          recursive: true\n        });\n      }\n\n      const cache = self.getCache();\n\n      if (!(this.uriHash in cache)) {\n        const saved = JSON.stringify(spec, null, 2);\n        const jsonHash = crypto.createHash('md5').update(saved).digest('hex');\n        cache[this.uriHash] = {\n          path: cacheDir('specs', `${jsonHash}.json`),\n          original: this.uri,\n          title: 'title' in spec.info ? spec.info.title : undefined,\n          version: 'version' in spec.info ? spec.info.version : undefined\n        };\n        fs.writeFileSync(cache[this.uriHash].path, saved);\n        fs.writeFileSync(self.cacheStore, JSON.stringify(cache, null, 2));\n        self.cache = cache;\n      }\n\n      return spec;\n    });\n  }\n\n  saveUrl() {\n    return fetch(this.uri).then(res => {\n      if (!res.ok) {\n        throw new Error(`Unable to retrieve URL. Reason: ${res.statusText}`);\n      }\n\n      if (res.headers.get('content-type') === 'application/yaml' || /\\.(yaml|yml)/.test(this.uri)) {\n        return res.text().then(text => {\n          return yaml.safeLoad(text);\n        });\n      }\n\n      return res.json();\n    }).then(json => this.save(json));\n  }\n\n  saveFile() {\n    return new Promise(resolve => {\n      return resolve(fs.readFileSync(this.uri, 'utf8'));\n    }).then(res => {\n      if (/\\.(yaml|yml)/.test(this.uri)) {\n        return yaml.safeLoad(res);\n      }\n\n      return JSON.parse(res);\n    }).then(json => this.save(json));\n  }\n\n}\n\nmodule.exports = SdkCache;","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/api/src/cache.js"],"names":["fetch","require","SwaggerParser","$RefParser","yaml","crypto","findCacheDir","pkg","fs","path","cacheDir","name","thunk","SdkCache","constructor","uri","uriHash","getCacheHash","dir","cacheStore","specsCache","cached","file","data","JSON","stringify","createHash","update","digest","isCached","cache","getCache","existsSync","parse","readFileSync","get","Error","load","url","URL","href","saveUrl","err","resolve","process","cwd","saveFile","save","json","self","swagger","Promise","then","res","validate","catch","test","message","dereference","spec","mkdirSync","recursive","saved","jsonHash","original","title","info","undefined","version","writeFileSync","ok","statusText","headers","text","safeLoad","module","exports"],"mappings":"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","sourcesContent":["const fetch = require('node-fetch');\nconst SwaggerParser = require('@apidevtools/swagger-parser');\nconst $RefParser = require('@apidevtools/json-schema-ref-parser');\nconst yaml = require('js-yaml');\nconst crypto = require('crypto');\nconst findCacheDir = require('find-cache-dir');\nconst pkg = require('../package.json');\nconst fs = require('fs');\nconst path = require('path');\n\nconst cacheDir = findCacheDir({ name: pkg.name, thunk: true });\n\nclass SdkCache {\n  constructor(uri) {\n    this.uri = uri;\n    this.uriHash = SdkCache.getCacheHash(this.uri);\n    this.dir = cacheDir();\n    this.cacheStore = cacheDir('cache.json');\n    this.specsCache = cacheDir('specs');\n\n    // This should default to false so we have awareness if we've looked at the cache yet.\n    this.cached = false;\n  }\n\n  static getCacheHash(file) {\n    let data = file;\n    if (typeof file === 'object') {\n      // Under certain unit testing circumstances, we might be supplying the class with a raw JSON object so we'll need\n      // to convert it to a string in order to hand it off to the crypto module.\n      data = JSON.stringify(file);\n    }\n\n    return crypto.createHash('md5').update(data).digest('hex');\n  }\n\n  isCached() {\n    const cache = this.getCache();\n    return cache && this.uriHash in cache;\n  }\n\n  getCache() {\n    if (typeof this.cached === 'object') {\n      return this.cached;\n    }\n\n    this.cached = {};\n\n    if (fs.existsSync(this.cacheStore)) {\n      this.cached = JSON.parse(fs.readFileSync(this.cacheStore, 'utf8'));\n    }\n\n    return this.cached;\n  }\n\n  get() {\n    // If the class was supplied a raw object, just go ahead and bypass the caching system and return that.\n    if (typeof this.uri === 'object') {\n      return this.uri;\n    }\n\n    if (!this.isCached()) {\n      throw new Error(`${this.uri} has not been cached yet and must do so before being retrieved.`);\n    }\n\n    const cache = this.getCache();\n    return JSON.parse(fs.readFileSync(cache[this.uriHash].path, 'utf8'));\n  }\n\n  async load() {\n    // If the class was supplied a raw object, just go ahead and bypass the caching system and return that.\n    if (typeof this.uri === 'object') {\n      return this.uri;\n    }\n\n    try {\n      const url = new URL(this.uri);\n      this.uri = url.href;\n\n      return this.saveUrl();\n    } catch (err) {\n      // Support relative paths by resolving them against the cwd.\n      this.uri = path.resolve(process.cwd(), this.uri);\n\n      if (!fs.existsSync(this.uri)) {\n        throw new Error(\n          `Sorry, we were unable to load that OpenAPI definition. Please either supply a URL or a path on your filesystem.`\n        );\n      }\n\n      return this.saveFile();\n    }\n  }\n\n  save(json) {\n    const self = this;\n\n    if (json.swagger) {\n      throw new Error('Sorry, this module only supports OpenAPI definitions.');\n    }\n\n    return new Promise(resolve => {\n      return resolve(json);\n    })\n      .then(res => {\n        return SwaggerParser.validate(res).catch(err => {\n          if (/is not a valid openapi api definition/i.test(err.message)) {\n            throw new Error(\"Sorry, that doesn't look like a valid OpenAPI definition.\");\n          }\n\n          throw err;\n        });\n      })\n      .then(res => {\n        return $RefParser.dereference(res);\n      })\n      .then(async spec => {\n        if (!fs.existsSync(self.dir)) {\n          fs.mkdirSync(self.dir, { recursive: true });\n        }\n\n        if (!fs.existsSync(self.specsCache)) {\n          fs.mkdirSync(self.specsCache, { recursive: true });\n        }\n\n        const cache = self.getCache();\n        if (!(this.uriHash in cache)) {\n          const saved = JSON.stringify(spec, null, 2);\n          const jsonHash = crypto.createHash('md5').update(saved).digest('hex');\n\n          cache[this.uriHash] = {\n            path: cacheDir('specs', `${jsonHash}.json`),\n            original: this.uri,\n            title: 'title' in spec.info ? spec.info.title : undefined,\n            version: 'version' in spec.info ? spec.info.version : undefined,\n          };\n\n          fs.writeFileSync(cache[this.uriHash].path, saved);\n          fs.writeFileSync(self.cacheStore, JSON.stringify(cache, null, 2));\n\n          self.cache = cache;\n        }\n\n        return spec;\n      });\n  }\n\n  saveUrl() {\n    return fetch(this.uri)\n      .then(res => {\n        if (!res.ok) {\n          throw new Error(`Unable to retrieve URL. Reason: ${res.statusText}`);\n        }\n\n        if (res.headers.get('content-type') === 'application/yaml' || /\\.(yaml|yml)/.test(this.uri)) {\n          return res.text().then(text => {\n            return yaml.safeLoad(text);\n          });\n        }\n\n        return res.json();\n      })\n      .then(json => this.save(json));\n  }\n\n  saveFile() {\n    return new Promise(resolve => {\n      return resolve(fs.readFileSync(this.uri, 'utf8'));\n    })\n      .then(res => {\n        if (/\\.(yaml|yml)/.test(this.uri)) {\n          return yaml.safeLoad(res);\n        }\n\n        return JSON.parse(res);\n      })\n      .then(json => this.save(json));\n  }\n}\n\nmodule.exports = SdkCache;\n"]},"metadata":{},"sourceType":"script"}