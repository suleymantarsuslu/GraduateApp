{"ast":null,"code":"\"use strict\";\n\nvar reducible = require(\"reducible/reducible\");\n\nvar reduce = require(\"reducible/reduce\");\n\nvar end = require(\"reducible/end\");\n\nfunction take(source, n) {\n  /**\n  Returns sequence of first `n` items of the given `source`. If `source`\n  contains less items than `n` then that's how  much items return sequence\n  will contain.\n   ## Example\n   print(take([ 1, 2, 3, 4, 5 ], 2))   // => < 1 2 >\n  print(take([ 1, 2, 3 ], 5))         // => < 1 2 3 >\n  **/\n  // If take `0` then optimize by returning an empty if less then `0`\n  // then just return `source` back.\n  if (n === 0) return void 0;\n  if (n < 0) return source;\n  return reducible(function reduceTake(next, initial) {\n    // Capture `n` into count, since modifying `n` directly will have side\n    // effects on subsequent calls.\n    var count = n;\n    reduce(source, function reduceTakeSource(value, result) {\n      count = count - 1;\n      result = next(value, result); // If we have not taken `n` items yet just pass result back. Otherwise\n      // pass `end` of stream to a consumer. Note `reducible` will return\n      // `reduced(result)` back signaling source it should stop.\n\n      return count > 0 ? result : next(end);\n    }, initial);\n  });\n}\n\nmodule.exports = take;","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/reducers/take.js"],"names":["reducible","require","reduce","end","take","source","n","reduceTake","next","initial","count","reduceTakeSource","value","result","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,qBAAD,CAAvB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,kBAAD,CAApB;;AACA,IAAIE,GAAG,GAAGF,OAAO,CAAC,eAAD,CAAjB;;AAEA,SAASG,IAAT,CAAcC,MAAd,EAAsBC,CAAtB,EAAyB;AACvB;;;;;;;;AAWA;AACA;AACA,MAAIA,CAAC,KAAK,CAAV,EAAa,OAAO,KAAK,CAAZ;AACb,MAAIA,CAAC,GAAG,CAAR,EAAW,OAAOD,MAAP;AACX,SAAOL,SAAS,CAAC,SAASO,UAAT,CAAoBC,IAApB,EAA0BC,OAA1B,EAAmC;AAClD;AACA;AACA,QAAIC,KAAK,GAAGJ,CAAZ;AACAJ,IAAAA,MAAM,CAACG,MAAD,EAAS,SAASM,gBAAT,CAA0BC,KAA1B,EAAiCC,MAAjC,EAAyC;AACtDH,MAAAA,KAAK,GAAGA,KAAK,GAAG,CAAhB;AACAG,MAAAA,MAAM,GAAGL,IAAI,CAACI,KAAD,EAAQC,MAAR,CAAb,CAFsD,CAItD;AACA;AACA;;AACA,aAAOH,KAAK,GAAG,CAAR,GAAYG,MAAZ,GACAL,IAAI,CAACL,GAAD,CADX;AAED,KATK,EASHM,OATG,CAAN;AAUD,GAde,CAAhB;AAeD;;AAEDK,MAAM,CAACC,OAAP,GAAiBX,IAAjB","sourcesContent":["\"use strict\";\n\nvar reducible = require(\"reducible/reducible\")\nvar reduce = require(\"reducible/reduce\")\nvar end = require(\"reducible/end\")\n\nfunction take(source, n) {\n  /**\n  Returns sequence of first `n` items of the given `source`. If `source`\n  contains less items than `n` then that's how  much items return sequence\n  will contain.\n\n  ## Example\n\n  print(take([ 1, 2, 3, 4, 5 ], 2))   // => < 1 2 >\n  print(take([ 1, 2, 3 ], 5))         // => < 1 2 3 >\n  **/\n\n  // If take `0` then optimize by returning an empty if less then `0`\n  // then just return `source` back.\n  if (n === 0) return void(0)\n  if (n < 0) return source\n  return reducible(function reduceTake(next, initial) {\n    // Capture `n` into count, since modifying `n` directly will have side\n    // effects on subsequent calls.\n    var count = n\n    reduce(source, function reduceTakeSource(value, result) {\n      count = count - 1\n      result = next(value, result)\n\n      // If we have not taken `n` items yet just pass result back. Otherwise\n      // pass `end` of stream to a consumer. Note `reducible` will return\n      // `reduced(result)` back signaling source it should stop.\n      return count > 0 ? result :\n             next(end)\n    }, initial)\n  })\n}\n\nmodule.exports = take\n"]},"metadata":{},"sourceType":"script"}