{"ast":null,"code":"\"use strict\";\n\nvar reduce = require(\"reducible/reduce\");\n\nvar reducible = require(\"reducible/reducible\");\n\nvar end = require(\"reducible/end\");\n\nvar isError = require(\"reducible/is-error\");\n\nfunction merge(source) {\n  /**\n  Merges given collection of collections to a collection with items of\n  all nested collections. Note that items in the resulting collection\n  are ordered by the time rather then index, in other words if item from\n  the second nested collection is deliver earlier then the item\n  from first nested collection it will in appear earlier in the resulting\n  collection.\n   print(merge([ [1, 2], [3, 4] ]))  // => < 1 2 3 4 >\n  **/\n  return reducible(function accumulateMerged(next, initial) {\n    var state = initial;\n    var open = 1;\n\n    function forward(value) {\n      if (value === end) {\n        open = open - 1;\n        if (open === 0) return next(end);\n      } else {\n        state = next(value, state);\n      }\n\n      return state;\n    }\n\n    reduce(source, function accumulateMergeSource(nested) {\n      // If there is an error or end of `source` collection just pass it\n      // to `forward` it will take care of detecting weather it's error\n      // or `end`. In later case it will also figure out if it's `end` of\n      // result to and act appropriately.\n      if (nested === end) return forward(end);\n      if (isError(nested)) return forward(nested); // If `nested` item is not end nor error just `accumulate` it via\n      // `forward` that keeps track of all collections that are bing forwarded\n      // to it.\n\n      open = open + 1;\n      reduce(nested, forward, null);\n    }, initial);\n  });\n}\n\nmodule.exports = merge;","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/reducers/merge.js"],"names":["reduce","require","reducible","end","isError","merge","source","accumulateMerged","next","initial","state","open","forward","value","accumulateMergeSource","nested","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,kBAAD,CAApB;;AACA,IAAIC,SAAS,GAAGD,OAAO,CAAC,qBAAD,CAAvB;;AACA,IAAIE,GAAG,GAAGF,OAAO,CAAC,eAAD,CAAjB;;AACA,IAAIG,OAAO,GAAGH,OAAO,CAAC,oBAAD,CAArB;;AAEA,SAASI,KAAT,CAAeC,MAAf,EAAuB;AACrB;;;;;;;;;AAUA,SAAOJ,SAAS,CAAC,SAASK,gBAAT,CAA0BC,IAA1B,EAAgCC,OAAhC,EAAyC;AACxD,QAAIC,KAAK,GAAGD,OAAZ;AACA,QAAIE,IAAI,GAAG,CAAX;;AAEA,aAASC,OAAT,CAAiBC,KAAjB,EAAwB;AACtB,UAAIA,KAAK,KAAKV,GAAd,EAAmB;AACjBQ,QAAAA,IAAI,GAAGA,IAAI,GAAG,CAAd;AACA,YAAIA,IAAI,KAAK,CAAb,EAAgB,OAAOH,IAAI,CAACL,GAAD,CAAX;AACjB,OAHD,MAGO;AACLO,QAAAA,KAAK,GAAGF,IAAI,CAACK,KAAD,EAAQH,KAAR,CAAZ;AACD;;AACD,aAAOA,KAAP;AACD;;AAGDV,IAAAA,MAAM,CAACM,MAAD,EAAS,SAASQ,qBAAT,CAA+BC,MAA/B,EAAuC;AACpD;AACA;AACA;AACA;AACA,UAAIA,MAAM,KAAKZ,GAAf,EAAoB,OAAOS,OAAO,CAACT,GAAD,CAAd;AACpB,UAAIC,OAAO,CAACW,MAAD,CAAX,EAAqB,OAAOH,OAAO,CAACG,MAAD,CAAd,CAN+B,CAOpD;AACA;AACA;;AACAJ,MAAAA,IAAI,GAAGA,IAAI,GAAG,CAAd;AACAX,MAAAA,MAAM,CAACe,MAAD,EAASH,OAAT,EAAkB,IAAlB,CAAN;AACD,KAZK,EAYHH,OAZG,CAAN;AAaD,GA5Be,CAAhB;AA6BD;;AAEDO,MAAM,CAACC,OAAP,GAAiBZ,KAAjB","sourcesContent":["\"use strict\";\n\nvar reduce = require(\"reducible/reduce\")\nvar reducible = require(\"reducible/reducible\")\nvar end = require(\"reducible/end\")\nvar isError = require(\"reducible/is-error\")\n\nfunction merge(source) {\n  /**\n  Merges given collection of collections to a collection with items of\n  all nested collections. Note that items in the resulting collection\n  are ordered by the time rather then index, in other words if item from\n  the second nested collection is deliver earlier then the item\n  from first nested collection it will in appear earlier in the resulting\n  collection.\n\n  print(merge([ [1, 2], [3, 4] ]))  // => < 1 2 3 4 >\n  **/\n  return reducible(function accumulateMerged(next, initial) {\n    var state = initial\n    var open = 1\n\n    function forward(value) {\n      if (value === end) {\n        open = open - 1\n        if (open === 0) return next(end)\n      } else {\n        state = next(value, state)\n      }\n      return state\n    }\n\n\n    reduce(source, function accumulateMergeSource(nested) {\n      // If there is an error or end of `source` collection just pass it\n      // to `forward` it will take care of detecting weather it's error\n      // or `end`. In later case it will also figure out if it's `end` of\n      // result to and act appropriately.\n      if (nested === end) return forward(end)\n      if (isError(nested)) return forward(nested)\n      // If `nested` item is not end nor error just `accumulate` it via\n      // `forward` that keeps track of all collections that are bing forwarded\n      // to it.\n      open = open + 1\n      reduce(nested, forward, null)\n    }, initial)\n  })\n}\n\nmodule.exports = merge\n"]},"metadata":{},"sourceType":"script"}