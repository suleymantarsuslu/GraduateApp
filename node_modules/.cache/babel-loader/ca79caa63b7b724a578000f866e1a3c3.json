{"ast":null,"code":"\"use strict\";\n\nvar reduce = require(\"reducible/reduce\");\n\nvar reduced = require(\"reducible/reduced\");\n\nvar isReduced = require(\"reducible/is-reduced\");\n\nvar end = require(\"reducible/end\");\n\nvar input = \"input@\" + module.id;\nvar consumers = \"consumers@\" + module.id;\nvar isArray = Array.isArray;\n\nfunction Hub(source) {\n  this[input] = source;\n  this[consumers] = [];\n}\n\nreduce.define(Hub, function reduceHub(hub, next, initial) {\n  // Enqueue new consumer into consumers array so that new\n  // values will be delegated to it.\n  hub[consumers].push({\n    next: next,\n    state: initial\n  }); // If source is not in the process of consumption than\n  // start it up.\n\n  if (!isOpen(hub)) open(hub);\n});\n\nfunction drain(consumers) {\n  while (consumers.length) {\n    var count = consumers.length;\n    var index = 0;\n\n    while (index < count) {\n      var consumer = consumers[index];\n      consumer.next(end, consumer.state);\n      index = index + 1;\n    }\n\n    consumers.splice(0, count);\n  }\n}\n\nfunction dispatch(consumers, value) {\n  var count = consumers.length;\n  var index = 0;\n\n  while (index < count) {\n    var consumer = consumers[index];\n    var state = consumer.next(value, consumer.state); // If consumer has finished accumulation remove it from the consumers\n    // list. And dispatch end of stream on it (maybe that should not be\n    // necessary).\n\n    if (isReduced(state)) {\n      consumers.splice(index, 1);\n      consumer.next(end, state.value); // If consumer is removed than we decrease count as consumers array\n      // will contain less elements (unless of course more elements were\n      // added but we would like to ignore those).\n\n      count = count - 1;\n    } else {\n      consumer.state = state;\n      index = index + 1;\n    }\n  }\n}\n\nfunction open(hub) {\n  var source = hub[input];\n  var reducers = hub[consumers];\n  hub[input] = null; // mark hub as open\n\n  reduce(source, function distribute(value) {\n    // If it's end of the source we close all the reducers including\n    // ones that subscribe as side effect.\n    if (value === end) drain(reducers); // otherwise we dispatch value to all the registered reducers.\n    else dispatch(reducers, value); // reducers will be empty if either source is drained or if all the\n    // reducers finished reductions. Either way we reset input back to\n    // source and return `reduced` marker to stop the reduction of\n    // source.\n\n    if (reducers.length === 0) {\n      hub[input] = source;\n      return reduced();\n    }\n  });\n}\n\nfunction isOpen(hub) {\n  return hub[input] === null;\n}\n\nfunction hub(source) {\n  /**\n  Take a reducible `source`, such as a `signal` and return a reducible that can\n  be consumed by many reducers.\n  **/\n  if (source === null) return null;\n  if (source === void 0) return null;\n  return new Hub(source);\n}\n\nhub.isOpen = isOpen;\nhub.type = Hub;\nmodule.exports = hub;","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/reducers/hub.js"],"names":["reduce","require","reduced","isReduced","end","input","module","id","consumers","isArray","Array","Hub","source","define","reduceHub","hub","next","initial","push","state","isOpen","open","drain","length","count","index","consumer","splice","dispatch","value","reducers","distribute","type","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar reduce = require(\"reducible/reduce\")\nvar reduced = require(\"reducible/reduced\")\nvar isReduced = require(\"reducible/is-reduced\")\nvar end = require(\"reducible/end\")\n\nvar input = \"input@\" + module.id\nvar consumers = \"consumers@\" + module.id\n\n\nvar isArray = Array.isArray\n\nfunction Hub(source) {\n  this[input] = source\n  this[consumers] = []\n}\n\nreduce.define(Hub, function reduceHub(hub, next, initial) {\n  // Enqueue new consumer into consumers array so that new\n  // values will be delegated to it.\n  hub[consumers].push({ next: next, state: initial })\n  // If source is not in the process of consumption than\n  // start it up.\n  if (!isOpen(hub)) open(hub)\n})\n\nfunction drain(consumers) {\n  while (consumers.length) {\n    var count = consumers.length\n    var index = 0\n    while (index < count) {\n      var consumer = consumers[index]\n      consumer.next(end, consumer.state)\n      index = index + 1\n    }\n    consumers.splice(0, count)\n  }\n}\n\nfunction dispatch(consumers, value) {\n  var count = consumers.length\n  var index = 0\n  while (index < count) {\n    var consumer = consumers[index]\n    var state = consumer.next(value, consumer.state)\n    // If consumer has finished accumulation remove it from the consumers\n    // list. And dispatch end of stream on it (maybe that should not be\n    // necessary).\n    if (isReduced(state)) {\n      consumers.splice(index, 1)\n      consumer.next(end, state.value)\n      // If consumer is removed than we decrease count as consumers array\n      // will contain less elements (unless of course more elements were\n      // added but we would like to ignore those).\n      count = count - 1\n    } else {\n      consumer.state = state\n      index = index + 1\n    }\n  }\n}\n\nfunction open(hub) {\n  var source = hub[input]\n  var reducers = hub[consumers]\n  hub[input] = null         // mark hub as open\n  reduce(source, function distribute(value) {\n    // If it's end of the source we close all the reducers including\n    // ones that subscribe as side effect.\n    if (value === end) drain(reducers)\n    // otherwise we dispatch value to all the registered reducers.\n    else dispatch(reducers, value)\n\n    // reducers will be empty if either source is drained or if all the\n    // reducers finished reductions. Either way we reset input back to\n    // source and return `reduced` marker to stop the reduction of\n    // source.\n    if (reducers.length === 0) {\n      hub[input] = source\n      return reduced()\n    }\n  })\n}\n\nfunction isOpen(hub) {\n  return hub[input] === null\n}\n\nfunction hub(source) {\n  /**\n  Take a reducible `source`, such as a `signal` and return a reducible that can\n  be consumed by many reducers.\n  **/\n  if (source === null) return null\n  if (source === void(0)) return null\n  return new Hub(source)\n}\nhub.isOpen = isOpen\nhub.type = Hub\n\nmodule.exports = hub\n"]},"metadata":{},"sourceType":"script"}