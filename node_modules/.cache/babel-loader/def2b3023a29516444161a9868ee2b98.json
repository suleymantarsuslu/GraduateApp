{"ast":null,"code":"\"use strict\";\n\nmodule.exports = $Ref;\n\nconst Pointer = require(\"./pointer\");\n/**\n * This class represents a single JSON reference and its resolved value.\n *\n * @constructor\n */\n\n\nfunction $Ref() {\n  /**\n   * The file path or URL of the referenced file.\n   * This path is relative to the path of the main JSON schema file.\n   *\n   * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.\n   * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get\n   * specific JSON pointers within the file.\n   *\n   * @type {string}\n   */\n  this.path = undefined;\n  /**\n   * The resolved value of the JSON reference.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   * @type {?*}\n   */\n\n  this.value = undefined;\n  /**\n   * The {@link $Refs} object that contains this {@link $Ref} object.\n   * @type {$Refs}\n   */\n\n  this.$refs = undefined;\n  /**\n   * Indicates the type of {@link $Ref#path} (e.g. \"file\", \"http\", etc.)\n   * @type {?string}\n   */\n\n  this.pathType = undefined;\n}\n/**\n * Determines whether the given JSON reference exists within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n\n\n$Ref.prototype.exists = function (path, options) {\n  try {\n    this.resolve(path, options);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n/**\n * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {*} - Returns the resolved value\n */\n\n\n$Ref.prototype.get = function (path, options) {\n  return this.resolve(path, options).value;\n};\n/**\n * Resolves the given JSON reference within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @param {string} [friendlyPath] - The original user-specified path (used for error messages)\n * @returns {Pointer}\n */\n\n\n$Ref.prototype.resolve = function (path, options, friendlyPath) {\n  let pointer = new Pointer(this, path, friendlyPath);\n  return pointer.resolve(this.value, options);\n};\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The full path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */\n\n\n$Ref.prototype.set = function (path, value) {\n  let pointer = new Pointer(this, path);\n  this.value = pointer.set(this.value, value);\n};\n/**\n * Determines whether the given value is a JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n\n\n$Ref.is$Ref = function (value) {\n  return value && typeof value === \"object\" && typeof value.$ref === \"string\" && value.$ref.length > 0;\n};\n/**\n * Determines whether the given value is an external JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n\n\n$Ref.isExternal$Ref = function (value) {\n  return $Ref.is$Ref(value) && value.$ref[0] !== \"#\";\n};\n/**\n * Determines whether the given value is a JSON reference, and whether it is allowed by the options.\n * For example, if it references an external file, then options.resolve.external must be true.\n *\n * @param {*} value - The value to inspect\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n\n\n$Ref.isAllowed$Ref = function (value, options) {\n  if ($Ref.is$Ref(value)) {\n    if (value.$ref.substr(0, 2) === \"#/\" || value.$ref === \"#\") {\n      // It's a JSON Pointer reference, which is always allowed\n      return true;\n    } else if (value.$ref[0] !== \"#\" && (!options || options.resolve.external)) {\n      // It's an external reference, which is allowed by the options\n      return true;\n    }\n  }\n};\n/**\n * Determines whether the given value is a JSON reference that \"extends\" its resolved value.\n * That is, it has extra properties (in addition to \"$ref\"), so rather than simply pointing to\n * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved\n * value, plus the extra properties.\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  In this example, \"employee\" is an extended $ref, since it extends \"person\" with an additional\n *  property (salary).  The result is a NEW value that looks like this:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n\n\n$Ref.isExtended$Ref = function (value) {\n  return $Ref.is$Ref(value) && Object.keys(value).length > 1;\n};\n/**\n * Returns the resolved value of a JSON Reference.\n * If necessary, the resolved value is merged with the JSON Reference to create a new object\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  When \"person\" and \"employee\" are merged, you end up with the following object:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {object} $ref - The JSON reference object (the one with the \"$ref\" property)\n * @param {*} resolvedValue - The resolved value, which can be any type\n * @returns {*} - Returns the dereferenced value\n */\n\n\n$Ref.dereference = function ($ref, resolvedValue) {\n  if (resolvedValue && typeof resolvedValue === \"object\" && $Ref.isExtended$Ref($ref)) {\n    let merged = {};\n\n    for (let key of Object.keys($ref)) {\n      if (key !== \"$ref\") {\n        merged[key] = $ref[key];\n      }\n    }\n\n    for (let key of Object.keys(resolvedValue)) {\n      if (!(key in merged)) {\n        merged[key] = resolvedValue[key];\n      }\n    }\n\n    return merged;\n  } else {\n    // Completely replace the original reference with the resolved value\n    return resolvedValue;\n  }\n};","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@apidevtools/swagger-parser/node_modules/@apidevtools/json-schema-ref-parser/lib/ref.js"],"names":["module","exports","$Ref","Pointer","require","path","undefined","value","$refs","pathType","prototype","exists","options","resolve","e","get","friendlyPath","pointer","set","is$Ref","$ref","length","isExternal$Ref","isAllowed$Ref","substr","external","isExtended$Ref","Object","keys","dereference","resolvedValue","merged","key"],"mappings":"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","sourcesContent":["\"use strict\";\n\nmodule.exports = $Ref;\n\nconst Pointer = require(\"./pointer\");\n\n/**\n * This class represents a single JSON reference and its resolved value.\n *\n * @constructor\n */\nfunction $Ref () {\n  /**\n   * The file path or URL of the referenced file.\n   * This path is relative to the path of the main JSON schema file.\n   *\n   * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.\n   * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get\n   * specific JSON pointers within the file.\n   *\n   * @type {string}\n   */\n  this.path = undefined;\n\n  /**\n   * The resolved value of the JSON reference.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   * @type {?*}\n   */\n  this.value = undefined;\n\n  /**\n   * The {@link $Refs} object that contains this {@link $Ref} object.\n   * @type {$Refs}\n   */\n  this.$refs = undefined;\n\n  /**\n   * Indicates the type of {@link $Ref#path} (e.g. \"file\", \"http\", etc.)\n   * @type {?string}\n   */\n  this.pathType = undefined;\n}\n\n/**\n * Determines whether the given JSON reference exists within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n$Ref.prototype.exists = function (path, options) {\n  try {\n    this.resolve(path, options);\n    return true;\n  }\n  catch (e) {\n    return false;\n  }\n};\n\n/**\n * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @returns {*} - Returns the resolved value\n */\n$Ref.prototype.get = function (path, options) {\n  return this.resolve(path, options).value;\n};\n\n/**\n * Resolves the given JSON reference within this {@link $Ref#value}.\n *\n * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash\n * @param {$RefParserOptions} options\n * @param {string} [friendlyPath] - The original user-specified path (used for error messages)\n * @returns {Pointer}\n */\n$Ref.prototype.resolve = function (path, options, friendlyPath) {\n  let pointer = new Pointer(this, path, friendlyPath);\n  return pointer.resolve(this.value, options);\n};\n\n/**\n * Sets the value of a nested property within this {@link $Ref#value}.\n * If the property, or any of its parents don't exist, they will be created.\n *\n * @param {string} path - The full path of the property to set, optionally with a JSON pointer in the hash\n * @param {*} value - The value to assign\n */\n$Ref.prototype.set = function (path, value) {\n  let pointer = new Pointer(this, path);\n  this.value = pointer.set(this.value, value);\n};\n\n/**\n * Determines whether the given value is a JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.is$Ref = function (value) {\n  return value && typeof value === \"object\" && typeof value.$ref === \"string\" && value.$ref.length > 0;\n};\n\n/**\n * Determines whether the given value is an external JSON reference.\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.isExternal$Ref = function (value) {\n  return $Ref.is$Ref(value) && value.$ref[0] !== \"#\";\n};\n\n/**\n * Determines whether the given value is a JSON reference, and whether it is allowed by the options.\n * For example, if it references an external file, then options.resolve.external must be true.\n *\n * @param {*} value - The value to inspect\n * @param {$RefParserOptions} options\n * @returns {boolean}\n */\n$Ref.isAllowed$Ref = function (value, options) {\n  if ($Ref.is$Ref(value)) {\n    if (value.$ref.substr(0, 2) === \"#/\" || value.$ref === \"#\") {\n      // It's a JSON Pointer reference, which is always allowed\n      return true;\n    }\n    else if (value.$ref[0] !== \"#\" && (!options || options.resolve.external)) {\n      // It's an external reference, which is allowed by the options\n      return true;\n    }\n  }\n};\n\n/**\n * Determines whether the given value is a JSON reference that \"extends\" its resolved value.\n * That is, it has extra properties (in addition to \"$ref\"), so rather than simply pointing to\n * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved\n * value, plus the extra properties.\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  In this example, \"employee\" is an extended $ref, since it extends \"person\" with an additional\n *  property (salary).  The result is a NEW value that looks like this:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\n$Ref.isExtended$Ref = function (value) {\n  return $Ref.is$Ref(value) && Object.keys(value).length > 1;\n};\n\n/**\n * Returns the resolved value of a JSON Reference.\n * If necessary, the resolved value is merged with the JSON Reference to create a new object\n *\n * @example:\n *  {\n *    person: {\n *      properties: {\n *        firstName: { type: string }\n *        lastName: { type: string }\n *      }\n *    }\n *    employee: {\n *      properties: {\n *        $ref: #/person/properties\n *        salary: { type: number }\n *      }\n *    }\n *  }\n *\n *  When \"person\" and \"employee\" are merged, you end up with the following object:\n *\n *  {\n *    properties: {\n *      firstName: { type: string }\n *      lastName: { type: string }\n *      salary: { type: number }\n *    }\n *  }\n *\n * @param {object} $ref - The JSON reference object (the one with the \"$ref\" property)\n * @param {*} resolvedValue - The resolved value, which can be any type\n * @returns {*} - Returns the dereferenced value\n */\n$Ref.dereference = function ($ref, resolvedValue) {\n  if (resolvedValue && typeof resolvedValue === \"object\" && $Ref.isExtended$Ref($ref)) {\n    let merged = {};\n    for (let key of Object.keys($ref)) {\n      if (key !== \"$ref\") {\n        merged[key] = $ref[key];\n      }\n    }\n\n    for (let key of Object.keys(resolvedValue)) {\n      if (!(key in merged)) {\n        merged[key] = resolvedValue[key];\n      }\n    }\n\n    return merged;\n  }\n  else {\n    // Completely replace the original reference with the resolved value\n    return resolvedValue;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}