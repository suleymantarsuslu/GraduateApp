{"ast":null,"code":"\"use strict\";\n\nconst validateSchema = require(\"./validators/schema\");\n\nconst validateSpec = require(\"./validators/spec\");\n\nconst normalizeArgs = require(\"@apidevtools/json-schema-ref-parser/lib/normalize-args\");\n\nconst util = require(\"./util\");\n\nconst Options = require(\"./options\");\n\nconst maybe = require(\"call-me-maybe\");\n\nconst {\n  ono\n} = require(\"@jsdevtools/ono\");\n\nconst $RefParser = require(\"@apidevtools/json-schema-ref-parser\");\n\nconst dereference = require(\"@apidevtools/json-schema-ref-parser/lib/dereference\");\n\nmodule.exports = SwaggerParser;\n/**\n * This class parses a Swagger 2.0 or 3.0 API, resolves its JSON references and their resolved values,\n * and provides methods for traversing, dereferencing, and validating the API.\n *\n * @constructor\n * @extends $RefParser\n */\n\nfunction SwaggerParser() {\n  $RefParser.apply(this, arguments);\n}\n\nutil.inherits(SwaggerParser, $RefParser);\nSwaggerParser.YAML = $RefParser.YAML;\nSwaggerParser.parse = $RefParser.parse;\nSwaggerParser.resolve = $RefParser.resolve;\nSwaggerParser.bundle = $RefParser.bundle;\nSwaggerParser.dereference = $RefParser.dereference;\n/**\n * Alias {@link $RefParser#schema} as {@link SwaggerParser#api}\n */\n\nObject.defineProperty(SwaggerParser.prototype, \"api\", {\n  configurable: true,\n  enumerable: true,\n\n  get() {\n    return this.schema;\n  }\n\n});\n/**\n * Parses the given Swagger API.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.\n * @param {ParserOptions} [options] - Options that determine how the API is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed API object.\n * @returns {Promise} - The returned promise resolves with the parsed API object.\n */\n\nSwaggerParser.prototype.parse = async function (path, api, options, callback) {\n  let args = normalizeArgs(arguments);\n  args.options = new Options(args.options);\n\n  try {\n    let schema = await $RefParser.prototype.parse.call(this, args.path, args.schema, args.options);\n\n    if (schema.swagger) {\n      // Verify that the parsed object is a Swagger API\n      if (schema.swagger === undefined || schema.info === undefined || schema.paths === undefined) {\n        throw ono.syntax(`${args.path || args.schema} is not a valid Swagger API definition`);\n      } else if (typeof schema.swagger === \"number\") {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('Swagger version number must be a string (e.g. \"2.0\") not a number.');\n      } else if (typeof schema.info.version === \"number\") {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('API version number must be a string (e.g. \"1.0.0\") not a number.');\n      } else if (schema.swagger !== \"2.0\") {\n        throw ono.syntax(`Unrecognized Swagger version: ${schema.swagger}. Expected 2.0`);\n      }\n    } else {\n      let supportedVersions = [\"3.0.0\", \"3.0.1\", \"3.0.2\", \"3.0.3\"]; // Verify that the parsed object is a Openapi API\n\n      if (schema.openapi === undefined || schema.info === undefined || schema.paths === undefined) {\n        throw ono.syntax(`${args.path || args.schema} is not a valid Openapi API definition`);\n      } else if (typeof schema.openapi === \"number\") {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('Openapi version number must be a string (e.g. \"3.0.0\") not a number.');\n      } else if (typeof schema.info.version === \"number\") {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('API version number must be a string (e.g. \"1.0.0\") not a number.');\n      } else if (supportedVersions.indexOf(schema.openapi) === -1) {\n        throw ono.syntax(`Unsupported OpenAPI version: ${schema.openapi}. ` + `Swagger Parser only supports versions ${supportedVersions.join(\", \")}`);\n      }\n    } // Looks good!\n\n\n    return maybe(args.callback, Promise.resolve(schema));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n/**\n * Parses, dereferences, and validates the given Swagger API.\n * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.\n * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed API object.\n * @returns {Promise} - The returned promise resolves with the parsed API object.\n */\n\n\nSwaggerParser.validate = function (path, api, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n\n  let instance = new Class();\n  return instance.validate.apply(instance, arguments);\n};\n/**\n * Parses, dereferences, and validates the given Swagger API.\n * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.\n * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed API object.\n * @returns {Promise} - The returned promise resolves with the parsed API object.\n */\n\n\nSwaggerParser.prototype.validate = async function (path, api, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n  args.options = new Options(args.options); // ZSchema doesn't support circular objects, so don't dereference circular $refs yet\n  // (see https://github.com/zaggino/z-schema/issues/137)\n\n  let circular$RefOption = args.options.dereference.circular;\n  args.options.validate.schema && (args.options.dereference.circular = \"ignore\");\n\n  try {\n    await this.dereference(args.path, args.schema, args.options); // Restore the original options, now that we're done dereferencing\n\n    args.options.dereference.circular = circular$RefOption;\n\n    if (args.options.validate.schema) {\n      // Validate the API against the Swagger schema\n      // NOTE: This is safe to do, because we haven't dereferenced circular $refs yet\n      validateSchema(me.api);\n\n      if (me.$refs.circular) {\n        if (circular$RefOption === true) {\n          // The API has circular references,\n          // so we need to do a second-pass to fully-dereference it\n          dereference(me, args.options);\n        } else if (circular$RefOption === false) {\n          // The API has circular references, and they're not allowed, so throw an error\n          throw ono.reference(\"The API contains circular references\");\n        }\n      }\n    }\n\n    if (args.options.validate.spec) {\n      // Validate the API against the Swagger spec\n      validateSpec(me.api);\n    }\n\n    return maybe(args.callback, Promise.resolve(me.schema));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n/**\n * The Swagger object\n * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#swagger-object\n *\n * @typedef {{swagger: string, info: {}, paths: {}}} SwaggerObject\n */","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@apidevtools/swagger-parser/lib/index.js"],"names":["validateSchema","require","validateSpec","normalizeArgs","util","Options","maybe","ono","$RefParser","dereference","module","exports","SwaggerParser","apply","arguments","inherits","YAML","parse","resolve","bundle","Object","defineProperty","prototype","configurable","enumerable","get","schema","path","api","options","callback","args","call","swagger","undefined","info","paths","syntax","version","supportedVersions","openapi","indexOf","join","Promise","err","reject","validate","Class","instance","me","circular$RefOption","circular","$refs","reference","spec"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst validateSchema = require(\"./validators/schema\");\nconst validateSpec = require(\"./validators/spec\");\nconst normalizeArgs = require(\"@apidevtools/json-schema-ref-parser/lib/normalize-args\");\nconst util = require(\"./util\");\nconst Options = require(\"./options\");\nconst maybe = require(\"call-me-maybe\");\nconst { ono } = require(\"@jsdevtools/ono\");\nconst $RefParser = require(\"@apidevtools/json-schema-ref-parser\");\nconst dereference = require(\"@apidevtools/json-schema-ref-parser/lib/dereference\");\n\nmodule.exports = SwaggerParser;\n\n/**\n * This class parses a Swagger 2.0 or 3.0 API, resolves its JSON references and their resolved values,\n * and provides methods for traversing, dereferencing, and validating the API.\n *\n * @constructor\n * @extends $RefParser\n */\nfunction SwaggerParser () {\n  $RefParser.apply(this, arguments);\n}\n\nutil.inherits(SwaggerParser, $RefParser);\nSwaggerParser.YAML = $RefParser.YAML;\nSwaggerParser.parse = $RefParser.parse;\nSwaggerParser.resolve = $RefParser.resolve;\nSwaggerParser.bundle = $RefParser.bundle;\nSwaggerParser.dereference = $RefParser.dereference;\n\n/**\n * Alias {@link $RefParser#schema} as {@link SwaggerParser#api}\n */\nObject.defineProperty(SwaggerParser.prototype, \"api\", {\n  configurable: true,\n  enumerable: true,\n  get () {\n    return this.schema;\n  }\n});\n\n/**\n * Parses the given Swagger API.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.\n * @param {ParserOptions} [options] - Options that determine how the API is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed API object.\n * @returns {Promise} - The returned promise resolves with the parsed API object.\n */\nSwaggerParser.prototype.parse = async function (path, api, options, callback) {\n  let args = normalizeArgs(arguments);\n  args.options = new Options(args.options);\n\n  try {\n    let schema = await $RefParser.prototype.parse.call(this, args.path, args.schema, args.options);\n\n    if (schema.swagger) {\n      // Verify that the parsed object is a Swagger API\n      if (schema.swagger === undefined || schema.info === undefined || schema.paths === undefined) {\n        throw ono.syntax(`${args.path || args.schema} is not a valid Swagger API definition`);\n      }\n      else if (typeof schema.swagger === \"number\") {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('Swagger version number must be a string (e.g. \"2.0\") not a number.');\n      }\n      else if (typeof schema.info.version === \"number\") {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('API version number must be a string (e.g. \"1.0.0\") not a number.');\n      }\n      else if (schema.swagger !== \"2.0\") {\n        throw ono.syntax(`Unrecognized Swagger version: ${schema.swagger}. Expected 2.0`);\n      }\n    }\n    else {\n      let supportedVersions = [\"3.0.0\", \"3.0.1\", \"3.0.2\", \"3.0.3\"];\n\n      // Verify that the parsed object is a Openapi API\n      if (schema.openapi === undefined || schema.info === undefined || schema.paths === undefined) {\n        throw ono.syntax(`${args.path || args.schema} is not a valid Openapi API definition`);\n      }\n      else if (typeof schema.openapi === \"number\") {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('Openapi version number must be a string (e.g. \"3.0.0\") not a number.');\n      }\n      else if (typeof schema.info.version === \"number\") {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('API version number must be a string (e.g. \"1.0.0\") not a number.');\n      }\n      else if (supportedVersions.indexOf(schema.openapi) === -1) {\n        throw ono.syntax(\n          `Unsupported OpenAPI version: ${schema.openapi}. ` +\n          `Swagger Parser only supports versions ${supportedVersions.join(\", \")}`\n        );\n      }\n    }\n\n    // Looks good!\n    return maybe(args.callback, Promise.resolve(schema));\n  }\n  catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * Parses, dereferences, and validates the given Swagger API.\n * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.\n * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed API object.\n * @returns {Promise} - The returned promise resolves with the parsed API object.\n */\nSwaggerParser.validate = function (path, api, options, callback) {\n  let Class = this; // eslint-disable-line consistent-this\n  let instance = new Class();\n  return instance.validate.apply(instance, arguments);\n};\n\n/**\n * Parses, dereferences, and validates the given Swagger API.\n * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.\n * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed API object.\n * @returns {Promise} - The returned promise resolves with the parsed API object.\n */\nSwaggerParser.prototype.validate = async function (path, api, options, callback) {\n  let me = this;\n  let args = normalizeArgs(arguments);\n  args.options = new Options(args.options);\n\n  // ZSchema doesn't support circular objects, so don't dereference circular $refs yet\n  // (see https://github.com/zaggino/z-schema/issues/137)\n  let circular$RefOption = args.options.dereference.circular;\n  args.options.validate.schema && (args.options.dereference.circular = \"ignore\");\n\n  try {\n    await this.dereference(args.path, args.schema, args.options);\n\n    // Restore the original options, now that we're done dereferencing\n    args.options.dereference.circular = circular$RefOption;\n\n    if (args.options.validate.schema) {\n      // Validate the API against the Swagger schema\n      // NOTE: This is safe to do, because we haven't dereferenced circular $refs yet\n      validateSchema(me.api);\n\n      if (me.$refs.circular) {\n        if (circular$RefOption === true) {\n          // The API has circular references,\n          // so we need to do a second-pass to fully-dereference it\n          dereference(me, args.options);\n        }\n        else if (circular$RefOption === false) {\n          // The API has circular references, and they're not allowed, so throw an error\n          throw ono.reference(\"The API contains circular references\");\n        }\n      }\n    }\n\n    if (args.options.validate.spec) {\n      // Validate the API against the Swagger spec\n      validateSpec(me.api);\n    }\n\n    return maybe(args.callback, Promise.resolve(me.schema));\n  }\n  catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * The Swagger object\n * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#swagger-object\n *\n * @typedef {{swagger: string, info: {}, paths: {}}} SwaggerObject\n */\n"]},"metadata":{},"sourceType":"script"}