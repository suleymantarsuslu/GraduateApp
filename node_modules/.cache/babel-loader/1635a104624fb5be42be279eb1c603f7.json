{"ast":null,"code":"\"use strict\";\n\nvar defineProperty = Object.defineProperty || function (object, name, property) {\n  object[name] = property.value;\n  return object;\n}; // Shortcut for `Object.prototype.toString` for faster access.\n\n\nvar typefy = Object.prototype.toString; // Map to for jumping from typeof(value) to associated type prefix used\n// as a hash in the map of builtin implementations.\n\nvar types = {\n  \"function\": \"Object\",\n  \"object\": \"Object\"\n}; // Array is used to save method implementations for the host objects in order\n// to avoid extending them with non-primitive values that could cause leaks.\n\nvar host = []; // Hash map is used to save method implementations for builtin types in order\n// to avoid extending their prototypes. This also allows to share method\n// implementations for types across diff contexts / frames / compartments.\n\nvar builtin = {};\n\nfunction Primitive() {}\n\nfunction ObjectType() {}\n\nObjectType.prototype = new Primitive();\n\nfunction ErrorType() {}\n\nErrorType.prototype = new ObjectType();\nvar Default = builtin.Default = Primitive.prototype;\nvar Null = builtin.Null = new Primitive();\nvar Void = builtin.Void = new Primitive();\nbuiltin.String = new Primitive();\nbuiltin.Number = new Primitive();\nbuiltin.Boolean = new Primitive();\nbuiltin.Object = ObjectType.prototype;\nbuiltin.Error = ErrorType.prototype;\nbuiltin.EvalError = new ErrorType();\nbuiltin.InternalError = new ErrorType();\nbuiltin.RangeError = new ErrorType();\nbuiltin.ReferenceError = new ErrorType();\nbuiltin.StopIteration = new ErrorType();\nbuiltin.SyntaxError = new ErrorType();\nbuiltin.TypeError = new ErrorType();\nbuiltin.URIError = new ErrorType();\n\nfunction Method(id) {\n  /**\n  Private Method is a callable private name that dispatches on the first\n  arguments same named Method:\n       method(object, ...rest) => object[method](...rest)\n   It is supposed to be given **unique** `id` preferably in `\"jump@package\"`\n  like form so it won't collide with `id's` other users create. If no argument\n  is passed unique id is generated, but it's proved to be problematic with\n  npm where it's easy to end up with a copies of same module where each copy\n  will have a different name.\n   ## Example\n       var foo = Method(\"foo@awesomeness\")\n       // Implementation for any types\n      foo.define(function(value, arg1, arg2) {\n        // ...\n      })\n       // Implementation for a specific type\n      foo.define(BarType, function(bar, arg1, arg2) {\n        // ...\n      })\n  **/\n  // Create an internal unique name if one is not provided, also prefix it\n  // to avoid collision with regular method names.\n  var name = \"λ:\" + String(id || Math.random().toString(32).substr(2));\n\n  function dispatch(value) {\n    // Method dispatches on type of the first argument.\n    // If first argument is `null` or `void` associated implementation is\n    // looked up in the `builtin` hash where implementations for built-ins\n    // are stored.\n    var type = null;\n    var method = value === null ? Null[name] : value === void 0 ? Void[name] : // Otherwise attempt to use method with a generated private\n    // `name` that is supposedly in the prototype chain of the\n    // `target`.\n    value[name] || // Otherwise assume it's one of the built-in type instances,\n    // in which case implementation is stored in a `builtin` hash.\n    // Attempt to find a implementation for the given built-in\n    // via constructor name and method name.\n    (type = builtin[(value.constructor || \"\").name]) && type[name] || // Otherwise assume it's a host object. For host objects\n    // actual method implementations are stored in the `host`\n    // array and only index for the implementation is stored\n    // in the host object's prototype chain. This avoids memory\n    // leaks that otherwise could happen when saving JS objects\n    // on host object.\n    host[value[\"!\" + name]] || // Otherwise attempt to lookup implementation for builtins by\n    // a type of the value. This basically makes sure that all\n    // non primitive values will delegate to an `Object`.\n    (type = builtin[types[typeof value]]) && type[name]; // If method implementation for the type is still not found then\n    // just fallback for default implementation.\n\n    method = method || Default[name]; // If implementation is still not found (which also means there is no\n    // default) just throw an error with a descriptive message.\n\n    if (!method) throw TypeError(\"Type does not implements method: \" + name); // If implementation was found then just delegate.\n\n    return method.apply(method, arguments);\n  } // Make `toString` of the dispatch return a private name, this enables\n  // method definition without sugar:\n  //\n  //    var method = Method()\n  //    object[method] = function() { /***/ }\n\n\n  dispatch.toString = function toString() {\n    return name;\n  }; // Copy utility methods for convenient API.\n\n\n  dispatch.implement = implementMethod;\n  dispatch.define = defineMethod;\n  return dispatch;\n} // Create method shortcuts form functions.\n\n\nvar defineMethod = function defineMethod(Type, lambda) {\n  return define(this, Type, lambda);\n};\n\nvar implementMethod = function implementMethod(object, lambda) {\n  return implement(this, object, lambda);\n}; // Define `implement` and `define` polymorphic methods to allow definitions\n// and implementations through them.\n\n\nvar implement = Method(\"implement@method\");\nvar define = Method(\"define@method\");\n\nfunction _implement(method, object, lambda) {\n  /**\n  Implements `Method` for the given `object` with a provided `implementation`.\n  Calling `Method` with `object` as a first argument will dispatch on provided\n  implementation.\n  **/\n  return defineProperty(object, method.toString(), {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: lambda\n  });\n}\n\nfunction _define(method, Type, lambda) {\n  /**\n  Defines `Method` for the given `Type` with a provided `implementation`.\n  Calling `Method` with a first argument of this `Type` will dispatch on\n  provided `implementation`. If `Type` is a `Method` default implementation\n  is defined. If `Type` is a `null` or `undefined` `Method` is implemented\n  for that value type.\n  **/\n  // Attempt to guess a type via `Object.prototype.toString.call` hack.\n  var type = Type && typefy.call(Type.prototype); // If only two arguments are passed then `Type` is actually an implementation\n  // for a default type.\n\n  if (!lambda) Default[method] = Type; // If `Type` is `null` or `void` store implementation accordingly.\n  else if (Type === null) Null[method] = lambda;else if (Type === void 0) Void[method] = lambda; // If `type` hack indicates built-in type and type has a name us it to\n    // store a implementation into associated hash. If hash for this type does\n    // not exists yet create one.\n    else if (type !== \"[object Object]\" && Type.name) {\n        var Bulitin = builtin[Type.name] || (builtin[Type.name] = new ObjectType());\n        Bulitin[method] = lambda;\n      } // If `type` hack indicates an object, that may be either object or any\n      // JS defined \"Class\". If name of the constructor is `Object`, assume it's\n      // built-in `Object` and store implementation accordingly.\n      else if (Type.name === \"Object\") builtin.Object[method] = lambda; // Host objects are pain!!! Every browser does some crazy stuff for them\n        // So far all browser seem to not implement `call` method for host object\n        // constructors. If that is a case here, assume it's a host object and\n        // store implementation in a `host` array and store `index` in the array\n        // in a `Type.prototype` itself. This avoids memory leaks that could be\n        // caused by storing JS objects on a host objects.\n        else if (Type.call === void 0) {\n            var index = host.indexOf(lambda);\n            if (index < 0) index = host.push(lambda) - 1; // Prefix private name with `!` so it can be dispatched from the method\n            // without type checks.\n\n            implement(\"!\" + method, Type.prototype, index);\n          } // If Got that far `Type` is user defined JS `Class`. Define private name\n          // as hidden property on it's prototype.\n          else implement(method, Type.prototype, lambda);\n} // And provided implementations for a polymorphic equivalents.\n\n\n_define(define, _define);\n\n_define(implement, _implement); // Define exports on `Method` as it's only thing being exported.\n\n\nMethod.implement = implement;\nMethod.define = define;\nMethod.Method = Method;\nMethod.method = Method;\nMethod.builtin = builtin;\nMethod.host = host;\nmodule.exports = Method;","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/method/core.js"],"names":["defineProperty","Object","object","name","property","value","typefy","prototype","toString","types","host","builtin","Primitive","ObjectType","ErrorType","Default","Null","Void","String","Number","Boolean","Error","EvalError","InternalError","RangeError","ReferenceError","StopIteration","SyntaxError","TypeError","URIError","Method","id","Math","random","substr","dispatch","type","method","constructor","apply","arguments","implement","implementMethod","define","defineMethod","Type","lambda","_implement","enumerable","configurable","writable","_define","call","Bulitin","index","indexOf","push","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar defineProperty = Object.defineProperty || function(object, name, property) {\n  object[name] = property.value\n  return object\n}\n\n// Shortcut for `Object.prototype.toString` for faster access.\nvar typefy = Object.prototype.toString\n\n// Map to for jumping from typeof(value) to associated type prefix used\n// as a hash in the map of builtin implementations.\nvar types = { \"function\": \"Object\", \"object\": \"Object\" }\n\n// Array is used to save method implementations for the host objects in order\n// to avoid extending them with non-primitive values that could cause leaks.\nvar host = []\n// Hash map is used to save method implementations for builtin types in order\n// to avoid extending their prototypes. This also allows to share method\n// implementations for types across diff contexts / frames / compartments.\nvar builtin = {}\n\nfunction Primitive() {}\nfunction ObjectType() {}\nObjectType.prototype = new Primitive()\nfunction ErrorType() {}\nErrorType.prototype = new ObjectType()\n\nvar Default = builtin.Default = Primitive.prototype\nvar Null = builtin.Null = new Primitive()\nvar Void = builtin.Void = new Primitive()\nbuiltin.String = new Primitive()\nbuiltin.Number = new Primitive()\nbuiltin.Boolean = new Primitive()\n\nbuiltin.Object = ObjectType.prototype\nbuiltin.Error = ErrorType.prototype\n\nbuiltin.EvalError = new ErrorType()\nbuiltin.InternalError = new ErrorType()\nbuiltin.RangeError = new ErrorType()\nbuiltin.ReferenceError = new ErrorType()\nbuiltin.StopIteration = new ErrorType()\nbuiltin.SyntaxError = new ErrorType()\nbuiltin.TypeError = new ErrorType()\nbuiltin.URIError = new ErrorType()\n\n\nfunction Method(id) {\n  /**\n  Private Method is a callable private name that dispatches on the first\n  arguments same named Method:\n\n      method(object, ...rest) => object[method](...rest)\n\n  It is supposed to be given **unique** `id` preferably in `\"jump@package\"`\n  like form so it won't collide with `id's` other users create. If no argument\n  is passed unique id is generated, but it's proved to be problematic with\n  npm where it's easy to end up with a copies of same module where each copy\n  will have a different name.\n\n  ## Example\n\n      var foo = Method(\"foo@awesomeness\")\n\n      // Implementation for any types\n      foo.define(function(value, arg1, arg2) {\n        // ...\n      })\n\n      // Implementation for a specific type\n      foo.define(BarType, function(bar, arg1, arg2) {\n        // ...\n      })\n  **/\n\n  // Create an internal unique name if one is not provided, also prefix it\n  // to avoid collision with regular method names.\n  var name = \"λ:\" + String(id || Math.random().toString(32).substr(2))\n\n  function dispatch(value) {\n    // Method dispatches on type of the first argument.\n    // If first argument is `null` or `void` associated implementation is\n    // looked up in the `builtin` hash where implementations for built-ins\n    // are stored.\n    var type = null\n    var method = value === null ? Null[name] :\n                 value === void(0) ? Void[name] :\n                 // Otherwise attempt to use method with a generated private\n                 // `name` that is supposedly in the prototype chain of the\n                 // `target`.\n                 value[name] ||\n                 // Otherwise assume it's one of the built-in type instances,\n                 // in which case implementation is stored in a `builtin` hash.\n                 // Attempt to find a implementation for the given built-in\n                 // via constructor name and method name.\n                 ((type = builtin[(value.constructor || \"\").name]) &&\n                  type[name]) ||\n                 // Otherwise assume it's a host object. For host objects\n                 // actual method implementations are stored in the `host`\n                 // array and only index for the implementation is stored\n                 // in the host object's prototype chain. This avoids memory\n                 // leaks that otherwise could happen when saving JS objects\n                 // on host object.\n                 host[value[\"!\" + name]] ||\n                 // Otherwise attempt to lookup implementation for builtins by\n                 // a type of the value. This basically makes sure that all\n                 // non primitive values will delegate to an `Object`.\n                 ((type = builtin[types[typeof(value)]]) && type[name])\n\n\n    // If method implementation for the type is still not found then\n    // just fallback for default implementation.\n    method = method || Default[name]\n\n    // If implementation is still not found (which also means there is no\n    // default) just throw an error with a descriptive message.\n    if (!method) throw TypeError(\"Type does not implements method: \" + name)\n\n    // If implementation was found then just delegate.\n    return method.apply(method, arguments)\n  }\n\n  // Make `toString` of the dispatch return a private name, this enables\n  // method definition without sugar:\n  //\n  //    var method = Method()\n  //    object[method] = function() { /***/ }\n  dispatch.toString = function toString() { return name }\n\n  // Copy utility methods for convenient API.\n  dispatch.implement = implementMethod\n  dispatch.define = defineMethod\n\n  return dispatch\n}\n\n// Create method shortcuts form functions.\nvar defineMethod = function defineMethod(Type, lambda) {\n  return define(this, Type, lambda)\n}\nvar implementMethod = function implementMethod(object, lambda) {\n  return implement(this, object, lambda)\n}\n\n// Define `implement` and `define` polymorphic methods to allow definitions\n// and implementations through them.\nvar implement = Method(\"implement@method\")\nvar define = Method(\"define@method\")\n\n\nfunction _implement(method, object, lambda) {\n  /**\n  Implements `Method` for the given `object` with a provided `implementation`.\n  Calling `Method` with `object` as a first argument will dispatch on provided\n  implementation.\n  **/\n  return defineProperty(object, method.toString(), {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: lambda\n  })\n}\n\nfunction _define(method, Type, lambda) {\n  /**\n  Defines `Method` for the given `Type` with a provided `implementation`.\n  Calling `Method` with a first argument of this `Type` will dispatch on\n  provided `implementation`. If `Type` is a `Method` default implementation\n  is defined. If `Type` is a `null` or `undefined` `Method` is implemented\n  for that value type.\n  **/\n\n  // Attempt to guess a type via `Object.prototype.toString.call` hack.\n  var type = Type && typefy.call(Type.prototype)\n\n  // If only two arguments are passed then `Type` is actually an implementation\n  // for a default type.\n  if (!lambda) Default[method] = Type\n  // If `Type` is `null` or `void` store implementation accordingly.\n  else if (Type === null) Null[method] = lambda\n  else if (Type === void(0)) Void[method] = lambda\n  // If `type` hack indicates built-in type and type has a name us it to\n  // store a implementation into associated hash. If hash for this type does\n  // not exists yet create one.\n  else if (type !== \"[object Object]\" && Type.name) {\n    var Bulitin = builtin[Type.name] || (builtin[Type.name] = new ObjectType())\n    Bulitin[method] = lambda\n  }\n  // If `type` hack indicates an object, that may be either object or any\n  // JS defined \"Class\". If name of the constructor is `Object`, assume it's\n  // built-in `Object` and store implementation accordingly.\n  else if (Type.name === \"Object\")\n    builtin.Object[method] = lambda\n  // Host objects are pain!!! Every browser does some crazy stuff for them\n  // So far all browser seem to not implement `call` method for host object\n  // constructors. If that is a case here, assume it's a host object and\n  // store implementation in a `host` array and store `index` in the array\n  // in a `Type.prototype` itself. This avoids memory leaks that could be\n  // caused by storing JS objects on a host objects.\n  else if (Type.call === void(0)) {\n    var index = host.indexOf(lambda)\n    if (index < 0) index = host.push(lambda) - 1\n    // Prefix private name with `!` so it can be dispatched from the method\n    // without type checks.\n    implement(\"!\" + method, Type.prototype, index)\n  }\n  // If Got that far `Type` is user defined JS `Class`. Define private name\n  // as hidden property on it's prototype.\n  else\n    implement(method, Type.prototype, lambda)\n}\n\n// And provided implementations for a polymorphic equivalents.\n_define(define, _define)\n_define(implement, _implement)\n\n// Define exports on `Method` as it's only thing being exported.\nMethod.implement = implement\nMethod.define = define\nMethod.Method = Method\nMethod.method = Method\nMethod.builtin = builtin\nMethod.host = host\n\nmodule.exports = Method\n"]},"metadata":{},"sourceType":"script"}