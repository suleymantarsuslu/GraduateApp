{"ast":null,"code":"\"use strict\";\n\nvar reduce = require(\"./reduce\");\n\nvar end = require(\"./end\");\n\nvar isError = require(\"./is-error\");\n\nvar isReduced = require(\"./is-reduced\");\n\nvar reduced = require(\"./reduced\");\n\nfunction Reducible(reduce) {\n  /**\n  Reducible is a type of the data-structure that represents something\n  that can be reduced. Most of the time it's used to represent transformation\n  over other reducible by capturing it in a lexical scope.\n   Reducible has an attribute `reduce` pointing to a function that does\n  reduction.\n  **/\n  // JS engines optimize access to properties that are set in the constructor's\n  // so we set it here.\n  this.reduce = reduce;\n} // Implementation of `accumulate` for reducible, which just delegates to it's\n// `reduce` attribute.\n\n\nreduce.define(Reducible, function reduceReducible(reducible, next, initial) {\n  var result; // State is intentionally accumulated in the outer variable, that way no\n  // matter if consumer is broken and passes in wrong accumulated state back\n  // this reducible will still accumulate result as intended.\n\n  var state = initial;\n\n  try {\n    reducible.reduce(function forward(value) {\n      try {\n        // If reduction has already being completed return is set to\n        // an accumulated state boxed via `reduced`. It's set to state\n        // that is return to signal input that reduction is complete.\n        if (result) state = result; // if dispatched `value` is is special `end` of input one or an error\n        // just forward to reducer and store last state boxed as `reduced` into\n        // state. Later it will be assigned to result and returned to input\n        // to indicate end of reduction.\n        else if (value === end || isError(value)) {\n            next(value, state);\n            state = reduced(state);\n          } // if non of above just accumulate new state by passing value and\n          // previously accumulate state to reducer.\n          else state = next(value, state); // If state is boxed with `reduced` then accumulation is complete.\n        // Indicated explicitly by a reducer or by end / error of the input.\n        // Either way store it to the result in case broken input attempts to\n        // call forward again.\n\n        if (isReduced(state)) result = state; // return accumulated state back either way.\n\n        return state;\n      } // If error is thrown then forward it to the reducer such that consumer\n      // can apply recovery logic. Also store current `state` boxed with\n      // `reduced` to signal input that reduction is complete.\n      catch (error) {\n        next(error, state);\n        result = reduced(state);\n        return result;\n      }\n    });\n  } // It could be that attempt to reduce underlaying reducible throws, if that\n  // is the case still forward an `error` to a reducer and store reduced state\n  // into result, in case process of reduction started before exception and\n  // forward will still be called. Return result either way to signal\n  // completion.\n  catch (error) {\n    next(error, state);\n    result = reduced(state);\n    return result;\n  }\n});\n\nfunction reducible(reduce) {\n  return new Reducible(reduce);\n}\n\nreducible.type = Reducible;\nmodule.exports = reducible;","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/reducible/reducible.js"],"names":["reduce","require","end","isError","isReduced","reduced","Reducible","define","reduceReducible","reducible","next","initial","result","state","forward","value","error","type","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,UAAD,CAApB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAjB;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,YAAD,CAArB;;AACA,IAAIG,SAAS,GAAGH,OAAO,CAAC,cAAD,CAAvB;;AACA,IAAII,OAAO,GAAGJ,OAAO,CAAC,WAAD,CAArB;;AAEA,SAASK,SAAT,CAAmBN,MAAnB,EAA2B;AACzB;;;;;;;AASA;AACA;AACA,OAAKA,MAAL,GAAcA,MAAd;AACD,C,CAED;AACA;;;AACAA,MAAM,CAACO,MAAP,CAAcD,SAAd,EAAyB,SAASE,eAAT,CAAyBC,SAAzB,EAAoCC,IAApC,EAA0CC,OAA1C,EAAmD;AAC1E,MAAIC,MAAJ,CAD0E,CAE1E;AACA;AACA;;AACA,MAAIC,KAAK,GAAGF,OAAZ;;AACA,MAAI;AACFF,IAAAA,SAAS,CAACT,MAAV,CAAiB,SAASc,OAAT,CAAiBC,KAAjB,EAAwB;AACvC,UAAI;AACF;AACA;AACA;AACA,YAAIH,MAAJ,EAAYC,KAAK,GAAGD,MAAR,CAAZ,CACA;AACA;AACA;AACA;AAJA,aAKK,IAAIG,KAAK,KAAKb,GAAV,IAAiBC,OAAO,CAACY,KAAD,CAA5B,EAAqC;AACxCL,YAAAA,IAAI,CAACK,KAAD,EAAQF,KAAR,CAAJ;AACAA,YAAAA,KAAK,GAAGR,OAAO,CAACQ,KAAD,CAAf;AACD,WAHI,CAIL;AACA;AALK,eAMAA,KAAK,GAAGH,IAAI,CAACK,KAAD,EAAQF,KAAR,CAAZ,CAfH,CAiBF;AACA;AACA;AACA;;AACA,YAAIT,SAAS,CAACS,KAAD,CAAb,EAAsBD,MAAM,GAAGC,KAAT,CArBpB,CAuBF;;AACA,eAAOA,KAAP;AACD,OAzBD,CA0BA;AACA;AACA;AACA,aAAOG,KAAP,EAAc;AACZN,QAAAA,IAAI,CAACM,KAAD,EAAQH,KAAR,CAAJ;AACAD,QAAAA,MAAM,GAAGP,OAAO,CAACQ,KAAD,CAAhB;AACA,eAAOD,MAAP;AACD;AACF,KAnCD;AAoCD,GArCD,CAsCA;AACA;AACA;AACA;AACA;AACA,SAAMI,KAAN,EAAa;AACXN,IAAAA,IAAI,CAACM,KAAD,EAAQH,KAAR,CAAJ;AACAD,IAAAA,MAAM,GAAGP,OAAO,CAACQ,KAAD,CAAhB;AACA,WAAOD,MAAP;AACD;AACF,CAtDD;;AAwDA,SAASH,SAAT,CAAmBT,MAAnB,EAA2B;AACzB,SAAO,IAAIM,SAAJ,CAAcN,MAAd,CAAP;AACD;;AACDS,SAAS,CAACQ,IAAV,GAAiBX,SAAjB;AAEAY,MAAM,CAACC,OAAP,GAAiBV,SAAjB","sourcesContent":["\"use strict\";\n\nvar reduce = require(\"./reduce\")\nvar end = require(\"./end\")\nvar isError = require(\"./is-error\")\nvar isReduced = require(\"./is-reduced\")\nvar reduced = require(\"./reduced\")\n\nfunction Reducible(reduce) {\n  /**\n  Reducible is a type of the data-structure that represents something\n  that can be reduced. Most of the time it's used to represent transformation\n  over other reducible by capturing it in a lexical scope.\n\n  Reducible has an attribute `reduce` pointing to a function that does\n  reduction.\n  **/\n\n  // JS engines optimize access to properties that are set in the constructor's\n  // so we set it here.\n  this.reduce = reduce\n}\n\n// Implementation of `accumulate` for reducible, which just delegates to it's\n// `reduce` attribute.\nreduce.define(Reducible, function reduceReducible(reducible, next, initial) {\n  var result\n  // State is intentionally accumulated in the outer variable, that way no\n  // matter if consumer is broken and passes in wrong accumulated state back\n  // this reducible will still accumulate result as intended.\n  var state = initial\n  try {\n    reducible.reduce(function forward(value) {\n      try {\n        // If reduction has already being completed return is set to\n        // an accumulated state boxed via `reduced`. It's set to state\n        // that is return to signal input that reduction is complete.\n        if (result) state = result\n        // if dispatched `value` is is special `end` of input one or an error\n        // just forward to reducer and store last state boxed as `reduced` into\n        // state. Later it will be assigned to result and returned to input\n        // to indicate end of reduction.\n        else if (value === end || isError(value)) {\n          next(value, state)\n          state = reduced(state)\n        }\n        // if non of above just accumulate new state by passing value and\n        // previously accumulate state to reducer.\n        else state = next(value, state)\n\n        // If state is boxed with `reduced` then accumulation is complete.\n        // Indicated explicitly by a reducer or by end / error of the input.\n        // Either way store it to the result in case broken input attempts to\n        // call forward again.\n        if (isReduced(state)) result = state\n\n        // return accumulated state back either way.\n        return state\n      }\n      // If error is thrown then forward it to the reducer such that consumer\n      // can apply recovery logic. Also store current `state` boxed with\n      // `reduced` to signal input that reduction is complete.\n      catch (error) {\n        next(error, state)\n        result = reduced(state)\n        return result\n      }\n    })\n  }\n  // It could be that attempt to reduce underlaying reducible throws, if that\n  // is the case still forward an `error` to a reducer and store reduced state\n  // into result, in case process of reduction started before exception and\n  // forward will still be called. Return result either way to signal\n  // completion.\n  catch(error) {\n    next(error, state)\n    result = reduced(state)\n    return result\n  }\n})\n\nfunction reducible(reduce) {\n  return new Reducible(reduce)\n}\nreducible.type = Reducible\n\nmodule.exports = reducible\n"]},"metadata":{},"sourceType":"script"}