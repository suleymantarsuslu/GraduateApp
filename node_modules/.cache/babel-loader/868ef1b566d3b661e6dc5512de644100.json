{"ast":null,"code":"\"use strict\";\n\nconst util = require(\"../util\");\n\nconst {\n  ono\n} = require(\"@jsdevtools/ono\");\n\nconst swaggerMethods = require(\"@apidevtools/swagger-methods\");\n\nconst primitiveTypes = [\"array\", \"boolean\", \"integer\", \"number\", \"string\"];\nconst schemaTypes = [\"array\", \"boolean\", \"integer\", \"number\", \"string\", \"object\", \"null\", undefined];\nmodule.exports = validateSpec;\n/**\n * Validates parts of the Swagger 2.0 spec that aren't covered by the Swagger 2.0 JSON Schema.\n *\n * @param {SwaggerObject} api\n */\n\nfunction validateSpec(api) {\n  if (api.openapi) {\n    // We don't (yet) support validating against the OpenAPI spec\n    return;\n  }\n\n  let paths = Object.keys(api.paths || {});\n  let operationIds = [];\n\n  for (let pathName of paths) {\n    let path = api.paths[pathName];\n    let pathId = \"/paths\" + pathName;\n\n    if (path && pathName.indexOf(\"/\") === 0) {\n      validatePath(api, path, pathId, operationIds);\n    }\n  }\n\n  let definitions = Object.keys(api.definitions || {});\n\n  for (let definitionName of definitions) {\n    let definition = api.definitions[definitionName];\n    let definitionId = \"/definitions/\" + definitionName;\n    validateRequiredPropertiesExist(definition, definitionId);\n  }\n}\n/**\n * Validates the given path.\n *\n * @param {SwaggerObject} api           - The entire Swagger API object\n * @param {object}        path          - A Path object, from the Swagger API\n * @param {string}        pathId        - A value that uniquely identifies the path\n * @param {string}        operationIds  - An array of collected operationIds found in other paths\n */\n\n\nfunction validatePath(api, path, pathId, operationIds) {\n  for (let operationName of swaggerMethods) {\n    let operation = path[operationName];\n    let operationId = pathId + \"/\" + operationName;\n\n    if (operation) {\n      let declaredOperationId = operation.operationId;\n\n      if (declaredOperationId) {\n        if (operationIds.indexOf(declaredOperationId) === -1) {\n          operationIds.push(declaredOperationId);\n        } else {\n          throw ono.syntax(`Validation failed. Duplicate operation id '${declaredOperationId}'`);\n        }\n      }\n\n      validateParameters(api, path, pathId, operation, operationId);\n      let responses = Object.keys(operation.responses || {});\n\n      for (let responseName of responses) {\n        let response = operation.responses[responseName];\n        let responseId = operationId + \"/responses/\" + responseName;\n        validateResponse(responseName, response || {}, responseId);\n      }\n    }\n  }\n}\n/**\n * Validates the parameters for the given operation.\n *\n * @param {SwaggerObject} api           - The entire Swagger API object\n * @param {object}        path          - A Path object, from the Swagger API\n * @param {string}        pathId        - A value that uniquely identifies the path\n * @param {object}        operation     - An Operation object, from the Swagger API\n * @param {string}        operationId   - A value that uniquely identifies the operation\n */\n\n\nfunction validateParameters(api, path, pathId, operation, operationId) {\n  let pathParams = path.parameters || [];\n  let operationParams = operation.parameters || []; // Check for duplicate path parameters\n\n  try {\n    checkForDuplicates(pathParams);\n  } catch (e) {\n    throw ono.syntax(e, `Validation failed. ${pathId} has duplicate parameters`);\n  } // Check for duplicate operation parameters\n\n\n  try {\n    checkForDuplicates(operationParams);\n  } catch (e) {\n    throw ono.syntax(e, `Validation failed. ${operationId} has duplicate parameters`);\n  } // Combine the path and operation parameters,\n  // with the operation params taking precedence over the path params\n\n\n  let params = pathParams.reduce((combinedParams, value) => {\n    let duplicate = combinedParams.some(param => {\n      return param.in === value.in && param.name === value.name;\n    });\n\n    if (!duplicate) {\n      combinedParams.push(value);\n    }\n\n    return combinedParams;\n  }, operationParams.slice());\n  validateBodyParameters(params, operationId);\n  validatePathParameters(params, pathId, operationId);\n  validateParameterTypes(params, api, operation, operationId);\n}\n/**\n * Validates body and formData parameters for the given operation.\n *\n * @param   {object[]}  params       -  An array of Parameter objects\n * @param   {string}    operationId  -  A value that uniquely identifies the operation\n */\n\n\nfunction validateBodyParameters(params, operationId) {\n  let bodyParams = params.filter(param => {\n    return param.in === \"body\";\n  });\n  let formParams = params.filter(param => {\n    return param.in === \"formData\";\n  }); // There can only be one \"body\" parameter\n\n  if (bodyParams.length > 1) {\n    throw ono.syntax(`Validation failed. ${operationId} has ${bodyParams.length} body parameters. Only one is allowed.`);\n  } else if (bodyParams.length > 0 && formParams.length > 0) {\n    // \"body\" params and \"formData\" params are mutually exclusive\n    throw ono.syntax(`Validation failed. ${operationId} has body parameters and formData parameters. Only one or the other is allowed.`);\n  }\n}\n/**\n * Validates path parameters for the given path.\n *\n * @param   {object[]}  params        - An array of Parameter objects\n * @param   {string}    pathId        - A value that uniquely identifies the path\n * @param   {string}    operationId   - A value that uniquely identifies the operation\n */\n\n\nfunction validatePathParameters(params, pathId, operationId) {\n  // Find all {placeholders} in the path string\n  let placeholders = pathId.match(util.swaggerParamRegExp) || []; // Check for duplicates\n\n  for (let i = 0; i < placeholders.length; i++) {\n    for (let j = i + 1; j < placeholders.length; j++) {\n      if (placeholders[i] === placeholders[j]) {\n        throw ono.syntax(`Validation failed. ${operationId} has multiple path placeholders named ${placeholders[i]}`);\n      }\n    }\n  }\n\n  params = params.filter(param => {\n    return param.in === \"path\";\n  });\n\n  for (let param of params) {\n    if (param.required !== true) {\n      throw ono.syntax(\"Validation failed. Path parameters cannot be optional. \" + `Set required=true for the \"${param.name}\" parameter at ${operationId}`);\n    }\n\n    let match = placeholders.indexOf(\"{\" + param.name + \"}\");\n\n    if (match === -1) {\n      throw ono.syntax(`Validation failed. ${operationId} has a path parameter named \"${param.name}\", ` + `but there is no corresponding {${param.name}} in the path string`);\n    }\n\n    placeholders.splice(match, 1);\n  }\n\n  if (placeholders.length > 0) {\n    throw ono.syntax(`Validation failed. ${operationId} is missing path parameter(s) for ${placeholders}`);\n  }\n}\n/**\n * Validates data types of parameters for the given operation.\n *\n * @param   {object[]}  params       -  An array of Parameter objects\n * @param   {object}    api          -  The entire Swagger API object\n * @param   {object}    operation    -  An Operation object, from the Swagger API\n * @param   {string}    operationId  -  A value that uniquely identifies the operation\n */\n\n\nfunction validateParameterTypes(params, api, operation, operationId) {\n  for (let param of params) {\n    let parameterId = operationId + \"/parameters/\" + param.name;\n    let schema, validTypes;\n\n    switch (param.in) {\n      case \"body\":\n        schema = param.schema;\n        validTypes = schemaTypes;\n        break;\n\n      case \"formData\":\n        schema = param;\n        validTypes = primitiveTypes.concat(\"file\");\n        break;\n\n      default:\n        schema = param;\n        validTypes = primitiveTypes;\n    }\n\n    validateSchema(schema, parameterId, validTypes);\n    validateRequiredPropertiesExist(schema, parameterId);\n\n    if (schema.type === \"file\") {\n      // \"file\" params must consume at least one of these MIME types\n      let formData = /multipart\\/(.*\\+)?form-data/;\n      let urlEncoded = /application\\/(.*\\+)?x-www-form-urlencoded/;\n      let consumes = operation.consumes || api.consumes || [];\n      let hasValidMimeType = consumes.some(consume => {\n        return formData.test(consume) || urlEncoded.test(consume);\n      });\n\n      if (!hasValidMimeType) {\n        throw ono.syntax(`Validation failed. ${operationId} has a file parameter, so it must consume multipart/form-data ` + \"or application/x-www-form-urlencoded\");\n      }\n    }\n  }\n}\n/**\n * Checks the given parameter list for duplicates, and throws an error if found.\n *\n * @param   {object[]}  params  - An array of Parameter objects\n */\n\n\nfunction checkForDuplicates(params) {\n  for (let i = 0; i < params.length - 1; i++) {\n    let outer = params[i];\n\n    for (let j = i + 1; j < params.length; j++) {\n      let inner = params[j];\n\n      if (outer.name === inner.name && outer.in === inner.in) {\n        throw ono.syntax(`Validation failed. Found multiple ${outer.in} parameters named \"${outer.name}\"`);\n      }\n    }\n  }\n}\n/**\n * Validates the given response object.\n *\n * @param   {string}    code        -  The HTTP response code (or \"default\")\n * @param   {object}    response    -  A Response object, from the Swagger API\n * @param   {string}    responseId  -  A value that uniquely identifies the response\n */\n\n\nfunction validateResponse(code, response, responseId) {\n  if (code !== \"default\" && (code < 100 || code > 599)) {\n    throw ono.syntax(`Validation failed. ${responseId} has an invalid response code (${code})`);\n  }\n\n  let headers = Object.keys(response.headers || {});\n\n  for (let headerName of headers) {\n    let header = response.headers[headerName];\n    let headerId = responseId + \"/headers/\" + headerName;\n    validateSchema(header, headerId, primitiveTypes);\n  }\n\n  if (response.schema) {\n    let validTypes = schemaTypes.concat(\"file\");\n\n    if (validTypes.indexOf(response.schema.type) === -1) {\n      throw ono.syntax(`Validation failed. ${responseId} has an invalid response schema type (${response.schema.type})`);\n    } else {\n      validateSchema(response.schema, responseId + \"/schema\", validTypes);\n    }\n  }\n}\n/**\n * Validates the given Swagger schema object.\n *\n * @param {object}    schema      - A Schema object, from the Swagger API\n * @param {string}    schemaId    - A value that uniquely identifies the schema object\n * @param {string[]}  validTypes  - An array of the allowed schema types\n */\n\n\nfunction validateSchema(schema, schemaId, validTypes) {\n  if (validTypes.indexOf(schema.type) === -1) {\n    throw ono.syntax(`Validation failed. ${schemaId} has an invalid type (${schema.type})`);\n  }\n\n  if (schema.type === \"array\" && !schema.items) {\n    throw ono.syntax(`Validation failed. ${schemaId} is an array, so it must include an \"items\" schema`);\n  }\n}\n/**\n * Validates that the declared properties of the given Swagger schema object actually exist.\n *\n * @param {object}    schema      - A Schema object, from the Swagger API\n * @param {string}    schemaId    - A value that uniquely identifies the schema object\n */\n\n\nfunction validateRequiredPropertiesExist(schema, schemaId) {\n  /**\n   * Recursively collects all properties of the schema and its ancestors. They are added to the props object.\n   */\n  function collectProperties(schemaObj, props) {\n    if (schemaObj.properties) {\n      for (let property in schemaObj.properties) {\n        if (schemaObj.properties.hasOwnProperty(property)) {\n          props[property] = schemaObj.properties[property];\n        }\n      }\n    }\n\n    if (schemaObj.allOf) {\n      for (let parent of schemaObj.allOf) {\n        collectProperties(parent, props);\n      }\n    }\n  }\n\n  if (schema.required && Array.isArray(schema.required)) {\n    let props = {};\n    collectProperties(schema, props);\n\n    for (let requiredProperty of schema.required) {\n      if (!props[requiredProperty]) {\n        throw ono.syntax(`Validation failed. Property '${requiredProperty}' listed as required but does not exist in '${schemaId}'`);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@apidevtools/swagger-parser/lib/validators/spec.js"],"names":["util","require","ono","swaggerMethods","primitiveTypes","schemaTypes","undefined","module","exports","validateSpec","api","openapi","paths","Object","keys","operationIds","pathName","path","pathId","indexOf","validatePath","definitions","definitionName","definition","definitionId","validateRequiredPropertiesExist","operationName","operation","operationId","declaredOperationId","push","syntax","validateParameters","responses","responseName","response","responseId","validateResponse","pathParams","parameters","operationParams","checkForDuplicates","e","params","reduce","combinedParams","value","duplicate","some","param","in","name","slice","validateBodyParameters","validatePathParameters","validateParameterTypes","bodyParams","filter","formParams","length","placeholders","match","swaggerParamRegExp","i","j","required","splice","parameterId","schema","validTypes","concat","validateSchema","type","formData","urlEncoded","consumes","hasValidMimeType","consume","test","outer","inner","code","headers","headerName","header","headerId","schemaId","items","collectProperties","schemaObj","props","properties","property","hasOwnProperty","allOf","parent","Array","isArray","requiredProperty"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst util = require(\"../util\");\nconst { ono } = require(\"@jsdevtools/ono\");\nconst swaggerMethods = require(\"@apidevtools/swagger-methods\");\nconst primitiveTypes = [\"array\", \"boolean\", \"integer\", \"number\", \"string\"];\nconst schemaTypes = [\"array\", \"boolean\", \"integer\", \"number\", \"string\", \"object\", \"null\", undefined];\n\nmodule.exports = validateSpec;\n\n/**\n * Validates parts of the Swagger 2.0 spec that aren't covered by the Swagger 2.0 JSON Schema.\n *\n * @param {SwaggerObject} api\n */\nfunction validateSpec (api) {\n  if (api.openapi) {\n    // We don't (yet) support validating against the OpenAPI spec\n    return;\n  }\n\n  let paths = Object.keys(api.paths || {});\n  let operationIds = [];\n  for (let pathName of paths) {\n    let path = api.paths[pathName];\n    let pathId = \"/paths\" + pathName;\n\n    if (path && pathName.indexOf(\"/\") === 0) {\n      validatePath(api, path, pathId, operationIds);\n    }\n  }\n\n  let definitions = Object.keys(api.definitions || {});\n  for (let definitionName of definitions) {\n    let definition = api.definitions[definitionName];\n    let definitionId = \"/definitions/\" + definitionName;\n    validateRequiredPropertiesExist(definition, definitionId);\n  }\n}\n\n/**\n * Validates the given path.\n *\n * @param {SwaggerObject} api           - The entire Swagger API object\n * @param {object}        path          - A Path object, from the Swagger API\n * @param {string}        pathId        - A value that uniquely identifies the path\n * @param {string}        operationIds  - An array of collected operationIds found in other paths\n */\nfunction validatePath (api, path, pathId, operationIds) {\n  for (let operationName of swaggerMethods) {\n    let operation = path[operationName];\n    let operationId = pathId + \"/\" + operationName;\n\n    if (operation) {\n      let declaredOperationId = operation.operationId;\n      if (declaredOperationId) {\n        if (operationIds.indexOf(declaredOperationId) === -1) {\n          operationIds.push(declaredOperationId);\n        }\n        else {\n          throw ono.syntax(`Validation failed. Duplicate operation id '${declaredOperationId}'`);\n        }\n      }\n      validateParameters(api, path, pathId, operation, operationId);\n\n      let responses = Object.keys(operation.responses || {});\n      for (let responseName of responses) {\n        let response = operation.responses[responseName];\n        let responseId = operationId + \"/responses/\" + responseName;\n        validateResponse(responseName, (response || {}), responseId);\n      }\n    }\n  }\n}\n\n/**\n * Validates the parameters for the given operation.\n *\n * @param {SwaggerObject} api           - The entire Swagger API object\n * @param {object}        path          - A Path object, from the Swagger API\n * @param {string}        pathId        - A value that uniquely identifies the path\n * @param {object}        operation     - An Operation object, from the Swagger API\n * @param {string}        operationId   - A value that uniquely identifies the operation\n */\nfunction validateParameters (api, path, pathId, operation, operationId) {\n  let pathParams = path.parameters || [];\n  let operationParams = operation.parameters || [];\n\n  // Check for duplicate path parameters\n  try {\n    checkForDuplicates(pathParams);\n  }\n  catch (e) {\n    throw ono.syntax(e, `Validation failed. ${pathId} has duplicate parameters`);\n  }\n\n  // Check for duplicate operation parameters\n  try {\n    checkForDuplicates(operationParams);\n  }\n  catch (e) {\n    throw ono.syntax(e, `Validation failed. ${operationId} has duplicate parameters`);\n  }\n\n  // Combine the path and operation parameters,\n  // with the operation params taking precedence over the path params\n  let params = pathParams.reduce((combinedParams, value) => {\n    let duplicate = combinedParams.some((param) => {\n      return param.in === value.in && param.name === value.name;\n    });\n    if (!duplicate) {\n      combinedParams.push(value);\n    }\n    return combinedParams;\n  }, operationParams.slice());\n\n  validateBodyParameters(params, operationId);\n  validatePathParameters(params, pathId, operationId);\n  validateParameterTypes(params, api, operation, operationId);\n}\n\n/**\n * Validates body and formData parameters for the given operation.\n *\n * @param   {object[]}  params       -  An array of Parameter objects\n * @param   {string}    operationId  -  A value that uniquely identifies the operation\n */\nfunction validateBodyParameters (params, operationId) {\n  let bodyParams = params.filter((param) => { return param.in === \"body\"; });\n  let formParams = params.filter((param) => { return param.in === \"formData\"; });\n\n  // There can only be one \"body\" parameter\n  if (bodyParams.length > 1) {\n    throw ono.syntax(\n      `Validation failed. ${operationId} has ${bodyParams.length} body parameters. Only one is allowed.`,\n    );\n  }\n  else if (bodyParams.length > 0 && formParams.length > 0) {\n    // \"body\" params and \"formData\" params are mutually exclusive\n    throw ono.syntax(\n      `Validation failed. ${operationId} has body parameters and formData parameters. Only one or the other is allowed.`,\n    );\n  }\n}\n\n/**\n * Validates path parameters for the given path.\n *\n * @param   {object[]}  params        - An array of Parameter objects\n * @param   {string}    pathId        - A value that uniquely identifies the path\n * @param   {string}    operationId   - A value that uniquely identifies the operation\n */\nfunction validatePathParameters (params, pathId, operationId) {\n  // Find all {placeholders} in the path string\n  let placeholders = pathId.match(util.swaggerParamRegExp) || [];\n\n  // Check for duplicates\n  for (let i = 0; i < placeholders.length; i++) {\n    for (let j = i + 1; j < placeholders.length; j++) {\n      if (placeholders[i] === placeholders[j]) {\n        throw ono.syntax(\n          `Validation failed. ${operationId} has multiple path placeholders named ${placeholders[i]}`);\n      }\n    }\n  }\n\n  params = params.filter((param) => { return param.in === \"path\"; });\n\n  for (let param of params) {\n    if (param.required !== true) {\n      throw ono.syntax(\n        \"Validation failed. Path parameters cannot be optional. \" +\n        `Set required=true for the \"${param.name}\" parameter at ${operationId}`,\n      );\n    }\n    let match = placeholders.indexOf(\"{\" + param.name + \"}\");\n    if (match === -1) {\n      throw ono.syntax(\n        `Validation failed. ${operationId} has a path parameter named \"${param.name}\", ` +\n        `but there is no corresponding {${param.name}} in the path string`\n      );\n    }\n    placeholders.splice(match, 1);\n  }\n\n  if (placeholders.length > 0) {\n    throw ono.syntax(`Validation failed. ${operationId} is missing path parameter(s) for ${placeholders}`);\n  }\n}\n\n/**\n * Validates data types of parameters for the given operation.\n *\n * @param   {object[]}  params       -  An array of Parameter objects\n * @param   {object}    api          -  The entire Swagger API object\n * @param   {object}    operation    -  An Operation object, from the Swagger API\n * @param   {string}    operationId  -  A value that uniquely identifies the operation\n */\nfunction validateParameterTypes (params, api, operation, operationId) {\n  for (let param of params) {\n    let parameterId = operationId + \"/parameters/\" + param.name;\n    let schema, validTypes;\n\n    switch (param.in) {\n      case \"body\":\n        schema = param.schema;\n        validTypes = schemaTypes;\n        break;\n      case \"formData\":\n        schema = param;\n        validTypes = primitiveTypes.concat(\"file\");\n        break;\n      default:\n        schema = param;\n        validTypes = primitiveTypes;\n    }\n\n    validateSchema(schema, parameterId, validTypes);\n    validateRequiredPropertiesExist(schema, parameterId);\n\n    if (schema.type === \"file\") {\n      // \"file\" params must consume at least one of these MIME types\n      let formData = /multipart\\/(.*\\+)?form-data/;\n      let urlEncoded = /application\\/(.*\\+)?x-www-form-urlencoded/;\n\n      let consumes = operation.consumes || api.consumes || [];\n\n      let hasValidMimeType = consumes.some((consume) => {\n        return formData.test(consume) || urlEncoded.test(consume);\n      });\n\n      if (!hasValidMimeType) {\n        throw ono.syntax(\n          `Validation failed. ${operationId} has a file parameter, so it must consume multipart/form-data ` +\n          \"or application/x-www-form-urlencoded\",\n        );\n      }\n    }\n  }\n}\n\n/**\n * Checks the given parameter list for duplicates, and throws an error if found.\n *\n * @param   {object[]}  params  - An array of Parameter objects\n */\nfunction checkForDuplicates (params) {\n  for (let i = 0; i < params.length - 1; i++) {\n    let outer = params[i];\n    for (let j = i + 1; j < params.length; j++) {\n      let inner = params[j];\n      if (outer.name === inner.name && outer.in === inner.in) {\n        throw ono.syntax(`Validation failed. Found multiple ${outer.in} parameters named \"${outer.name}\"`);\n      }\n    }\n  }\n}\n\n/**\n * Validates the given response object.\n *\n * @param   {string}    code        -  The HTTP response code (or \"default\")\n * @param   {object}    response    -  A Response object, from the Swagger API\n * @param   {string}    responseId  -  A value that uniquely identifies the response\n */\nfunction validateResponse (code, response, responseId) {\n  if (code !== \"default\" && (code < 100 || code > 599)) {\n    throw ono.syntax(`Validation failed. ${responseId} has an invalid response code (${code})`);\n  }\n\n  let headers = Object.keys(response.headers || {});\n  for (let headerName of headers) {\n    let header = response.headers[headerName];\n    let headerId = responseId + \"/headers/\" + headerName;\n    validateSchema(header, headerId, primitiveTypes);\n  }\n\n  if (response.schema) {\n    let validTypes = schemaTypes.concat(\"file\");\n    if (validTypes.indexOf(response.schema.type) === -1) {\n      throw ono.syntax(\n        `Validation failed. ${responseId} has an invalid response schema type (${response.schema.type})`);\n    }\n    else {\n      validateSchema(response.schema, responseId + \"/schema\", validTypes);\n    }\n  }\n}\n\n/**\n * Validates the given Swagger schema object.\n *\n * @param {object}    schema      - A Schema object, from the Swagger API\n * @param {string}    schemaId    - A value that uniquely identifies the schema object\n * @param {string[]}  validTypes  - An array of the allowed schema types\n */\nfunction validateSchema (schema, schemaId, validTypes) {\n  if (validTypes.indexOf(schema.type) === -1) {\n    throw ono.syntax(\n      `Validation failed. ${schemaId} has an invalid type (${schema.type})`);\n  }\n\n  if (schema.type === \"array\" && !schema.items) {\n    throw ono.syntax(`Validation failed. ${schemaId} is an array, so it must include an \"items\" schema`);\n  }\n}\n\n/**\n * Validates that the declared properties of the given Swagger schema object actually exist.\n *\n * @param {object}    schema      - A Schema object, from the Swagger API\n * @param {string}    schemaId    - A value that uniquely identifies the schema object\n */\nfunction validateRequiredPropertiesExist (schema, schemaId) {\n  /**\n   * Recursively collects all properties of the schema and its ancestors. They are added to the props object.\n   */\n  function collectProperties (schemaObj, props) {\n    if (schemaObj.properties) {\n      for (let property in schemaObj.properties) {\n        if (schemaObj.properties.hasOwnProperty(property)) {\n          props[property] = schemaObj.properties[property];\n        }\n      }\n    }\n    if (schemaObj.allOf) {\n      for (let parent of schemaObj.allOf) {\n        collectProperties(parent, props);\n      }\n    }\n  }\n\n  if (schema.required && Array.isArray(schema.required)) {\n    let props = {};\n    collectProperties(schema, props);\n    for (let requiredProperty of schema.required) {\n      if (!props[requiredProperty]) {\n        throw ono.syntax(\n          `Validation failed. Property '${requiredProperty}' listed as required but does not exist in '${schemaId}'`\n        );\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}