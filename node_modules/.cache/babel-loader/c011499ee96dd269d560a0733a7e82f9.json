{"ast":null,"code":"const querystring = require('querystring');\n\nconst extensions = require('@readme/oas-extensions');\n\nconst {\n  findSchemaDefinition,\n  getSchema,\n  parametersToJsonSchema\n} = require('@readme/oas-tooling/utils');\n\nconst {\n  Operation\n} = require('@readme/oas-tooling');\n\nconst configureSecurity = require('./lib/configure-security');\n\nconst removeUndefinedObjects = require('./lib/remove-undefined-objects');\n\nfunction formatter(values, param, type, onlyIfExists) {\n  if (typeof values[type][param.name] !== 'undefined') {\n    return values[type][param.name];\n  }\n\n  if (onlyIfExists && !param.required) {\n    return undefined;\n  }\n\n  if (param.required && param.example) {\n    return param.example;\n  }\n\n  return param.name;\n}\n\nconst defaultFormDataTypes = Object.keys(parametersToJsonSchema.types).reduce((prev, curr) => {\n  return Object.assign(prev, {\n    [curr]: {}\n  });\n}, {});\n\nfunction getResponseContentType(content) {\n  const types = Object.keys(content) || [];\n  let type = 'application/json';\n\n  if (types && types.length) {\n    type = types[0];\n  }\n\n  return type;\n}\n\nfunction isPrimitive(val) {\n  return typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean';\n}\n\nmodule.exports = (oas, operationSchema = {\n  path: '',\n  method: ''\n}, values = {}, auth = {}, opts = {\n  proxyUrl: false\n}) => {\n  let operation = operationSchema;\n\n  if (!(operationSchema instanceof Operation)) {\n    operation = new Operation(oas, operationSchema.path, operationSchema.method, operationSchema);\n  }\n\n  const formData = { ...defaultFormDataTypes,\n    ...values\n  };\n  const har = {\n    headers: [],\n    queryString: [],\n    postData: {},\n    method: operation.method.toUpperCase(),\n    url: `${oas.url()}${operation.path}`.replace(/\\s/g, '%20')\n  }; // TODO look to move this to Oas class as well\n\n  if (oas[extensions.PROXY_ENABLED] && opts.proxyUrl) {\n    har.url = `https://try.readme.io/${har.url}`;\n  } // Does this operation have any parameters?\n\n\n  const parameters = [];\n\n  function addParameter(param) {\n    if (param.$ref) {\n      parameters.push(findSchemaDefinition(param.$ref, oas));\n    } else {\n      parameters.push(param);\n    }\n  }\n\n  if (operation.parameters) {\n    operation.parameters.forEach(addParameter);\n  } // Does this operation have any common parameters?\n\n\n  if (oas.paths && oas.paths[operation.path] && oas.paths[operation.path].parameters) {\n    oas.paths[operation.path].parameters.forEach(addParameter);\n  }\n\n  har.url = har.url.replace(/{([-_a-zA-Z0-9[\\]]+)}/g, (full, key) => {\n    if (!operation || !parameters) return key; // No path params at all\n    // Find the path parameter or set a default value if it does not exist\n\n    const parameter = parameters.find(param => param.name === key) || {\n      name: key\n    };\n    return encodeURIComponent(formatter(formData, parameter, 'path'));\n  });\n  const queryStrings = parameters && parameters.filter(param => param.in === 'query');\n\n  if (queryStrings && queryStrings.length) {\n    queryStrings.forEach(queryString => {\n      const value = formatter(formData, queryString, 'query', true);\n      if (typeof value === 'undefined') return;\n      har.queryString.push({\n        name: queryString.name,\n        value: String(value)\n      });\n    });\n  } // Does this response have any documented content types?\n\n\n  if (operation.responses) {\n    Object.keys(operation.responses).some(response => {\n      if (!operation.responses[response].content) return false; // if there is an Accept header specified in the form, we'll use that instead.\n\n      if (formData.header.Accept) return true;\n      har.headers.push({\n        name: 'Accept',\n        value: getResponseContentType(operation.responses[response].content)\n      });\n      return true;\n    });\n  } // Do we have any `header` parameters on the operation?\n\n\n  let hasContentType = false;\n  const headers = parameters && parameters.filter(param => param.in === 'header');\n\n  if (headers && headers.length) {\n    headers.forEach(header => {\n      const value = formatter(formData, header, 'header', true);\n      if (typeof value === 'undefined') return;\n\n      if (header.name.toLowerCase() === 'content-type') {\n        hasContentType = true;\n      }\n\n      har.headers.push({\n        name: header.name,\n        value: String(value)\n      });\n    });\n  } // Are there `x-static` static headers configured for this OAS?\n\n\n  if (oas[extensions.HEADERS]) {\n    oas[extensions.HEADERS].forEach(header => {\n      if (header.key.toLowerCase() === 'content-type') {\n        hasContentType = true;\n      }\n\n      har.headers.push({\n        name: header.key,\n        value: String(header.value)\n      });\n    });\n  } // Do we have an `Accept` header set up in the form, but it hasn't been added yet?\n\n\n  if (formData.header && formData.header.Accept && har.headers.find(hdr => hdr.name === 'Accept') === undefined) {\n    har.headers.push({\n      name: 'Accept',\n      value: String(formData.header.Accept)\n    });\n  }\n\n  const schema = getSchema(operation, oas) || {\n    schema: {}\n  };\n\n  function stringify(json) {\n    // Default to JSON.stringify\n    return JSON.stringify(removeUndefinedObjects(typeof json.RAW_BODY !== 'undefined' ? json.RAW_BODY : json));\n  }\n\n  if (schema.schema && Object.keys(schema.schema).length) {\n    // If there is formData, then the type is application/x-www-form-urlencoded\n    if (Object.keys(formData.formData).length) {\n      har.postData.text = querystring.stringify(formData.formData); // formData.body can be one of the following:\n      // - `undefined` - if the form hasn't been touched yet because of formData.body on:\n      // https://github.com/readmeio/api-explorer/blob/b32a2146737c11813bd1b222a137de61854414b3/packages/api-explorer/src/Doc.jsx#L28\n      // - a primitive type\n      // - an object\n    } else if (typeof formData.body !== 'undefined' && (isPrimitive(formData.body) || Object.keys(formData.body).length)) {\n      try {\n        // Find all `{ type: string, format: json }` properties in the schema\n        // because we need to manually JSON.parse them before submit, otherwise\n        // they'll be escaped instead of actual objects\n        const jsonTypes = Object.keys(schema.schema.properties).filter(key => schema.schema.properties[key].format === 'json');\n\n        if (jsonTypes.length) {\n          // We have to clone the body object, otherwise the form\n          // will attempt to re-render with an object, which will\n          // cause it to error!\n          let cloned = removeUndefinedObjects(JSON.parse(JSON.stringify(formData.body)));\n          jsonTypes.forEach(prop => {\n            // Attempt to JSON parse each of the json properties\n            // if this errors, it'll just get caught and stringify it normally\n            cloned[prop] = JSON.parse(cloned[prop]);\n          });\n\n          if (typeof cloned.RAW_BODY !== 'undefined') {\n            cloned = cloned.RAW_BODY;\n          }\n\n          har.postData.text = JSON.stringify(cloned);\n        } else {\n          har.postData.text = stringify(formData.body);\n        }\n      } catch (e) {\n        // If anything goes wrong in the above, assume that it's invalid JSON\n        // and stringify it\n        har.postData.text = stringify(formData.body);\n      }\n    }\n  } // Add a `Content-Type` header if there are any body values setup above or if there is a schema defined, but only do\n  // so if we don't already have a `Content-Type` present as it's impossible for a request to have multiple.\n\n\n  if ((har.postData.text || Object.keys(schema.schema).length) && !hasContentType) {\n    const type = operation.getContentType();\n    har.headers.push({\n      name: 'Content-Type',\n      value: type\n    });\n  }\n\n  const securityRequirements = operation.security || oas.security;\n\n  if (securityRequirements && securityRequirements.length) {\n    // TODO pass these values through the formatter?\n    securityRequirements.forEach(schemes => {\n      Object.keys(schemes).forEach(security => {\n        const securityValue = configureSecurity(oas, auth, security);\n\n        if (!securityValue) {\n          return;\n        }\n\n        har[securityValue.type].push(securityValue.value);\n      });\n    });\n  }\n\n  return {\n    log: {\n      entries: [{\n        request: har\n      }]\n    }\n  };\n};","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@readme/oas-to-har/src/index.js"],"names":["querystring","require","extensions","findSchemaDefinition","getSchema","parametersToJsonSchema","Operation","configureSecurity","removeUndefinedObjects","formatter","values","param","type","onlyIfExists","name","required","undefined","example","defaultFormDataTypes","Object","keys","types","reduce","prev","curr","assign","getResponseContentType","content","length","isPrimitive","val","module","exports","oas","operationSchema","path","method","auth","opts","proxyUrl","operation","formData","har","headers","queryString","postData","toUpperCase","url","replace","PROXY_ENABLED","parameters","addParameter","$ref","push","forEach","paths","full","key","parameter","find","encodeURIComponent","queryStrings","filter","in","value","String","responses","some","response","header","Accept","hasContentType","toLowerCase","HEADERS","hdr","schema","stringify","json","JSON","RAW_BODY","text","body","jsonTypes","properties","format","cloned","parse","prop","e","getContentType","securityRequirements","security","schemes","securityValue","log","entries","request"],"mappings":"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","sourcesContent":["const querystring = require('querystring');\nconst extensions = require('@readme/oas-extensions');\nconst { findSchemaDefinition, getSchema, parametersToJsonSchema } = require('@readme/oas-tooling/utils');\nconst { Operation } = require('@readme/oas-tooling');\n\nconst configureSecurity = require('./lib/configure-security');\nconst removeUndefinedObjects = require('./lib/remove-undefined-objects');\n\nfunction formatter(values, param, type, onlyIfExists) {\n  if (typeof values[type][param.name] !== 'undefined') {\n    return values[type][param.name];\n  }\n\n  if (onlyIfExists && !param.required) {\n    return undefined;\n  }\n\n  if (param.required && param.example) {\n    return param.example;\n  }\n\n  return param.name;\n}\n\nconst defaultFormDataTypes = Object.keys(parametersToJsonSchema.types).reduce((prev, curr) => {\n  return Object.assign(prev, { [curr]: {} });\n}, {});\n\nfunction getResponseContentType(content) {\n  const types = Object.keys(content) || [];\n\n  let type = 'application/json';\n  if (types && types.length) {\n    type = types[0];\n  }\n\n  return type;\n}\n\nfunction isPrimitive(val) {\n  return typeof val === 'string' || typeof val === 'number' || typeof val === 'boolean';\n}\n\nmodule.exports = (\n  oas,\n  operationSchema = { path: '', method: '' },\n  values = {},\n  auth = {},\n  opts = { proxyUrl: false }\n) => {\n  let operation = operationSchema;\n  if (!(operationSchema instanceof Operation)) {\n    operation = new Operation(oas, operationSchema.path, operationSchema.method, operationSchema);\n  }\n\n  const formData = { ...defaultFormDataTypes, ...values };\n  const har = {\n    headers: [],\n    queryString: [],\n    postData: {},\n    method: operation.method.toUpperCase(),\n    url: `${oas.url()}${operation.path}`.replace(/\\s/g, '%20'),\n  };\n\n  // TODO look to move this to Oas class as well\n  if (oas[extensions.PROXY_ENABLED] && opts.proxyUrl) {\n    har.url = `https://try.readme.io/${har.url}`;\n  }\n\n  // Does this operation have any parameters?\n  const parameters = [];\n  function addParameter(param) {\n    if (param.$ref) {\n      parameters.push(findSchemaDefinition(param.$ref, oas));\n    } else {\n      parameters.push(param);\n    }\n  }\n\n  if (operation.parameters) {\n    operation.parameters.forEach(addParameter);\n  }\n\n  // Does this operation have any common parameters?\n  if (oas.paths && oas.paths[operation.path] && oas.paths[operation.path].parameters) {\n    oas.paths[operation.path].parameters.forEach(addParameter);\n  }\n\n  har.url = har.url.replace(/{([-_a-zA-Z0-9[\\]]+)}/g, (full, key) => {\n    if (!operation || !parameters) return key; // No path params at all\n\n    // Find the path parameter or set a default value if it does not exist\n    const parameter = parameters.find(param => param.name === key) || { name: key };\n\n    return encodeURIComponent(formatter(formData, parameter, 'path'));\n  });\n\n  const queryStrings = parameters && parameters.filter(param => param.in === 'query');\n  if (queryStrings && queryStrings.length) {\n    queryStrings.forEach(queryString => {\n      const value = formatter(formData, queryString, 'query', true);\n      if (typeof value === 'undefined') return;\n\n      har.queryString.push({\n        name: queryString.name,\n        value: String(value),\n      });\n    });\n  }\n\n  // Does this response have any documented content types?\n  if (operation.responses) {\n    Object.keys(operation.responses).some(response => {\n      if (!operation.responses[response].content) return false;\n\n      // if there is an Accept header specified in the form, we'll use that instead.\n      if (formData.header.Accept) return true;\n\n      har.headers.push({\n        name: 'Accept',\n        value: getResponseContentType(operation.responses[response].content),\n      });\n\n      return true;\n    });\n  }\n\n  // Do we have any `header` parameters on the operation?\n  let hasContentType = false;\n  const headers = parameters && parameters.filter(param => param.in === 'header');\n  if (headers && headers.length) {\n    headers.forEach(header => {\n      const value = formatter(formData, header, 'header', true);\n      if (typeof value === 'undefined') return;\n\n      if (header.name.toLowerCase() === 'content-type') {\n        hasContentType = true;\n      }\n\n      har.headers.push({\n        name: header.name,\n        value: String(value),\n      });\n    });\n  }\n\n  // Are there `x-static` static headers configured for this OAS?\n  if (oas[extensions.HEADERS]) {\n    oas[extensions.HEADERS].forEach(header => {\n      if (header.key.toLowerCase() === 'content-type') {\n        hasContentType = true;\n      }\n\n      har.headers.push({\n        name: header.key,\n        value: String(header.value),\n      });\n    });\n  }\n\n  // Do we have an `Accept` header set up in the form, but it hasn't been added yet?\n  if (formData.header && formData.header.Accept && har.headers.find(hdr => hdr.name === 'Accept') === undefined) {\n    har.headers.push({\n      name: 'Accept',\n      value: String(formData.header.Accept),\n    });\n  }\n\n  const schema = getSchema(operation, oas) || { schema: {} };\n\n  function stringify(json) {\n    // Default to JSON.stringify\n    return JSON.stringify(removeUndefinedObjects(typeof json.RAW_BODY !== 'undefined' ? json.RAW_BODY : json));\n  }\n\n  if (schema.schema && Object.keys(schema.schema).length) {\n    // If there is formData, then the type is application/x-www-form-urlencoded\n    if (Object.keys(formData.formData).length) {\n      har.postData.text = querystring.stringify(formData.formData);\n      // formData.body can be one of the following:\n      // - `undefined` - if the form hasn't been touched yet because of formData.body on:\n      // https://github.com/readmeio/api-explorer/blob/b32a2146737c11813bd1b222a137de61854414b3/packages/api-explorer/src/Doc.jsx#L28\n      // - a primitive type\n      // - an object\n    } else if (\n      typeof formData.body !== 'undefined' &&\n      (isPrimitive(formData.body) || Object.keys(formData.body).length)\n    ) {\n      try {\n        // Find all `{ type: string, format: json }` properties in the schema\n        // because we need to manually JSON.parse them before submit, otherwise\n        // they'll be escaped instead of actual objects\n        const jsonTypes = Object.keys(schema.schema.properties).filter(\n          key => schema.schema.properties[key].format === 'json'\n        );\n\n        if (jsonTypes.length) {\n          // We have to clone the body object, otherwise the form\n          // will attempt to re-render with an object, which will\n          // cause it to error!\n          let cloned = removeUndefinedObjects(JSON.parse(JSON.stringify(formData.body)));\n          jsonTypes.forEach(prop => {\n            // Attempt to JSON parse each of the json properties\n            // if this errors, it'll just get caught and stringify it normally\n            cloned[prop] = JSON.parse(cloned[prop]);\n          });\n\n          if (typeof cloned.RAW_BODY !== 'undefined') {\n            cloned = cloned.RAW_BODY;\n          }\n\n          har.postData.text = JSON.stringify(cloned);\n        } else {\n          har.postData.text = stringify(formData.body);\n        }\n      } catch (e) {\n        // If anything goes wrong in the above, assume that it's invalid JSON\n        // and stringify it\n        har.postData.text = stringify(formData.body);\n      }\n    }\n  }\n\n  // Add a `Content-Type` header if there are any body values setup above or if there is a schema defined, but only do\n  // so if we don't already have a `Content-Type` present as it's impossible for a request to have multiple.\n  if ((har.postData.text || Object.keys(schema.schema).length) && !hasContentType) {\n    const type = operation.getContentType();\n\n    har.headers.push({\n      name: 'Content-Type',\n      value: type,\n    });\n  }\n\n  const securityRequirements = operation.security || oas.security;\n\n  if (securityRequirements && securityRequirements.length) {\n    // TODO pass these values through the formatter?\n    securityRequirements.forEach(schemes => {\n      Object.keys(schemes).forEach(security => {\n        const securityValue = configureSecurity(oas, auth, security);\n        if (!securityValue) {\n          return;\n        }\n\n        har[securityValue.type].push(securityValue.value);\n      });\n    });\n  }\n\n  return { log: { entries: [{ request: har }] } };\n};\n"]},"metadata":{},"sourceType":"script"}