{"ast":null,"code":"\"use strict\";\n\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 100,\n\n  /**\n   * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that match will be tried, in order, until one successfully parses the file.\n   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n   * every parser will be tried.\n   *\n   * @type {RegExp|string[]|function}\n   */\n  canParse: \".json\",\n\n  /**\n   * Parses the given file as JSON\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {Promise}\n   */\n  parse(file) {\n    return new Promise((resolve, reject) => {\n      let data = file.data;\n\n      if (Buffer.isBuffer(data)) {\n        data = data.toString();\n      }\n\n      if (typeof data === \"string\") {\n        if (data.trim().length === 0) {\n          resolve(undefined); // This mirrors the YAML behavior\n        } else {\n          resolve(JSON.parse(data));\n        }\n      } else {\n        // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n        resolve(data);\n      }\n    });\n  }\n\n};","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@apidevtools/swagger-parser/node_modules/@apidevtools/json-schema-ref-parser/lib/parsers/json.js"],"names":["module","exports","order","allowEmpty","canParse","parse","file","Promise","resolve","reject","data","Buffer","isBuffer","toString","trim","length","undefined","JSON"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiB;AACf;;;;;AAKAC,EAAAA,KAAK,EAAE,GANQ;;AAQf;;;;;AAKAC,EAAAA,UAAU,EAAE,IAbG;;AAef;;;;;;;;AAQAC,EAAAA,QAAQ,EAAE,OAvBK;;AAyBf;;;;;;;;;AASAC,EAAAA,KAAK,CAAEC,IAAF,EAAQ;AACX,WAAO,IAAIC,OAAJ,CAAa,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACvC,UAAIC,IAAI,GAAGJ,IAAI,CAACI,IAAhB;;AACA,UAAIC,MAAM,CAACC,QAAP,CAAgBF,IAAhB,CAAJ,EAA2B;AACzBA,QAAAA,IAAI,GAAGA,IAAI,CAACG,QAAL,EAAP;AACD;;AAED,UAAI,OAAOH,IAAP,KAAgB,QAApB,EAA8B;AAC5B,YAAIA,IAAI,CAACI,IAAL,GAAYC,MAAZ,KAAuB,CAA3B,EAA8B;AAC5BP,UAAAA,OAAO,CAACQ,SAAD,CAAP,CAD4B,CACP;AACtB,SAFD,MAGK;AACHR,UAAAA,OAAO,CAACS,IAAI,CAACZ,KAAL,CAAWK,IAAX,CAAD,CAAP;AACD;AACF,OAPD,MAQK;AACH;AACAF,QAAAA,OAAO,CAACE,IAAD,CAAP;AACD;AACF,KAlBM,CAAP;AAmBD;;AAtDc,CAAjB","sourcesContent":["\"use strict\";\n\nmodule.exports = {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   *\n   * @type {number}\n   */\n  order: 100,\n\n  /**\n   * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n   *\n   * @type {boolean}\n   */\n  allowEmpty: true,\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that match will be tried, in order, until one successfully parses the file.\n   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n   * every parser will be tried.\n   *\n   * @type {RegExp|string[]|function}\n   */\n  canParse: \".json\",\n\n  /**\n   * Parses the given file as JSON\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns {Promise}\n   */\n  parse (file) {\n    return new Promise(((resolve, reject) => {\n      let data = file.data;\n      if (Buffer.isBuffer(data)) {\n        data = data.toString();\n      }\n\n      if (typeof data === \"string\") {\n        if (data.trim().length === 0) {\n          resolve(undefined);  // This mirrors the YAML behavior\n        }\n        else {\n          resolve(JSON.parse(data));\n        }\n      }\n      else {\n        // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n        resolve(data);\n      }\n    }));\n  }\n};\n"]},"metadata":{},"sourceType":"script"}