{"ast":null,"code":"const fetch = require('node-fetch');\n\nconst fetchHar = require('fetch-har');\n\nconst Oas = require('@readme/oas-tooling');\n\nconst oasToHar = require('@readme/oas-to-har');\n\nconst Cache = require('./cache');\n\nconst {\n  prepareAuth,\n  prepareParams\n} = require('./lib/index');\n\nglobal.fetch = fetch;\nglobal.Request = fetch.Request;\nglobal.Headers = fetch.Headers;\n\nclass Sdk {\n  constructor(uri) {\n    this.uri = uri;\n  }\n\n  static getOperations(spec) {\n    return Object.keys(spec.paths).map(path => {\n      return Object.keys(spec.paths[path]).map(method => {\n        return spec.operation(path, method);\n      });\n    }).reduce((prev, next) => prev.concat(next), []);\n  }\n\n  load() {\n    const authKeys = [];\n    const cache = new Cache(this.uri);\n    let isLoaded = false;\n    let isCached = cache.isCached();\n    let sdk = {};\n\n    function fetchOperation(spec, operation, body, metadata) {\n      const har = oasToHar(spec, operation, prepareParams(operation, body, metadata), prepareAuth(authKeys, operation));\n      return fetchHar(har);\n    }\n\n    function loadMethods(spec) {\n      const supportedVerbs = ['get', 'put', 'post', 'delete', 'options', 'head', 'patch', 'trace'];\n      return supportedVerbs.map(name => {\n        return {\n          [name]: ((method, path, ...args) => {\n            const operation = spec.operation(path, method);\n            return fetchOperation(spec, operation, ...args);\n          }).bind(null, name)\n        };\n      }).reduce((prev, next) => Object.assign(prev, next));\n    }\n\n    function loadOperations(spec) {\n      return Sdk.getOperations(spec).filter(operation => operation.operationId).reduce((prev, next) => {\n        return Object.assign(prev, {\n          [next.operationId]: ((operation, ...args) => {\n            return fetchOperation(spec, operation, ...args);\n          }).bind(null, next)\n        });\n      }, {});\n    }\n\n    async function loadFromCache() {\n      let cachedSpec;\n\n      if (isCached) {\n        cachedSpec = await cache.get();\n      } else {\n        cachedSpec = await cache.load();\n        isCached = true;\n      }\n\n      const spec = new Oas(cachedSpec);\n      sdk = Object.assign(sdk, { ...loadMethods(spec),\n        ...loadOperations(spec)\n      });\n      isLoaded = true;\n    }\n\n    const sdkProxy = {\n      get(target, method) {\n        // Since auth returns a self-proxy, we **do not** want it to fall through into the async function below as when\n        // that'll happen, instead of returning a self-proxy, it'll end up returning a Promise. When that happens,\n        // chaining `sdk.auth().operationId()` will fail.\n        if (method === 'auth') {\n          return function (...args) {\n            return target[method].apply(this, args);\n          };\n        }\n\n        return async function (...args) {\n          if (!(method in target)) {\n            // If this method doesn't exist on the proxy (SDK), have we loaded the SDK? If we have, then this method\n            // isn't valid.\n            if (isLoaded) {\n              throw new Error(`Sorry, \\`${method}\\` does not appear to be a valid operation on this API.`);\n            }\n\n            await loadFromCache(); // If after loading the SDK and this method still doesn't exist, then it's not real!\n\n            if (!(method in sdk)) {\n              throw new Error(`Sorry, \\`${method}\\` does not appear to be a valid operation on this API.`);\n            }\n\n            return sdk[method].apply(this, args);\n          }\n\n          return target[method].apply(this, args);\n        };\n      }\n\n    };\n    sdk = {\n      auth: (...values) => {\n        authKeys.push(values);\n        return new Proxy(sdk, sdkProxy);\n      }\n    };\n    return new Proxy(sdk, sdkProxy);\n  }\n\n}\n\nmodule.exports = uri => {\n  return new Sdk(uri).load();\n};","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/api/src/index.js"],"names":["fetch","require","fetchHar","Oas","oasToHar","Cache","prepareAuth","prepareParams","global","Request","Headers","Sdk","constructor","uri","getOperations","spec","Object","keys","paths","map","path","method","operation","reduce","prev","next","concat","load","authKeys","cache","isLoaded","isCached","sdk","fetchOperation","body","metadata","har","loadMethods","supportedVerbs","name","args","bind","assign","loadOperations","filter","operationId","loadFromCache","cachedSpec","get","sdkProxy","target","apply","Error","auth","values","push","Proxy","module","exports"],"mappings":"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","sourcesContent":["const fetch = require('node-fetch');\nconst fetchHar = require('fetch-har');\nconst Oas = require('@readme/oas-tooling');\nconst oasToHar = require('@readme/oas-to-har');\n\nconst Cache = require('./cache');\nconst { prepareAuth, prepareParams } = require('./lib/index');\n\nglobal.fetch = fetch;\nglobal.Request = fetch.Request;\nglobal.Headers = fetch.Headers;\n\nclass Sdk {\n  constructor(uri) {\n    this.uri = uri;\n  }\n\n  static getOperations(spec) {\n    return Object.keys(spec.paths)\n      .map(path => {\n        return Object.keys(spec.paths[path]).map(method => {\n          return spec.operation(path, method);\n        });\n      })\n      .reduce((prev, next) => prev.concat(next), []);\n  }\n\n  load() {\n    const authKeys = [];\n    const cache = new Cache(this.uri);\n\n    let isLoaded = false;\n    let isCached = cache.isCached();\n    let sdk = {};\n\n    function fetchOperation(spec, operation, body, metadata) {\n      const har = oasToHar(spec, operation, prepareParams(operation, body, metadata), prepareAuth(authKeys, operation));\n\n      return fetchHar(har);\n    }\n\n    function loadMethods(spec) {\n      const supportedVerbs = ['get', 'put', 'post', 'delete', 'options', 'head', 'patch', 'trace'];\n\n      return supportedVerbs\n        .map(name => {\n          return {\n            [name]: ((method, path, ...args) => {\n              const operation = spec.operation(path, method);\n              return fetchOperation(spec, operation, ...args);\n            }).bind(null, name),\n          };\n        })\n        .reduce((prev, next) => Object.assign(prev, next));\n    }\n\n    function loadOperations(spec) {\n      return Sdk.getOperations(spec)\n        .filter(operation => operation.operationId)\n        .reduce((prev, next) => {\n          return Object.assign(prev, {\n            [next.operationId]: ((operation, ...args) => {\n              return fetchOperation(spec, operation, ...args);\n            }).bind(null, next),\n          });\n        }, {});\n    }\n\n    async function loadFromCache() {\n      let cachedSpec;\n      if (isCached) {\n        cachedSpec = await cache.get();\n      } else {\n        cachedSpec = await cache.load();\n        isCached = true;\n      }\n\n      const spec = new Oas(cachedSpec);\n\n      sdk = Object.assign(sdk, {\n        ...loadMethods(spec),\n        ...loadOperations(spec),\n      });\n\n      isLoaded = true;\n    }\n\n    const sdkProxy = {\n      get(target, method) {\n        // Since auth returns a self-proxy, we **do not** want it to fall through into the async function below as when\n        // that'll happen, instead of returning a self-proxy, it'll end up returning a Promise. When that happens,\n        // chaining `sdk.auth().operationId()` will fail.\n        if (method === 'auth') {\n          return function (...args) {\n            return target[method].apply(this, args);\n          };\n        }\n\n        return async function (...args) {\n          if (!(method in target)) {\n            // If this method doesn't exist on the proxy (SDK), have we loaded the SDK? If we have, then this method\n            // isn't valid.\n            if (isLoaded) {\n              throw new Error(`Sorry, \\`${method}\\` does not appear to be a valid operation on this API.`);\n            }\n\n            await loadFromCache();\n\n            // If after loading the SDK and this method still doesn't exist, then it's not real!\n            if (!(method in sdk)) {\n              throw new Error(`Sorry, \\`${method}\\` does not appear to be a valid operation on this API.`);\n            }\n\n            return sdk[method].apply(this, args);\n          }\n\n          return target[method].apply(this, args);\n        };\n      },\n    };\n\n    sdk = {\n      auth: (...values) => {\n        authKeys.push(values);\n        return new Proxy(sdk, sdkProxy);\n      },\n    };\n\n    return new Proxy(sdk, sdkProxy);\n  }\n}\n\nmodule.exports = uri => {\n  return new Sdk(uri).load();\n};\n"]},"metadata":{},"sourceType":"script"}