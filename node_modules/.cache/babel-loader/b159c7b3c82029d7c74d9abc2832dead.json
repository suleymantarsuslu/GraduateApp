{"ast":null,"code":"\"use strict\";\n\nconst $Ref = require(\"./ref\");\n\nconst Pointer = require(\"./pointer\");\n\nconst parse = require(\"./parse\");\n\nconst url = require(\"./util/url\");\n\nmodule.exports = resolveExternal;\n/**\n * Crawls the JSON schema, finds all external JSON references, and resolves their values.\n * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.\n *\n * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the schema have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\n\nfunction resolveExternal(parser, options) {\n  if (!options.resolve.external) {\n    // Nothing to resolve, so exit early\n    return Promise.resolve();\n  }\n\n  try {\n    // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);\n    let promises = crawl(parser.schema, parser.$refs._root$Ref.path + \"#\", parser.$refs, options);\n    return Promise.all(promises);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n/**\n * Recursively crawls the given value, and resolves any external JSON references.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise[]}\n * Returns an array of promises. There will be one promise for each JSON reference in `obj`.\n * If `obj` does not contain any JSON references, then the array will be empty.\n * If any of the JSON references point to files that contain additional JSON references,\n * then the corresponding promise will internally reference an array of promises.\n */\n\n\nfunction crawl(obj, path, $refs, options) {\n  let promises = [];\n\n  if (obj && typeof obj === \"object\") {\n    if ($Ref.isExternal$Ref(obj)) {\n      promises.push(resolve$Ref(obj, path, $refs, options));\n    } else {\n      for (let key of Object.keys(obj)) {\n        let keyPath = Pointer.join(path, key);\n        let value = obj[key];\n\n        if ($Ref.isExternal$Ref(value)) {\n          promises.push(resolve$Ref(value, keyPath, $refs, options));\n        } else {\n          promises = promises.concat(crawl(value, keyPath, $refs, options));\n        }\n      }\n    }\n  }\n\n  return promises;\n}\n/**\n * Resolves the given JSON Reference, and then crawls the resulting value.\n *\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the object have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\n\n\nasync function resolve$Ref($ref, path, $refs, options) {\n  // console.log('Resolving $ref pointer \"%s\" at %s', $ref.$ref, path);\n  let resolvedPath = url.resolve(path, $ref.$ref);\n  let withoutHash = url.stripHash(resolvedPath); // Do we already have this $ref?\n\n  $ref = $refs._$refs[withoutHash];\n\n  if ($ref) {\n    // We've already parsed this $ref, so use the existing value\n    return Promise.resolve($ref.value);\n  } // Parse the $referenced file/url\n\n\n  const result = await parse(resolvedPath, $refs, options); // Crawl the parsed value\n  // console.log('Resolving $ref pointers in %s', withoutHash);\n\n  let promises = crawl(result, withoutHash + \"#\", $refs, options);\n  return Promise.all(promises);\n}","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@apidevtools/swagger-parser/node_modules/@apidevtools/json-schema-ref-parser/lib/resolve-external.js"],"names":["$Ref","require","Pointer","parse","url","module","exports","resolveExternal","parser","options","resolve","external","Promise","promises","crawl","schema","$refs","_root$Ref","path","all","e","reject","obj","isExternal$Ref","push","resolve$Ref","key","Object","keys","keyPath","join","value","concat","$ref","resolvedPath","withoutHash","stripHash","_$refs","result"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst $Ref = require(\"./ref\");\nconst Pointer = require(\"./pointer\");\nconst parse = require(\"./parse\");\nconst url = require(\"./util/url\");\n\nmodule.exports = resolveExternal;\n\n/**\n * Crawls the JSON schema, finds all external JSON references, and resolves their values.\n * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.\n *\n * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the schema have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nfunction resolveExternal (parser, options) {\n  if (!options.resolve.external) {\n    // Nothing to resolve, so exit early\n    return Promise.resolve();\n  }\n\n  try {\n    // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);\n    let promises = crawl(parser.schema, parser.$refs._root$Ref.path + \"#\", parser.$refs, options);\n    return Promise.all(promises);\n  }\n  catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Recursively crawls the given value, and resolves any external JSON references.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise[]}\n * Returns an array of promises. There will be one promise for each JSON reference in `obj`.\n * If `obj` does not contain any JSON references, then the array will be empty.\n * If any of the JSON references point to files that contain additional JSON references,\n * then the corresponding promise will internally reference an array of promises.\n */\nfunction crawl (obj, path, $refs, options) {\n  let promises = [];\n\n  if (obj && typeof obj === \"object\") {\n    if ($Ref.isExternal$Ref(obj)) {\n      promises.push(resolve$Ref(obj, path, $refs, options));\n    }\n    else {\n      for (let key of Object.keys(obj)) {\n        let keyPath = Pointer.join(path, key);\n        let value = obj[key];\n\n        if ($Ref.isExternal$Ref(value)) {\n          promises.push(resolve$Ref(value, keyPath, $refs, options));\n        }\n        else {\n          promises = promises.concat(crawl(value, keyPath, $refs, options));\n        }\n      }\n    }\n  }\n\n  return promises;\n}\n\n/**\n * Resolves the given JSON Reference, and then crawls the resulting value.\n *\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the object have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nasync function resolve$Ref ($ref, path, $refs, options) {\n  // console.log('Resolving $ref pointer \"%s\" at %s', $ref.$ref, path);\n\n  let resolvedPath = url.resolve(path, $ref.$ref);\n  let withoutHash = url.stripHash(resolvedPath);\n\n  // Do we already have this $ref?\n  $ref = $refs._$refs[withoutHash];\n  if ($ref) {\n    // We've already parsed this $ref, so use the existing value\n    return Promise.resolve($ref.value);\n  }\n\n  // Parse the $referenced file/url\n  const result = await parse(resolvedPath, $refs, options);\n\n  // Crawl the parsed value\n  // console.log('Resolving $ref pointers in %s', withoutHash);\n  let promises = crawl(result, withoutHash + \"#\", $refs, options);\n\n  return Promise.all(promises);\n}\n"]},"metadata":{},"sourceType":"script"}