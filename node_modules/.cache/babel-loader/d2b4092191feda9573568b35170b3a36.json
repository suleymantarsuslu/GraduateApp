{"ast":null,"code":"\"use strict\";\n\nconst util = require(\"../util\");\n\nconst {\n  ono\n} = require(\"@jsdevtools/ono\");\n\nconst ZSchema = require(\"z-schema\");\n\nconst {\n  openapi\n} = require(\"@apidevtools/openapi-schemas\");\n\nmodule.exports = validateSchema;\nlet zSchema = initializeZSchema();\n/**\n * Validates the given Swagger API against the Swagger 2.0 or 3.0 schema.\n *\n * @param {SwaggerObject} api\n */\n\nfunction validateSchema(api) {\n  // Choose the appropriate schema (Swagger or OpenAPI)\n  let schema = api.swagger ? openapi.v2 : openapi.v3; // Validate against the schema\n\n  let isValid = zSchema.validate(api, schema);\n\n  if (!isValid) {\n    let err = zSchema.getLastError();\n    let message = \"Swagger schema validation failed. \\n\" + formatZSchemaError(err.details);\n    throw ono.syntax(err, {\n      details: err.details\n    }, message);\n  }\n}\n/**\n * Performs one-time initialization logic to prepare for Swagger Schema validation.\n */\n\n\nfunction initializeZSchema() {\n  // HACK: Delete the OpenAPI schema IDs because ZSchema can't resolve them\n  delete openapi.v2.id;\n  delete openapi.v3.id; // The OpenAPI 3.0 schema uses \"uri-reference\" formats.\n  // Assume that any non-whitespace string is valid.\n\n  ZSchema.registerFormat(\"uri-reference\", value => value.trim().length > 0); // Configure ZSchema\n\n  return new ZSchema({\n    breakOnFirstError: true,\n    noExtraKeywords: true,\n    ignoreUnknownFormats: false,\n    reportPathAsArray: true\n  });\n}\n/**\n * Z-Schema validation errors are a nested tree structure.\n * This function crawls that tree and builds an error message string.\n *\n * @param {object[]}  errors     - The Z-Schema error details\n * @param {string}    [indent]   - The whitespace used to indent the error message\n * @returns {string}\n */\n\n\nfunction formatZSchemaError(errors, indent) {\n  indent = indent || \"  \";\n  let message = \"\";\n\n  for (let error of errors) {\n    message += util.format(`${indent}${error.message} at #/${error.path.join(\"/\")}\\n`);\n\n    if (error.inner) {\n      message += formatZSchemaError(error.inner, indent + \"  \");\n    }\n  }\n\n  return message;\n}","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/@apidevtools/swagger-parser/lib/validators/schema.js"],"names":["util","require","ono","ZSchema","openapi","module","exports","validateSchema","zSchema","initializeZSchema","api","schema","swagger","v2","v3","isValid","validate","err","getLastError","message","formatZSchemaError","details","syntax","id","registerFormat","value","trim","length","breakOnFirstError","noExtraKeywords","ignoreUnknownFormats","reportPathAsArray","errors","indent","error","format","path","join","inner"],"mappings":"AAAA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,SAAD,CAApB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAUD,OAAO,CAAC,iBAAD,CAAvB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAcH,OAAO,CAAC,8BAAD,CAA3B;;AAEAI,MAAM,CAACC,OAAP,GAAiBC,cAAjB;AAEA,IAAIC,OAAO,GAAGC,iBAAiB,EAA/B;AAEA;;;;;;AAKA,SAASF,cAAT,CAAyBG,GAAzB,EAA8B;AAC5B;AACA,MAAIC,MAAM,GAAGD,GAAG,CAACE,OAAJ,GAAcR,OAAO,CAACS,EAAtB,GAA2BT,OAAO,CAACU,EAAhD,CAF4B,CAI5B;;AACA,MAAIC,OAAO,GAAGP,OAAO,CAACQ,QAAR,CAAiBN,GAAjB,EAAsBC,MAAtB,CAAd;;AAEA,MAAI,CAACI,OAAL,EAAc;AACZ,QAAIE,GAAG,GAAGT,OAAO,CAACU,YAAR,EAAV;AACA,QAAIC,OAAO,GAAG,yCAAyCC,kBAAkB,CAACH,GAAG,CAACI,OAAL,CAAzE;AACA,UAAMnB,GAAG,CAACoB,MAAJ,CAAWL,GAAX,EAAgB;AAAEI,MAAAA,OAAO,EAAEJ,GAAG,CAACI;AAAf,KAAhB,EAA0CF,OAA1C,CAAN;AACD;AACF;AAED;;;;;AAGA,SAASV,iBAAT,GAA8B;AAC5B;AACA,SAAOL,OAAO,CAACS,EAAR,CAAWU,EAAlB;AACA,SAAOnB,OAAO,CAACU,EAAR,CAAWS,EAAlB,CAH4B,CAK5B;AACA;;AACApB,EAAAA,OAAO,CAACqB,cAAR,CAAuB,eAAvB,EAAyCC,KAAD,IAAWA,KAAK,CAACC,IAAN,GAAaC,MAAb,GAAsB,CAAzE,EAP4B,CAS5B;;AACA,SAAO,IAAIxB,OAAJ,CAAY;AACjByB,IAAAA,iBAAiB,EAAE,IADF;AAEjBC,IAAAA,eAAe,EAAE,IAFA;AAGjBC,IAAAA,oBAAoB,EAAE,KAHL;AAIjBC,IAAAA,iBAAiB,EAAE;AAJF,GAAZ,CAAP;AAMD;AAED;;;;;;;;;;AAQA,SAASX,kBAAT,CAA6BY,MAA7B,EAAqCC,MAArC,EAA6C;AAC3CA,EAAAA,MAAM,GAAGA,MAAM,IAAI,IAAnB;AACA,MAAId,OAAO,GAAG,EAAd;;AACA,OAAK,IAAIe,KAAT,IAAkBF,MAAlB,EAA0B;AACxBb,IAAAA,OAAO,IAAInB,IAAI,CAACmC,MAAL,CAAa,GAAEF,MAAO,GAAEC,KAAK,CAACf,OAAQ,SAAQe,KAAK,CAACE,IAAN,CAAWC,IAAX,CAAgB,GAAhB,CAAqB,IAAnE,CAAX;;AACA,QAAIH,KAAK,CAACI,KAAV,EAAiB;AACfnB,MAAAA,OAAO,IAAIC,kBAAkB,CAACc,KAAK,CAACI,KAAP,EAAcL,MAAM,GAAG,IAAvB,CAA7B;AACD;AACF;;AACD,SAAOd,OAAP;AACD","sourcesContent":["\"use strict\";\n\nconst util = require(\"../util\");\nconst { ono } = require(\"@jsdevtools/ono\");\nconst ZSchema = require(\"z-schema\");\nconst { openapi } = require(\"@apidevtools/openapi-schemas\");\n\nmodule.exports = validateSchema;\n\nlet zSchema = initializeZSchema();\n\n/**\n * Validates the given Swagger API against the Swagger 2.0 or 3.0 schema.\n *\n * @param {SwaggerObject} api\n */\nfunction validateSchema (api) {\n  // Choose the appropriate schema (Swagger or OpenAPI)\n  let schema = api.swagger ? openapi.v2 : openapi.v3;\n\n  // Validate against the schema\n  let isValid = zSchema.validate(api, schema);\n\n  if (!isValid) {\n    let err = zSchema.getLastError();\n    let message = \"Swagger schema validation failed. \\n\" + formatZSchemaError(err.details);\n    throw ono.syntax(err, { details: err.details }, message);\n  }\n}\n\n/**\n * Performs one-time initialization logic to prepare for Swagger Schema validation.\n */\nfunction initializeZSchema () {\n  // HACK: Delete the OpenAPI schema IDs because ZSchema can't resolve them\n  delete openapi.v2.id;\n  delete openapi.v3.id;\n\n  // The OpenAPI 3.0 schema uses \"uri-reference\" formats.\n  // Assume that any non-whitespace string is valid.\n  ZSchema.registerFormat(\"uri-reference\", (value) => value.trim().length > 0);\n\n  // Configure ZSchema\n  return new ZSchema({\n    breakOnFirstError: true,\n    noExtraKeywords: true,\n    ignoreUnknownFormats: false,\n    reportPathAsArray: true\n  });\n}\n\n/**\n * Z-Schema validation errors are a nested tree structure.\n * This function crawls that tree and builds an error message string.\n *\n * @param {object[]}  errors     - The Z-Schema error details\n * @param {string}    [indent]   - The whitespace used to indent the error message\n * @returns {string}\n */\nfunction formatZSchemaError (errors, indent) {\n  indent = indent || \"  \";\n  let message = \"\";\n  for (let error of errors) {\n    message += util.format(`${indent}${error.message} at #/${error.path.join(\"/\")}\\n`);\n    if (error.inner) {\n      message += formatZSchemaError(error.inner, indent + \"  \");\n    }\n  }\n  return message;\n}\n"]},"metadata":{},"sourceType":"script"}