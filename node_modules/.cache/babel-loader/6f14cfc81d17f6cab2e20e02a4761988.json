{"ast":null,"code":"\"use strict\";\n\nvar reduce = require(\"reducible/reduce\");\n\nvar isError = require(\"reducible/is-error\");\n\nvar isReduced = require(\"reducible/is-reduced\");\n\nvar end = require(\"reducible/end\");\n\nvar hub = require(\"./hub\");\n\nfunction Promise() {\n  this.delivered = false;\n  this.next = void 0;\n  this.initial = void 0;\n}\n\nreduce.define(Promise, function reducePromise(promise, next, initial) {\n  if (promise.delivered) return reduce(promise.value, next, initial);\n  promise.next = next;\n  promise.initial = initial;\n});\n\nfunction deliver(promise, value) {\n  promise.delivered = true;\n  promise.value = value;\n  if (promise.next) reduce(value, promise.next, promise.initial);\n}\n\nfunction fold(source, next, initial) {\n  /**\n  Fold is just like `reduce` with a difference that `next` reducer / folder\n  function it takes has it's parameters reversed. One always needs `value`,\n  but not always accumulated one. To avoid conflict with array `reduce` we\n  have a `fold`.\n  **/\n  var promise = new Promise();\n  reduce(source, function fold(value, state) {\n    // If source is `end`-ed deliver accumulated `state`.\n    // If is source has an error, deliver that.\n    if (isError(value)) {\n      deliver(promise, value);\n      throw value;\n    }\n\n    if (value === end) return deliver(promise, state); // Accumulate new `state`\n\n    state = next(value, state); // If already reduced, then deliver.\n\n    if (isReduced(state)) deliver(promise, state.value);\n    return state;\n  }, initial);\n  return promise.delivered ? promise.value : hub(promise);\n}\n\nmodule.exports = fold;","map":{"version":3,"sources":["/Users/suleymantarsuslu/Desktop/graduateApp/new/graduate/node_modules/reducers/fold.js"],"names":["reduce","require","isError","isReduced","end","hub","Promise","delivered","next","initial","define","reducePromise","promise","value","deliver","fold","source","state","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,kBAAD,CAApB;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,oBAAD,CAArB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,sBAAD,CAAvB;;AACA,IAAIG,GAAG,GAAGH,OAAO,CAAC,eAAD,CAAjB;;AACA,IAAII,GAAG,GAAGJ,OAAO,CAAC,OAAD,CAAjB;;AAEA,SAASK,OAAT,GAAmB;AACjB,OAAKC,SAAL,GAAiB,KAAjB;AACA,OAAKC,IAAL,GAAY,KAAK,CAAjB;AACA,OAAKC,OAAL,GAAe,KAAK,CAApB;AACD;;AACDT,MAAM,CAACU,MAAP,CAAcJ,OAAd,EAAuB,SAASK,aAAT,CAAuBC,OAAvB,EAAgCJ,IAAhC,EAAsCC,OAAtC,EAA+C;AACpE,MAAIG,OAAO,CAACL,SAAZ,EAAuB,OAAOP,MAAM,CAACY,OAAO,CAACC,KAAT,EAAgBL,IAAhB,EAAsBC,OAAtB,CAAb;AACvBG,EAAAA,OAAO,CAACJ,IAAR,GAAeA,IAAf;AACAI,EAAAA,OAAO,CAACH,OAAR,GAAkBA,OAAlB;AACD,CAJD;;AAMA,SAASK,OAAT,CAAiBF,OAAjB,EAA0BC,KAA1B,EAAiC;AAC/BD,EAAAA,OAAO,CAACL,SAAR,GAAoB,IAApB;AACAK,EAAAA,OAAO,CAACC,KAAR,GAAgBA,KAAhB;AACA,MAAID,OAAO,CAACJ,IAAZ,EAAkBR,MAAM,CAACa,KAAD,EAAQD,OAAO,CAACJ,IAAhB,EAAsBI,OAAO,CAACH,OAA9B,CAAN;AACnB;;AAGD,SAASM,IAAT,CAAcC,MAAd,EAAsBR,IAAtB,EAA4BC,OAA5B,EAAqC;AACnC;;;;;;AAMA,MAAIG,OAAO,GAAG,IAAIN,OAAJ,EAAd;AACAN,EAAAA,MAAM,CAACgB,MAAD,EAAS,SAASD,IAAT,CAAcF,KAAd,EAAqBI,KAArB,EAA4B;AACzC;AACA;AACA,QAAIf,OAAO,CAACW,KAAD,CAAX,EAAoB;AAClBC,MAAAA,OAAO,CAACF,OAAD,EAAUC,KAAV,CAAP;AACA,YAAMA,KAAN;AACD;;AACD,QAAIA,KAAK,KAAKT,GAAd,EAAmB,OAAOU,OAAO,CAACF,OAAD,EAAUK,KAAV,CAAd,CAPsB,CASzC;;AACAA,IAAAA,KAAK,GAAGT,IAAI,CAACK,KAAD,EAAQI,KAAR,CAAZ,CAVyC,CAWzC;;AACA,QAAId,SAAS,CAACc,KAAD,CAAb,EAAsBH,OAAO,CAACF,OAAD,EAAUK,KAAK,CAACJ,KAAhB,CAAP;AAEtB,WAAOI,KAAP;AACD,GAfK,EAeHR,OAfG,CAAN;AAiBA,SAAOG,OAAO,CAACL,SAAR,GAAoBK,OAAO,CAACC,KAA5B,GAAoCR,GAAG,CAACO,OAAD,CAA9C;AACD;;AAEDM,MAAM,CAACC,OAAP,GAAiBJ,IAAjB","sourcesContent":["\"use strict\";\n\nvar reduce = require(\"reducible/reduce\")\nvar isError = require(\"reducible/is-error\")\nvar isReduced = require(\"reducible/is-reduced\")\nvar end = require(\"reducible/end\")\nvar hub = require(\"./hub\")\n\nfunction Promise() {\n  this.delivered = false\n  this.next = void(0)\n  this.initial = void(0)\n}\nreduce.define(Promise, function reducePromise(promise, next, initial) {\n  if (promise.delivered) return reduce(promise.value, next, initial)\n  promise.next = next\n  promise.initial = initial\n})\n\nfunction deliver(promise, value) {\n  promise.delivered = true\n  promise.value = value\n  if (promise.next) reduce(value, promise.next, promise.initial)\n}\n\n\nfunction fold(source, next, initial) {\n  /**\n  Fold is just like `reduce` with a difference that `next` reducer / folder\n  function it takes has it's parameters reversed. One always needs `value`,\n  but not always accumulated one. To avoid conflict with array `reduce` we\n  have a `fold`.\n  **/\n  var promise = new Promise()\n  reduce(source, function fold(value, state) {\n    // If source is `end`-ed deliver accumulated `state`.\n    // If is source has an error, deliver that.\n    if (isError(value)) {\n      deliver(promise, value)\n      throw value\n    }\n    if (value === end) return deliver(promise, state)\n\n    // Accumulate new `state`\n    state = next(value, state)\n    // If already reduced, then deliver.\n    if (isReduced(state)) deliver(promise, state.value)\n\n    return state\n  }, initial)\n\n  return promise.delivered ? promise.value : hub(promise)\n}\n\nmodule.exports = fold\n"]},"metadata":{},"sourceType":"script"}